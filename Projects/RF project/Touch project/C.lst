            ;=========================Include <OPTION.INC> Start=========================
            //--------------------------------------------------------------------------------------------------
            // TRITAN FDSP-IDE Option define file.
            // WARNING! All changes made in this file will be lost when recompiling.
            //--------------------------------------------------------------------------------------------------
            // Part number    : TRSF16127A
            // Option version : 2.9
            // Base Information--------------------------------------------------------------------------------
            #define       _OPT_TRSF16127A_                
            #define       _OPT_PROMSize_                0x20000   //PROM Size
            #define       _OPT_SRAMSize_                3072      //SRAM Size
            // I/O Configuration--------------------------------------------------------------------------------
            #define       _OPT_EXTReset_EN_             0         //EXT Reset Enable,0:Disable,1:Enable
            #define       _OPT_EXTINT1_EN_              0         //EXTINT1_EN,0:Disable,1:Enable
            #define       _OPT_EXTINT0_EN_              0         //EXTINT0_EN,0:Disable,1:Enable
            #define       _OPT_SpreadSpectrum_          0         //Spread Spectrum Enable,0:Disable,1:Enable
            #define       _OPT_EXTResetPin_             0         //EXT Reset Pin Select,0:PB3,1:PC3
            #define       _OPT_EXTINT1_INV_             0         //EXTINT1_INV,0:Disable,1:Enable
            #define       _OPT_EXTINT0_INV_             0         //EXTINT0_INV,0:Disable,1:Enable
            // Memory Configuration-----------------------------------------------------------------------------
            #define       _OPT_PRAMBank_                0         //PRAM Bank
            #define       _OPT_PRAMSize_                0         //PRAM Size(Words)
            #define       _OPT_WriteSegmentProtection_  0x0FFFF   //Write Segment Protection(0000H~ )
            // System Control Setup-----------------------------------------------------------------------------
            #define       _OPT_Bank0Speed_              11        //Bank0 Speed(MHz)
            #define       _OPT_RTCINT_                  1         //RTC interrupt,0:Disable,1:Enable
            #define       _OPT_RTCinHalt_               0         //RTC LP32K in Halt Mode,0:Disable,1:Enable
            #define       _OPT_LVR_                     2200      //LVR(mv)
            #define       _OPT_WatchDog_                256       //Watch dog(ms)
            #define       _OPT_ICEEnable_               1         //ICE Disable/Enable,0:Disable,1:Enable
            // Audio Configuration------------------------------------------------------------------------------
            #define       _OPT_AudioSamplingRate_       32        //Audio Sampling Rate(KHz)
            #define       _OPT_PWMBit_                  16        //PWM Bit
            #define       _OPT_DACFIFO_                 1         //DAC FIFO,0:Disable,1:Enable
            //--------------------------------------------------------------------------------------------------
            ;=========================Include <OPTION.INC> End=========================
            
            #define DSP_SRAM_SIZE		3072
            #define DSP_VECT_SUPPORT		6
            #define _PROJECT_CONFIG_FILE_		
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> Start=========================
            
            ; =====================
            ;      COMMON I/O
            ; =====================
            
            #ifdef _MFDSP_
            
            ; {
            	STATUS          EQU             00H             ;R/W, BIT0: Zero.
            							;R/W, BIT1: Carry.
            							;R/W, BIT2: Overflow.
            							;R/W, BIT3: Negative.
            							;R/W, BIT7: Global Interrupt Enable.
            							;R/W, BIT[12:8]: SD_EN, TRA_EN, ADH_EN, SPIS_EN, SPIM_EN.
            							;R/W, BIT13: Interrupt Vector Table Access Enable.
            							;R/W, BIT14: Filter Buffer Available.
            							;R/W, BIT15: Parser Buffer Available.
            
            	INTENA          EQU             01H             ;R/W, Int Enable.
            	INTREQ          EQU             02H             ;R/W, Int Request.
            	IntVect         EQU             03H             ;R/W, Interrupt Table
            	IOC_PA          EQU             04H             ;R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB          EQU             05H             ;R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PCI         EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PC          EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA           EQU             07H             ;R/W, General input/output port.
            	PortB           EQU             08H             ;R/W, General input/output port.
            	PortCI          EQU             09H             ;R/W, General input/output port.
            	PortC           EQU             09H             ;R/W, General input/output port.
            	INTMASK         EQU             0AH             ;R/W, Int Mask.
            	SPIS_CTL        EQU             0BH             ;R/W, SPI slaver control register.
            	SPIS_DAT        EQU             0CH             ;R/W, SPI slaver data    register.
            	SPI_CTL         EQU             0DH             ;R/W, SPI master control register.
            	SPI_DAT         EQU             0EH             ;R/W, SPI master data    register.
            	SD_CTL          EQU             0FH             ;R/W, SD card interface control register.
            	SD_DAT          EQU             10H             ;R/W, SD card interface data.
            	SD_RSP          EQU             11H             ;R/W, SD card interface response register.
            	UART_CTL        EQU             12H
            	UART_DAT        EQU             13H
            	DPPWM           EQU             14H
            	//------------------------------------
            	PUPD_PA         EQU             15H             ;R/W, PortA  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	DACL            EQU             16H
            	DACR            EQU             17H
            	USB_CTL         EQU             18H
            	USB_DAT         EQU             19H
            	PUPD_PB         EQU             1AH             ;R/W, PortB  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	PUPD_PC         EQU             1BH             ;R/W, PortC  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	MISC            EQU             1CH
            	ClrWDT          EQU             1DH             ;W, Clear Watch-dog reset.
            	Real_T          EQU             1DH             ;R, System Real-Time Counter, base on 31.25us
            	IOP_IX          EQU             1EH             ;W, Programming IO Port index .
            	IOP_DAT         EQU             1FH             ;W, Programming IO Port Data .
            
            	//------------------------------------
            	// Virtual         Program IO Port
            	IOP_Timer1      EQU             00H
            	IOP_Timer2      EQU             01H
            	IOP_RTC32K      EQU             02H
            	IOP_PreScale    EQU             03H
            	IOP_FGREEN32K   EQU             04H
            	IOP_ODEN_PA     EQU             05H
            	IOP_ODEN_PB     EQU             06H
            	IOP_ODEN_PC     EQU             07H
            
            	IOP_TOUCH_CFG   EQU             08H
            	IOP_TOUCH_DAT   EQU             09H
            
            	IOP_CLK_CFG     EQU             0AH
            	IOP_CLK_DAT1    EQU             0BH
            	IOP_CLK_DAT2    EQU             0CH
            	IOP_CUR_PA      EQU             0DH
            	IOP_CUR_PB      EQU             0EH
            	IOP_CUR_PC      EQU             0FH
            
            	//------------------------------------
            	// IO[0x40-0x7F]
            	ADH_CFG0        EQU             40H
            	ADH_CFG1        EQU             41H
            	ADH_CFG2        EQU             42H
            	ADH_CFG3        EQU             43H
            	ADH_DO          EQU             44H
            
            	ADL_CFG         EQU             45H
            
            	TRA_CFG         EQU             46H
            	TRA_DAT         EQU             47H
            
            	I2C_CTL         EQU             48H
            	I2C_DAT         EQU             49H
            	I2C_CMD         EQU             4AH
            	I2C_SR          EQU             4AH             ; same as I2C_CMD
            
            	I80_CTL         EQU             4BH
            	I80_INX         EQU             4CH
            	I80_DAT         EQU             4DH
            	I80_RADR        EQU             4EH
            	I80_DMANUM      EQU             4FH
            
            	SD_DMA_CTL      EQU             50H
            	SD_DMA_RADR     EQU             51H
            	SD_DMA_DMANUM   EQU             52H
            
            	SPI_DMA_CTL     EQU             53H
            	SPI_DMA_RADR    EQU             54H
            	SPI_DMA_DMANUM  EQU             55H
            
            	USB_DMA_CTL     EQU             56H
            	USB_DMA_RADR    EQU             57H
            	USB_DMA_DMANUM  EQU             58H
            
            	SSC             EQU             63H
            	MIC             EQU             64H
            	GREEN           EQU             65H
            	SLEEP           EQU             66H
            	SPEED           EQU             67H
            	PR              EQU             68H
            
            	//------------------------------------
            	IOP_WAKEN_PA    EQU             10H
            	IOP_WAKEN_PB    EQU             11H
            	IOP_WAKEN_PC    EQU             12H
            ; }
            
            #endif
            
            
            
            
            #ifdef _MSPEECHDSP_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            
            #ifdef _MSPEECHDSP2_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            #ifdef _MFDSP2_
            
            ; {
            
            	STATUS	     EQU    00H	      ; R/W, BIT0: Zero.
            				      ; R/W, BIT1: Carry.
            				      ; R/W, BIT2: Overflow.
            				      ; R/W, BIT3: Negative.
            				      ; R/W, BIT5: UART_EN
            				      ; R/W, BIT7: Global Interrupt Enable.
            				      ; R/W, BIT8: SPIM_EN
            				      ; R/W, BIT9: SPIS_EN
            				      ; R/W, BIT12: BANK15
            				      ; R/W, BIT13: Interrupt Vector Table Access Enable.
            				      ; R/W, BIT14: Filter Buffer Available.
            				      ; R/W, BIT15: Parser Buffer Available.
            	INTENA	     EQU    01H	      ; R/W, Int Enable.
            	INTREQ	     EQU    02H	      ; R/W, Int Request.
            	IntVect	     EQU    03H	      ; R/W, Interrupt Table
            	IOC_PA	     EQU    04H	      ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB	     EQU    05H	      ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC	     EQU    06H	      ; R/W, PortC IO control. ('0' = input,'1' = output)
            	IOC_PCI	     EQU    06H
            	PortA	     EQU    07H	      ; R/W, General input/output port.
            	PortB	     EQU    08H	      ; R/W, General input/output port.
            	PortC	     EQU    09H	      ; R/W, General input/output port.
            	PortC2	     EQU    09H
            	PortCI	     EQU    09H
            	IntMask	     EQU    0AH
            	SPIS_CTL     EQU    0BH	      ; W,   Specical Peripheral control register.
            	SPIS_DAT     EQU    0CH	      ; W,   Specical Peripheral control register.
            	SPI_CTL	     EQU    0DH	      ; R/W, Serial interface control register.
            	SPI_DAT	     EQU    0EH	      ; R/W, Serial interface data.
            	SPIM_CTL     EQU    0DH	      ; R/W, Serial interface control register.
            	SPIM_DAT     EQU    0EH	      ; R/W, Serial interface data.
            
            	UART_CTL     EQU    12H
            	UART_DAT     EQU    13H
            
            	; ------------------------------------
            
            	MISC6	     EQU    15H
            	DACL	     EQU    16H	      ;W, DAC output L Channel.
            	DACR	     EQU    17H	      ;W, DAC output R Channel.
            
            	MISC5	     EQU    18H
            	MISC4	     EQU    19H
            	MISC3	     EQU    1AH
            	MISC2	     EQU    1BH
            	MISC	     EQU    1CH
            
            	ClrWDT	     EQU    1DH	      ;W, Clear Watch-dog reset.
            	Real_T	     EQU    1DH	      ;R, System Real-Time Counter, base on 31.25us
            	IOP_IX	     EQU    1EH	      ;W, Programming IO Port index .
            	IOP_DAT	     EQU    1FH	      ;W, Programming IO Port Data .
            
            	; ------------------------------------
            	; Virtual Program IO Port
            
            	IOP_Timer1    EQU    00H
            	IOP_Timer2    EQU    01H
            	IOP_RTC32K    EQU    02H
            	IOP_FetchCNT  EQU    03H
            
            	IOP_PA_PDEN   EQU    05H
            	IOP_PB_PDEN   EQU    06H
            	IOP_PCI_PDEN  EQU    07H
            
            	IOP_PA_PUEN   EQU    08H
            	IOP_PB_PUEN   EQU    09H
            	IOP_PCI_PUEN  EQU    0AH
            
            	IOP_PA_PDSEL  EQU    0BH
            	IOP_PB_PDSEL  EQU    0CH
            	IOP_PCI_PDSEL EQU    0DH
            
            	IOP_PA_TOUCH  EQU    0EH
            	IOP_PB_TOUCH  EQU    0FH
            	IOP_PCI_TOUCH EQU    10H
            
            	IOP_PA_ODEN   EQU    11H
            	IOP_PB_ODEN   EQU    12H
            	IOP_PCI_ODEN  EQU    13H
            
            	IOP_WAKEN_PA  EQU    14H
            	IOP_WAKEN_PB  EQU    15H
            	IOP_WAKEN_PC  EQU    16H
            
            	IOP_WAKELV_PA EQU    17H
            	IOP_WAKELV_PB EQU    18H
            	IOP_WAKELV_PC EQU    19H
            
            	IOP_WAKEDLV_PB EQU   1AH
            
            	IOP_DEEP_SLEEP1 EQU  1BH
            	IOP_DEEP_SLEEP2 EQU  1CH
            	IOP_DEBOUNCE_T1 EQU  1DH
            	IOP_DEBOUNCE_T2 EQU  1EH
            
            
            	; ------------------------------------
            	; IO[0x40-0x7F]
            
            
            	ADH_CFG0      EQU    40H
            	ADH_CFG1      EQU    41H
            	ADH_CFG2      EQU    42H
            	ADH_DO	      EQU    44H
            
            	I2C_CTL	      EQU    48H
            	I2C_DAT	      EQU    49H
            	I2C_CMD	      EQU    4AH
            	I2C_SR	      EQU    4AH	    ; same as I2C_CMD
            
            	ADH2_CFG0     EQU    4BH
            	ADH2_CFG1     EQU    4CH
            	ADH2_CFG2     EQU    4DH
            	ADH2_DO       EQU    4FH
            
            	TRA_CFG       EQU    46H
            	TRA_DAT       EQU    47H
            
            	ENC_DAT	      EQU    54H
            	SSC           EQU    63H
            	SPEED	      EQU    67H
            ; }
            
            #endif
            
            
            ;-----------------------------------------------------------
            
            #ifdef NO_OPTIMAL_RM
            
            
            #else
            
            #define Optimal_RM	; Optimal RAM function Enable
            
            #endif
            
            
            VarRM[0:127] = {
            BP_SAVE,
            
            }
            
            VarRM[128:511] = {
            
            }
            
            VarRM[512:4095] = {
            
            }
            
            ShareVar = {
            
            }
            
            ;--------------------------------------------------------------------
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> Start=========================
            
            	org	0000h
            RSTB_ENTRY:
00000:      	PCH=		SYS_PROG_ENTRY
00001:      	ljmp		SYS_PROG_ENTRY
            
            
            	org	0004h
            WAKEUP_ENTRY:
00004:      	PCH=		WAKEUP_PROC
00005:      	ljmp		WAKEUP_PROC
            
            
            	org	0100h
            
            
            
            SYS_PROG_ENTRY:
            	; ~~ DSP initial
            
00100:      	dsi
00101:      	nop
00102:      	AR=		@STACKBOTTOM
00104:      	BP=		AR
            
            #ifdef KEEP_SRAM_DATA
            
            
            #else
00105:      	AR=		DSP_SRAM_SIZE
00107:      	AR--
00108:      	CX=		AR
00109:      	I1=		AR
0010A:      	AR=		0
            @clearram_loop_1705:
0010B:      	rm[I1--]=	AR
0010C:      	loop		@clearram_loop_1705
            #endif
            
0010D:      	io[ClrWDT]=	AR
            
0010E:      	set		io[STATUS].b13
0010F:      	CX=		DSP_VECT_SUPPORT
00110:      	P1=		#IntVectTable
00113:      	jmp		@setintvect_label_1548
            @setintvect_loop_1548:
00114:      	AR=		pm[P1++]
00115:      	io[IntVect]=	AR
            @setintvect_label_1548:
00116:      	loop		@setintvect_loop_1548
            
00117:      	clr		io[STATUS].b13
            
            	; ~~ C code
            
            #ifdef PRAM_BANK
            	PCH=		sfx_DynFastCallInit
            	lcall		sfx_DynFastCallInit
            #endif
            
00118:      	PCH=		ginit_code
00119:      	lcall		ginit_code
            
0011A:      	PCH=		_main
0011B:      	ljmp		_main
            
            
            /* ================================================================= */
            // ------------- Interrupt Service Routine--------------------------
            /* ================================================================= */
            
            EMPTY_INTENTRY:
0011C:      	reti
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> End=========================
            
            ;=========================Include <DEPS\C_D568E6C1.S.CODE.ASM> Start=========================
            ; C.C Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _main();
            ; //rjmp void _KeyPlayAdpECABF1D0();
            ; //rjmp void _KeyPlayNextAFBA8CED();
            ; //rjmp void _KeyPlayPrev8E98A35A();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _main()				
            _main:
            ; //{
            ; //_A569F39CC_0:;					
            _A569F39CC_0:
            ; //	
            ; //_A569F39CC_1:;					
            _A569F39CC_1:
            ; //_A569F39CC_2:;					
            _A569F39CC_2:
            ; //	_InitialDA4A7CC4();			
0011D:      	pch	= _InitialDA4A7CC4
0011E:      	lcall	_InitialDA4A7CC4
            ; //_A569F39CC_3:;					
            _A569F39CC_3:
            ; //_A569F39CC_4:;					
            _A569F39CC_4:
            ; //	_InitKey3C587B6D();			
0011F:      	pch	= _InitKey3C587B6D
00120:      	lcall	_InitKey3C587B6D
            ; //_A569F39CC_5:;					
            _A569F39CC_5:
            ; //_A569F39CC_6:;					
            _A569F39CC_6:
            ; //	ADPCM_CHX_Init();			
00121:      	pch	= ADPCM_CHX_Init
00122:      	lcall	ADPCM_CHX_Init
            ; //_A569F39CC_7:;					
            _A569F39CC_7:
            ; //	sAX	= 0x0001;			
00123:      	AX	= 0x01
            ; //	asm I1 = CopyToBank+0;			
00124:      	I1 = CopyToBank+0//
            ; //	*(__int16*)sSI	= sAX			
00125:      	rm[I1]	= AX
            ; //_A569F39CC_8:;					
            _A569F39CC_8:
            ; //	asm	set io[INTENA].b0		
00126:      	set io[INTENA].b0
            ; //_A569F39CC_9:;					
            _A569F39CC_9:
            ; //	asm	eni				
00127:      	eni
            ; //_A569F39CC_10:;					
            _A569F39CC_10:
            ; //_A569F39CC_11:;					
            _A569F39CC_11:
            ; //	_touch_init378E5983();			
00128:      	pch	= _touch_init378E5983
00129:      	lcall	_touch_init378E5983
            ; //LE6FF7BEA_5:;					
            LE6FF7BEA_5:
            ; //_A569F39CC_12:;					
            _A569F39CC_12:
            ; //_A569F39CC_13:;					
            _A569F39CC_13:
            ; //	asm	io[ClrWDT] = AR			
0012A:      	io[ClrWDT] = AR
            ; //	
            ; //_A569F39CC_14:;					
            _A569F39CC_14:
            ; //_A569F39CC_15:;					
            _A569F39CC_15:
            ; //	_PollingKey3B90E3B1();			
0012B:      	pch	= _PollingKey3B90E3B1
0012C:      	lcall	_PollingKey3B90E3B1
            ; //_A569F39CC_16:;					
            _A569F39CC_16:
            ; //_A569F39CC_17:;					
            _A569F39CC_17:
            ; //	_DoADPCM9CD0E20D();			
0012D:      	pch	= _DoADPCM9CD0E20D
0012E:      	lcall	_DoADPCM9CD0E20D
            ; //_A569F39CC_18:;					
            _A569F39CC_18:
            ; //	goto LE6FF7BEA_5;			
0012F:      	jmp	LE6FF7BEA_5
            ; //LE6FF7BEA_4:;					
            LE6FF7BEA_4:
            ; //LE6FF7BEA_3:;					
            LE6FF7BEA_3:
            ; //_A569F39CC_19:;					
            _A569F39CC_19:
            ; //	return;					
00130:      	rets
            ; //_main_end:;					
            _main_end:
            ; //_A569F39CC_20:;					
            _A569F39CC_20:
            ; //}
            ; //
            ; //rjmp void _KeyPlayAdpECABF1D0()			
            _KeyPlayAdpECABF1D0:
            ; //{
            ; //_A569F39CC_21:;					
            _A569F39CC_21:
            ; //	
            ; //_A569F39CC_22:;					
            _A569F39CC_22:
            ; //_A569F39CC_23:;					
            _A569F39CC_23:
            ; //	asm I1 = _iADPCCACC469+0;		
00131:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
00132:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
00133:      	push	AX
            ; //	_playADPCMBACD5AFD(STACK[sSP + 0]);	
00134:      	pch	= _playADPCMBACD5AFD
00135:      	lcall	_playADPCMBACD5AFD
            ; //	RESTORESP(1);				
00136:      	pop	AR
            ; //LE6FF7BEA_6:;					
            LE6FF7BEA_6:
            ; //_A569F39CC_24:;					
            _A569F39CC_24:
            ; //	return;					
00137:      	rets
            ; //_KeyPlayAdpECABF1D0_end:;			
            _KeyPlayAdpECABF1D0_end:
            ; //_A569F39CC_25:;					
            _A569F39CC_25:
            ; //}
            ; //
            ; //rjmp void _KeyPlayNextAFBA8CED()		
            _KeyPlayNextAFBA8CED:
            ; //{
            ; //_A569F39CC_26:;					
            _A569F39CC_26:
            ; //	
            ; //_A569F39CC_27:;					
            _A569F39CC_27:
            ; //	asm I1 = _iADPCCACC469+0;		
00138:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
00139:      	AX	= rm[I1]
            ; //	sSI	= (int)&_iADPCCACC469;		
0013A:      	I1	= _iADPCCACC469
            ; //	sCX	= *(__int16*)sSI;		
0013B:      	CX	= rm[I1]
            ; //	sCX++;					
0013C:      	CX++
            ; //	*(__int16*)sSI	= sCX;			
0013D:      	rm[I1]	= CX
            ; //_A569F39CC_28:;					
            _A569F39CC_28:
            ; //	asm I1 = _iADPCCACC469+0;		
0013E:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
0013F:      	AX	= rm[I1]
            ; //	sCX	= 0x0009;			
00140:      	CX	= 0x09
            ; //	sfx_CMP_AX_CX_JGE();			
00141:      	pch	= sfx_CMP_AX_CX_JGE
00142:      	lcall	sfx_CMP_AX_CX_JGE
            ; //	if(__je__)	goto LE6FF7BEA_9;	
00143:      	if ZR	jmp LE6FF7BEA_9
            ; //	goto	LE6FF7BEA_8;			
00144:      	jmp	LE6FF7BEA_8
            ; //LE6FF7BEA_9:;					
            LE6FF7BEA_9:
            ; //_A569F39CC_29:;					
            _A569F39CC_29:
            ; //	sAX	= 0x0000;			
00145:      	AX	= 0x00
            ; //	asm I1 = _iADPCCACC469+0;		
00146:      	I1 = _iADPCCACC469+0//
            ; //	*(__int16*)sSI	= sAX			
00147:      	rm[I1]	= AX
            ; //LE6FF7BEA_8:;					
            LE6FF7BEA_8:
            ; //_A569F39CC_30:;					
            _A569F39CC_30:
            ; //_A569F39CC_31:;					
            _A569F39CC_31:
            ; //_A569F39CC_32:;					
            _A569F39CC_32:
            ; //	_KeyPlayAdpECABF1D0();			
00148:      	pch	= _KeyPlayAdpECABF1D0
00149:      	lcall	_KeyPlayAdpECABF1D0
            ; //LE6FF7BEA_7:;					
            LE6FF7BEA_7:
            ; //_A569F39CC_33:;					
            _A569F39CC_33:
            ; //	return;					
0014A:      	rets
            ; //_KeyPlayNextAFBA8CED_end:;			
            _KeyPlayNextAFBA8CED_end:
            ; //_A569F39CC_34:;					
            _A569F39CC_34:
            ; //}
            ; //
            ; //rjmp void _KeyPlayPrev8E98A35A()		
            _KeyPlayPrev8E98A35A:
            ; //{
            ; //_A569F39CC_35:;					
            _A569F39CC_35:
            ; //	
            ; //_A569F39CC_36:;					
            _A569F39CC_36:
            ; //	asm I1 = _iADPCCACC469+0;		
0014B:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
0014C:      	AX	= rm[I1]
            ; //	sSI	= (int)&_iADPCCACC469;		
0014D:      	I1	= _iADPCCACC469
            ; //	sCX	= *(__int16*)sSI;		
0014E:      	CX	= rm[I1]
            ; //	sCX--;					
0014F:      	CX--
            ; //	*(__int16*)sSI	= sCX;			
00150:      	rm[I1]	= CX
            ; //_A569F39CC_37:;					
            _A569F39CC_37:
            ; //	asm I1 = _iADPCCACC469+0;		
00151:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
00152:      	AX	= rm[I1]
            ; //	sCX	= 0x0000;			
00153:      	CX	= 0x00
            ; //	sfx_CMP_AX_CX_JL();			
00154:      	pch	= sfx_CMP_AX_CX_JL
00155:      	lcall	sfx_CMP_AX_CX_JL
            ; //	if(__je__)	goto LE6FF7BEA_12;	
00156:      	if ZR	jmp LE6FF7BEA_12
            ; //	goto	LE6FF7BEA_11;			
00157:      	jmp	LE6FF7BEA_11
            ; //LE6FF7BEA_12:;					
            LE6FF7BEA_12:
            ; //_A569F39CC_38:;					
            _A569F39CC_38:
            ; //	sAX	= 0x0005;			
00158:      	AX	= 0x05
            ; //	asm I1 = _iADPCCACC469+0;		
00159:      	I1 = _iADPCCACC469+0//
            ; //	*(__int16*)sSI	= sAX			
0015A:      	rm[I1]	= AX
            ; //LE6FF7BEA_11:;					
            LE6FF7BEA_11:
            ; //_A569F39CC_39:;					
            _A569F39CC_39:
            ; //_A569F39CC_40:;					
            _A569F39CC_40:
            ; //_A569F39CC_41:;					
            _A569F39CC_41:
            ; //	_KeyPlayAdpECABF1D0();			
0015B:      	pch	= _KeyPlayAdpECABF1D0
0015C:      	lcall	_KeyPlayAdpECABF1D0
            ; //LE6FF7BEA_10:;					
            LE6FF7BEA_10:
            ; //_A569F39CC_42:;					
            _A569F39CC_42:
            ; //	return;					
0015D:      	rets
            ; //_KeyPlayPrev8E98A35A_end:;			
            _KeyPlayPrev8E98A35A_end:
            ; //_A569F39CC_43:;					
            _A569F39CC_43:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //__int16 _keyfuncF06F3D55[15] = {		
            _keyfuncF06F3D55:
            ; //	(int)&_KeyPlayPrev8E98A35A[0], 0x0000, 0x0000, (int)&_KeyPlayAdpECABF1D0[0], 0x0000, 0x0000, (int)&_KeyPlayNextAFBA8CED[0], 0x0000, 
0015E:      DW #_KeyPlayPrev8E98A35A,0x0000,0x0000,#_KeyPlayAdpECABF1D0,0x0000,0x0000,#_KeyPlayNextAFBA8CED,0x0000,
            ; //	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
00166:      DW 0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
            ; //};
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\C_D568E6C1.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\GLOBAL_6037E6D5.S.CODE.ASM> Start=========================
            ; global.c Code Start!!;
            VarRM[0:127]={
             inbuf,outbuf 
            };
            
            ; //// CODE segment					
            VarRM[0:4095]={
             BaseOn128#PCMY[128] 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //interrupt rjmp void _PWM_Entry4EB0B003();
            ; //rjmp void _InitialDA4A7CC4();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //interrupt rjmp void _PWM_Entry4EB0B003()	
            _PWM_Entry4EB0B003:
            ; //{						
0016D:      	push ax
0016E:      	push bx
0016F:      	push cx
00170:      	push dx
00171:      	push r0
00172:      	push r1
00173:      	push r2
00174:      	push r3
00175:      	push i1
00176:      	push p1
00177:      	push mx
00178:      	push mr0
00179:      	push mr1
0017A:      	push mr2
0017B:      	ar = p1.hh
0017C:      	push ar
            ; //_A569F39CC_44:;					
            _A569F39CC_44:
            ; //	
            ; //_A569F39CC_45:;					
            _A569F39CC_45:
            ; //	io[0x02]	= 0x0000;		
0017D:      	AR	= 0x00
0017E:      	io[0x02]	= AR
            ; //_A569F39CC_46:;					
            _A569F39CC_46:
            ; //	asm	push AX				
0017F:      	push AX
            ; //_A569F39CC_47:;					
            _A569F39CC_47:
            ; //	asm	push I0				
00180:      	push I0
            ; //_A569F39CC_48:;					
            _A569F39CC_48:
            ; //	asm	push CBL			
00181:      	push CBL
            ; //_A569F39CC_49:;					
            _A569F39CC_49:
            ; //	io[0x3B]	= 0x0007;		
00182:      	AR	= 0x07
00183:      	io[0x3B]	= AR
            ; //	
            ; //_A569F39CC_50:;					
            _A569F39CC_50:
            ; //	asm AX = rm[outbuf+0];			
00184:      	AX = rm[outbuf+0]//
            ; //_A569F39CC_51:;					
            _A569F39CC_51:
            ; //	asm	AR = AX				
00185:      	AR = AX
            ; //_A569F39CC_52:;					
            _A569F39CC_52:
            ; //	asm	I0 = AR				
00186:      	I0 = AR
            ; //	
            ; //_A569F39CC_53:;					
            _A569F39CC_53:
            ; //_A569F39CC_54:;					
            _A569F39CC_54:
            ; //	read_I0P2();				
00187:      	AX	= rm[I0++2]
            ; //	io[0x16]	= sAX;			
00188:      	AR	= AX
00189:      	io[0x16]	= AR
            ; //_A569F39CC_55:;					
            _A569F39CC_55:
            ; //_A569F39CC_56:;					
            _A569F39CC_56:
            ; //	read_I0P2();				
0018A:      	AX	= rm[I0++2]
            ; //	io[0x16]	= sAX;			
0018B:      	AR	= AX
0018C:      	io[0x16]	= AR
            ; //_A569F39CC_57:;					
            _A569F39CC_57:
            ; //_A569F39CC_58:;					
            _A569F39CC_58:
            ; //	read_I0P2();				
0018D:      	AX	= rm[I0++2]
            ; //	io[0x16]	= sAX;			
0018E:      	AR	= AX
0018F:      	io[0x16]	= AR
            ; //_A569F39CC_59:;					
            _A569F39CC_59:
            ; //_A569F39CC_60:;					
            _A569F39CC_60:
            ; //	read_I0P2();				
00190:      	AX	= rm[I0++2]
            ; //	io[0x16]	= sAX;			
00191:      	AR	= AX
00192:      	io[0x16]	= AR
            ; //_A569F39CC_61:;					
            _A569F39CC_61:
            ; //_A569F39CC_62:;					
            _A569F39CC_62:
            ; //	get_I0();				
00193:      	push	I0
00194:      	pop	AX
            ; //	outbuf+0 = sAX				
00195:      	rm[outbuf+0]	= AX
            ; //_A569F39CC_63:;					
            _A569F39CC_63:
            ; //	asm	pop CBL				
00196:      	pop CBL
            ; //_A569F39CC_64:;					
            _A569F39CC_64:
            ; //	asm	pop I0				
00197:      	pop I0
            ; //_A569F39CC_65:;					
            _A569F39CC_65:
            ; //	asm	pop AX				
00198:      	pop AX
            ; //L0E8FA404_15:;					
            L0E8FA404_15:
            ; //_A569F39CC_66:;					
            _A569F39CC_66:
            ; //	return;					
00199:      	pop ar
0019A:      	p1.hh = ar
0019B:      	pop mr2
0019C:      	pop mr1
0019D:      	pop mr0
0019E:      	pop mx
0019F:      	pop p1
001A0:      	pop i1
001A1:      	pop r3
001A2:      	pop r2
001A3:      	pop r1
001A4:      	pop r0
001A5:      	pop dx
001A6:      	pop cx
001A7:      	pop bx
001A8:      	pop ax
001A9:      	reti
            ; //_PWM_Entry4EB0B003_end:;			
            _PWM_Entry4EB0B003_end:
            ; //_A569F39CC_67:;					
            _A569F39CC_67:
            ; //}
            ; //
            ; //rjmp void L0E8FA404_16()			
            L0E8FA404_16:
            ; //{
            ; //_A569F39CC_68:;					
            _A569F39CC_68:
            ; //	
            ; //_A569F39CC_69:;					
            _A569F39CC_69:
            ; //	io[0x16]	= 0x0000;		
001AA:      	AR	= 0x00
001AB:      	io[0x16]	= AR
            ; //_A569F39CC_70:;					
            _A569F39CC_70:
            ; //	io[0x16]	= 0x0000;		
001AC:      	AR	= 0x00
001AD:      	io[0x16]	= AR
            ; //_A569F39CC_71:;					
            _A569F39CC_71:
            ; //	io[0x16]	= 0x0000;		
001AE:      	AR	= 0x00
001AF:      	io[0x16]	= AR
            ; //_A569F39CC_72:;					
            _A569F39CC_72:
            ; //	io[0x16]	= 0x0000;		
001B0:      	AR	= 0x00
001B1:      	io[0x16]	= AR
            ; //_A569F39CC_73:;					
            _A569F39CC_73:
            ; //	io[0x36]	= 0x0000;		
001B2:      	AR	= 0x00
001B3:      	io[0x36]	= AR
            ; //_A569F39CC_74:;					
            _A569F39CC_74:
            ; //	io[0x36]	= 0x0000;		
001B4:      	AR	= 0x00
001B5:      	io[0x36]	= AR
            ; //_A569F39CC_75:;					
            _A569F39CC_75:
            ; //	io[0x36]	= 0x0000;		
001B6:      	AR	= 0x00
001B7:      	io[0x36]	= AR
            ; //_A569F39CC_76:;					
            _A569F39CC_76:
            ; //	io[0x36]	= 0x0000;		
001B8:      	AR	= 0x00
001B9:      	io[0x36]	= AR
            ; //_A569F39CC_77:;					
            _A569F39CC_77:
            ; //	io[0x36]	= 0x0000;		
001BA:      	AR	= 0x00
001BB:      	io[0x36]	= AR
            ; //_A569F39CC_78:;					
            _A569F39CC_78:
            ; //	io[0x36]	= 0x0000;		
001BC:      	AR	= 0x00
001BD:      	io[0x36]	= AR
            ; //_A569F39CC_79:;					
            _A569F39CC_79:
            ; //	io[0x36]	= 0x0000;		
001BE:      	AR	= 0x00
001BF:      	io[0x36]	= AR
            ; //_A569F39CC_80:;					
            _A569F39CC_80:
            ; //	io[0x36]	= 0x0000;		
001C0:      	AR	= 0x00
001C1:      	io[0x36]	= AR
            ; //_A569F39CC_81:;					
            _A569F39CC_81:
            ; //	io[0x3C]	= 0x003F;		
001C2:      	AR	= 0x3F
001C3:      	io[0x3C]	= AR
            ; //_A569F39CC_82:;					
            _A569F39CC_82:
            ; //	sAX	= io[0x3C];			
001C4:      	AR	= io[0x3C]
001C5:      	AX	= AR
            ; //_A569F39CC_83:;					
            _A569F39CC_83:
            ; //	asm	set io[MISC].b9			
001C6:      	set io[MISC].b9
            ; //_A569F39CC_84:;					
            _A569F39CC_84:
            ; //	asm	set io[MISC].b8			
001C7:      	set io[MISC].b8
            ; //_A569F39CC_85:;					
            _A569F39CC_85:
            ; //	asm	set io[MISC].b4			
001C8:      	set io[MISC].b4
            ; //L0E8FA404_18:;					
            L0E8FA404_18:
            ; //_A569F39CC_86:;					
            _A569F39CC_86:
            ; //	return;					
001C9:      	rets
            ; //L0E8FA404_16_end:;				
            L0E8FA404_16_end:
            ; //_A569F39CC_87:;					
            _A569F39CC_87:
            ; //}
            ; //
            ; //rjmp void L0E8FA404_19()			
            L0E8FA404_19:
            ; //{
            ; //_A569F39CC_88:;					
            _A569F39CC_88:
            ; //	
            ; //_A569F39CC_89:;					
            _A569F39CC_89:
            ; //	io[0x05]	= 0xFFFF;		
001CA:      	AR	= 0xFFFF
001CC:      	io[0x05]	= AR
            ; //_A569F39CC_90:;					
            _A569F39CC_90:
            ; //	io[0x08]	= 0x0000;		
001CD:      	AR	= 0x00
001CE:      	io[0x08]	= AR
            ; //L0E8FA404_21:;					
            L0E8FA404_21:
            ; //_A569F39CC_91:;					
            _A569F39CC_91:
            ; //	return;					
001CF:      	rets
            ; //L0E8FA404_19_end:;				
            L0E8FA404_19_end:
            ; //_A569F39CC_92:;					
            _A569F39CC_92:
            ; //}
            ; //
            ; //rjmp void _InitialDA4A7CC4()			
            _InitialDA4A7CC4:
            ; //{
            ; //_A569F39CC_93:;					
            _A569F39CC_93:
            ; //	
            ; //_A569F39CC_94:;					
            _A569F39CC_94:
            ; //	sAX	= 0xFFFF;			
001D0:      	AX	= 0xFFFF
            ; //	asm I1 = _iADPCCACC469+0;		
001D2:      	I1 = _iADPCCACC469+0//
            ; //	*(__int16*)sSI	= sAX			
001D3:      	rm[I1]	= AX
            ; //_A569F39CC_95:;					
            _A569F39CC_95:
            ; //	asm AX = PCMY+0;			
001D4:      	AX = PCMY+0//
            ; //	inbuf+0 = sAX				
001D6:      	rm[inbuf+0]	= AX
            ; //_A569F39CC_96:;					
            _A569F39CC_96:
            ; //	asm AX = PCMY+0;			
001D7:      	AX = PCMY+0//
            ; //	outbuf+0 = sAX				
001D9:      	rm[outbuf+0]	= AX
            ; //_A569F39CC_97:;					
            _A569F39CC_97:
            ; //_A569F39CC_98:;					
            _A569F39CC_98:
            ; //	NEARCALL(L0E8FA404_16);			
001DA:      	call	L0E8FA404_16
            ; //_A569F39CC_99:;					
            _A569F39CC_99:
            ; //_A569F39CC_100:;				
            _A569F39CC_100:
            ; //	NEARCALL(L0E8FA404_19);			
001DB:      	call	L0E8FA404_19
            ; //L0E8FA404_22:;					
            L0E8FA404_22:
            ; //_A569F39CC_101:;				
            _A569F39CC_101:
            ; //	return;					
001DC:      	rets
            ; //_InitialDA4A7CC4_end:;				
            _InitialDA4A7CC4_end:
            ; //_A569F39CC_102:;				
            _A569F39CC_102:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\GLOBAL_6037E6D5.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\PLAYADP_65A00B9D.S.CODE.ASM> Start=========================
            ; playadp.c Code Start!!;
            VarRM[0:4095]={
             _iADPCCACC469,_adpch30670376[36],_adpFLTG0FBE3CB5[2] 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _playADPCMBACD5AFD(__int16 _index_0_4);
            ; //rjmp void ADPCM_CHX_Init();
            ; //rjmp void ADPCM_CHXGetBts();
            ; //rjmp void _DoADPCM9CD0E20D();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _playADPCMBACD5AFD(__int16 _index_0_4)
            _playADPCMBACD5AFD:
            ; //{
            ; //	__int16 _i_1_2;
            ; //	__int16 _p_1_4;
            ; //	__int16 _q_1_6;
            ; //						
001DD:      	AR	= rm[BP_SAVE]
001DE:      	push	AR
001DF:      	AR	= BP
001E0:      	rm[BP_SAVE]	= AR
001E1:      	AR	 = -3
001E2:      	BP	+= AR
            ; //_A569F39CC_103:;				
            _A569F39CC_103:
            ; //	
            ; //_A569F39CC_104:;				
            _A569F39CC_104:
            ; //	asm AX = _adpch30670376+0;		
001E3:      	AX = _adpch30670376+0//
            ; //	sSI	= (int)&_p_1_4;			
001E4:      	AR	= -1
001E5:      	I1	= rm[BP_SAVE]
001E6:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
001E7:      	rm[I1]	= AX
            ; //_A569F39CC_105:;				
            _A569F39CC_105:
            ; //	_i_1_2+0	= 0x00;			
001E8:      	I1	= rm[BP_SAVE]
001E9:      	AX	= 0x00
001EA:      	rm[I1]	= AX
            ; //L7F5A46A0_26:;					
            L7F5A46A0_26:
            ; //	sSI	= (int)&_i_1_2;			
001EB:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
001EC:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
001ED:      	CX	= 0x02
            ; //	sfx_CMP_AX_CX_JL();			
001EE:      	pch	= sfx_CMP_AX_CX_JL
001EF:      	lcall	sfx_CMP_AX_CX_JL
            ; //	if(__je__)	goto L7F5A46A0_30;	
001F0:      	if ZR	jmp L7F5A46A0_30
            ; //	goto	L7F5A46A0_28;			
001F1:      	jmp	L7F5A46A0_28
            ; //L7F5A46A0_30:;					
            L7F5A46A0_30:
            ; //	goto L7F5A46A0_27;			
001F2:      	jmp	L7F5A46A0_27
            ; //L7F5A46A0_29:;					
            L7F5A46A0_29:
            ; //	sSI	= (int)&_i_1_2;			
001F3:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
001F4:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
001F5:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
001F6:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
001F7:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
001F8:      	rm[I1] = CX + AR//
            ; //	goto L7F5A46A0_26;			
001F9:      	jmp	L7F5A46A0_26
            ; //L7F5A46A0_27:;					
            L7F5A46A0_27:
            ; //	
            ; //_A569F39CC_106:;				
            _A569F39CC_106:
            ; //	sSI	= (int)&_p_1_4;			
001FA:      	AR	= -1
001FB:      	I1	= rm[BP_SAVE]
001FC:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
001FD:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
001FE:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
001FF:      	AR	= CX
00200:      	AX	+= AR
            ; //	sSI	= sAX;				
00201:      	AR	= AX
00202:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI++;		
00203:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
00204:      	DX	= rm[I1--]
            ; //	sfx_CHECKZEROLONG();			
00205:      	AR	= AX
00206:      	AR	|= DX
            ; //	if(__jz__)	goto L7F5A46A0_32;	
00207:      	if ZR	jmp L7F5A46A0_32
            ; //	goto	L7F5A46A0_31;			
00208:      	jmp	L7F5A46A0_31
            ; //L7F5A46A0_32:;					
            L7F5A46A0_32:
            ; //	
            ; //_A569F39CC_107:;				
            _A569F39CC_107:
            ; //_A569F39CC_108:;				
            _A569F39CC_108:
            ; //	sAX	= 0x0012;			
00209:      	AX	= 0x12
            ; //	PUSH(sAX);				
0020A:      	push	AX
            ; //	sAX	= 0x0000;			
0020B:      	AX	= 0x00
            ; //	PUSH(sAX);				
0020C:      	push	AX
            ; //	sSI	= (int)&_p_1_4;			
0020D:      	AR	= -1
0020E:      	I1	= rm[BP_SAVE]
0020F:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00210:      	AX	= rm[I1]
            ; //	sDX	= 0;				
00211:      	DX	= 0x00
            ; //	PUSH(sDX);				
00212:      	push	DX
            ; //	PUSH(sAX);				
00213:      	push	AX
            ; //	_memset5A9D755A(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2], STACK[sSP + 3]);
00214:      	pch	= _memset5A9D755A
00215:      	lcall	_memset5A9D755A
            ; //	RESTORESP(4);				
00216:      	AR	= 4
00217:      	BP	+= AR
            ; //_A569F39CC_109:;				
            _A569F39CC_109:
            ; //	asm AX = #_adpdata32993E3B+0;		
00218:      	AX = #_adpdata32993E3B+0//
            ; //	PUSH(sAX);				
0021A:      	push	AX
            ; //	sSI	= (int)&_index_0_4;		
0021B:      	AR	= 2
0021C:      	I1	= rm[BP_SAVE]
0021D:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0021E:      	AX	= rm[I1]
            ; //	sCX	= 0x0004;			
0021F:      	CX	= 0x04
            ; //	sfx_IMUL_AX_CX();			
00220:      	pch	= sfx_IMUL_AX_CX
00221:      	lcall	sfx_IMUL_AX_CX
            ; //	sCX	= POP();			
00222:      	pop	CX
            ; //	sAX	= sAX + sCX;			
00223:      	AR	= CX
00224:      	AX	+= AR
            ; //	sSI	= (int)&_q_1_6;			
00225:      	AR	= -2
00226:      	I1	= rm[BP_SAVE]
00227:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00228:      	rm[I1]	= AX
            ; //_A569F39CC_110:;				
            _A569F39CC_110:
            ; //	sSI	= (int)&_p_1_4;			
00229:      	AR	= -1
0022A:      	I1	= rm[BP_SAVE]
0022B:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0022C:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
0022D:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
0022E:      	AR	= CX
0022F:      	AX	+= AR
            ; //	PUSH(sAX);				
00230:      	push	AX
            ; //	sSI	= (int)&_q_1_6;			
00231:      	AR	= -2
00232:      	I1	= rm[BP_SAVE]
00233:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00234:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
00235:      	AR	= AX
00236:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI++;		
00237:      	AX	= pm[P1++]
            ; //	sDX	= *(__int16*)sDI--;		
00238:      	DX	= pm[P1--]
            ; //	sSI	= POP();			
00239:      	pop	I1
            ; //	sfx_STORSILONG();			
0023A:      	rm[I1++]	= AX
0023B:      	rm[I1--]	= DX
            ; //_A569F39CC_111:;				
            _A569F39CC_111:
            ; //	sSI	= (int)&_p_1_4;			
0023C:      	AR	= -1
0023D:      	I1	= rm[BP_SAVE]
0023E:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0023F:      	AX	= rm[I1]
            ; //	sCX	= 0x0011;			
00240:      	CX	= 0x11
            ; //	sAX	= sAX + sCX;			
00241:      	AR	= CX
00242:      	AX	+= AR
            ; //	PUSH(sAX);				
00243:      	push	AX
            ; //	sSI	= (int)&_q_1_6;			
00244:      	AR	= -2
00245:      	I1	= rm[BP_SAVE]
00246:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00247:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
00248:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
00249:      	AR	= CX
0024A:      	AX	+= AR
            ; //	sDI	= sAX;				
0024B:      	AR	= AX
0024C:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
0024D:      	AX	= pm[P1]
            ; //	sSI	= POP();			
0024E:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
0024F:      	rm[I1]	= AX
            ; //_A569F39CC_112:;				
            _A569F39CC_112:
            ; //	asm AX = _adpFLTG0FBE3CB5+0;		
00250:      	AX = _adpFLTG0FBE3CB5+0//
            ; //	PUSH(sAX);				
00251:      	push	AX
            ; //	sSI	= (int)&_i_1_2;			
00252:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00253:      	AX	= rm[I1]
            ; //	
            ; //	sCX	= POP();			
00254:      	pop	CX
            ; //	sAX	= sAX + sCX;			
00255:      	AR	= CX
00256:      	AX	+= AR
            ; //	PUSH(sAX);				
00257:      	push	AX
            ; //	sSI	= (int)&_q_1_6;			
00258:      	AR	= -2
00259:      	I1	= rm[BP_SAVE]
0025A:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0025B:      	AX	= rm[I1]
            ; //	sCX	= 0x0003;			
0025C:      	CX	= 0x03
            ; //	sAX	= sAX + sCX;			
0025D:      	AR	= CX
0025E:      	AX	+= AR
            ; //	sDI	= sAX;				
0025F:      	AR	= AX
00260:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
00261:      	AX	= pm[P1]
            ; //	sSI	= POP();			
00262:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00263:      	rm[I1]	= AX
            ; //_A569F39CC_113:;				
            _A569F39CC_113:
            ; //	sAX	= 0x0001;			
00264:      	AX	= 0x01
            ; //	goto L7F5A46A0_25;			
00265:      	jmp	L7F5A46A0_25
            ; //L7F5A46A0_31:;					
            L7F5A46A0_31:
            ; //_A569F39CC_114:;				
            _A569F39CC_114:
            ; //_A569F39CC_115:;				
            _A569F39CC_115:
            ; //	sSI	= (int)&_p_1_4;			
00266:      	AR	= -1
00267:      	I1	= rm[BP_SAVE]
00268:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00269:      	AX	= rm[I1]
            ; //	sSI	= (int)&_p_1_4;			
0026A:      	AR	= -1
0026B:      	I1	= rm[BP_SAVE]
0026C:      	I1	+= AR
            ; //	asm AR = 0x0012;			
0026D:      	AR = 0x0012//
            ; //	sCX	= *(__int16*)sSI;		
0026E:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
0026F:      	rm[I1] = CX + AR//
            ; //_A569F39CC_116:;				
            _A569F39CC_116:
            ; //	goto L7F5A46A0_29;			
00270:      	jmp	L7F5A46A0_29
            ; //L7F5A46A0_28:;					
            L7F5A46A0_28:
            ; //_A569F39CC_117:;				
            _A569F39CC_117:
            ; //	sAX	= 0x0000;			
00271:      	AX	= 0x00
            ; //	goto L7F5A46A0_25;			
00272:      	jmp	L7F5A46A0_25
            ; //L7F5A46A0_25:;					
            L7F5A46A0_25:
            ; //_A569F39CC_118:;				
            _A569F39CC_118:
            ; //	return;					
00273:      	AR	= 3
00274:      	BP	+= AR
00275:      	pop	AR
00276:      	rm[BP_SAVE]	= AR
00277:      	rets
            ; //_playADPCMBACD5AFD_end:;			
            _playADPCMBACD5AFD_end:
            ; //_A569F39CC_119:;				
            _A569F39CC_119:
            ; //}
            ; //
            ; //rjmp void ADPCM_CHX_Init()			
            ADPCM_CHX_Init:
            ; //{
            ; //_A569F39CC_120:;				
            _A569F39CC_120:
            ; //	
            ; //_A569F39CC_121:;				
            _A569F39CC_121:
            ; //	sAX	= 0x0000;			
00278:      	AX	= 0x00
            ; //	asm I1 = _iADPCCACC469+0;		
00279:      	I1 = _iADPCCACC469+0//
            ; //	*(__int16*)sSI	= sAX			
0027A:      	rm[I1]	= AX
            ; //_A569F39CC_122:;				
            _A569F39CC_122:
            ; //_A569F39CC_123:;				
            _A569F39CC_123:
            ; //	sAX	= 0x0024;			
0027B:      	AX	= 0x24
            ; //	PUSH(sAX);				
0027C:      	push	AX
            ; //	sAX	= 0x0000;			
0027D:      	AX	= 0x00
            ; //	PUSH(sAX);				
0027E:      	push	AX
            ; //	asm AX = _adpch30670376+0;		
0027F:      	AX = _adpch30670376+0//
            ; //	sDX	= 0;				
00280:      	DX	= 0x00
            ; //	PUSH(sDX);				
00281:      	push	DX
            ; //	PUSH(sAX);				
00282:      	push	AX
            ; //	_memset5A9D755A(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2], STACK[sSP + 3]);
00283:      	pch	= _memset5A9D755A
00284:      	lcall	_memset5A9D755A
            ; //	RESTORESP(4);				
00285:      	AR	= 4
00286:      	BP	+= AR
            ; //L7F5A46A0_33:;					
            L7F5A46A0_33:
            ; //_A569F39CC_124:;				
            _A569F39CC_124:
            ; //	return;					
00287:      	rets
            ; //ADPCM_CHX_Init_end:;				
            ADPCM_CHX_Init_end:
            ; //_A569F39CC_125:;				
            _A569F39CC_125:
            ; //}
            ; //
            ; //rjmp void ADPCM_CHXGetBts()			
            ADPCM_CHXGetBts:
            ; //{
            ; //_A569F39CC_126:;				
            _A569F39CC_126:
            ; //_A569F39CC_127:;				
            _A569F39CC_127:
            ; //	asm	push AX				
00288:      	push AX
            ; //_A569F39CC_128:;				
            _A569F39CC_128:
            ; //	asm	push BX				
00289:      	push BX
            ; //_A569F39CC_129:;				
            _A569F39CC_129:
            ; //	asm	push CX				
0028A:      	push CX
            ; //_A569F39CC_130:;				
            _A569F39CC_130:
            ; //	asm	push DX				
0028B:      	push DX
            ; //_A569F39CC_131:;				
            _A569F39CC_131:
            ; //	asm	push I1				
0028C:      	push I1
            ; //_A569F39CC_132:;				
            _A569F39CC_132:
            ; //	asm	push P0				
0028D:      	push P0
            ; //_A569F39CC_133:;				
            _A569F39CC_133:
            ; //	asm	AR = P0.hh			
0028E:      	AR = P0.hh
            ; //_A569F39CC_134:;				
            _A569F39CC_134:
            ; //	asm	push AR				
0028F:      	push AR
            ; //	
            ; //_A569F39CC_135:;				
            _A569F39CC_135:
            ; //	asm I1 = ADPCM_Tmpi+0;			
00290:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
00291:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
00292:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
00293:      	AR	= CX
00294:      	AX	+= AR
            ; //	sSI	= sAX;				
00295:      	AR	= AX
00296:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI++;		
00297:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
00298:      	DX	= rm[I1--]
            ; //	PUSH(sAX);				
00299:      	push	AX
            ; //	PUSH(sDX);				
0029A:      	push	DX
            ; //	sCX	= 0x0001;			
0029B:      	CX	= 0x01
            ; //	sBX	= 0x0000;			
0029C:      	BX	= 0x00
            ; //	sfx_ADDLONG();				
0029D:      	AR	= CX
0029E:      	AX	= AX + AR
0029F:      	AR	= BX
002A0:      	DX	= DX + AR + C
            ; //	sfx_STORSILONG();			
002A1:      	rm[I1++]	= AX
002A2:      	rm[I1--]	= DX
            ; //	sDX	= POP();			
002A3:      	pop	DX
            ; //	sAX	= POP();			
002A4:      	pop	AX
            ; //_A569F39CC_136:;				
            _A569F39CC_136:
            ; //	asm	AR = AX				
002A5:      	AR = AX
            ; //_A569F39CC_137:;				
            _A569F39CC_137:
            ; //	asm	P0 = AR				
002A6:      	P0 = AR
            ; //_A569F39CC_138:;				
            _A569F39CC_138:
            ; //	asm	AR = DX				
002A7:      	AR = DX
            ; //_A569F39CC_139:;				
            _A569F39CC_139:
            ; //	asm	P0.hh = AR			
002A8:      	P0.hh = AR
            ; //	
            ; //_A569F39CC_140:;				
            _A569F39CC_140:
            ; //_A569F39CC_141:;				
            _A569F39CC_141:
            ; //	read_P0();				
002A9:      	AX	= pm[P0]
            ; //_A569F39CC_142:;				
            _A569F39CC_142:
            ; //	asm	pop AR				
002AA:      	pop AR
            ; //_A569F39CC_143:;				
            _A569F39CC_143:
            ; //	asm	P0.hh = AR			
002AB:      	P0.hh = AR
            ; //_A569F39CC_144:;				
            _A569F39CC_144:
            ; //	asm	pop P0				
002AC:      	pop P0
            ; //_A569F39CC_145:;				
            _A569F39CC_145:
            ; //	asm	pop I1				
002AD:      	pop I1
            ; //_A569F39CC_146:;				
            _A569F39CC_146:
            ; //	asm	pop DX				
002AE:      	pop DX
            ; //_A569F39CC_147:;				
            _A569F39CC_147:
            ; //	asm	pop CX				
002AF:      	pop CX
            ; //_A569F39CC_148:;				
            _A569F39CC_148:
            ; //	asm	pop BX				
002B0:      	pop BX
            ; //	
            ; //_A569F39CC_149:;				
            _A569F39CC_149:
            ; //_A569F39CC_150:;				
            _A569F39CC_150:
            ; //	asintax();				
            ; //_A569F39CC_151:;				
            _A569F39CC_151:
            ; //	asm	AR = AX				
002B1:      	AR = AX
            ; //_A569F39CC_152:;				
            _A569F39CC_152:
            ; //	asm	pop AX				
002B2:      	pop AX
            ; //L7F5A46A0_34:;					
            L7F5A46A0_34:
            ; //_A569F39CC_153:;				
            _A569F39CC_153:
            ; //	return;					
002B3:      	rets
            ; //ADPCM_CHXGetBts_end:;				
            ADPCM_CHXGetBts_end:
            ; //_A569F39CC_154:;				
            _A569F39CC_154:
            ; //}
            ; //
            ; //rjmp void L7F5A46A0_35()			
            L7F5A46A0_35:
            ; //{
            ; //	__int16 _i_1_2;
            ; //						
002B4:      	AR	= rm[BP_SAVE]
002B5:      	push	AR
002B6:      	AR	= BP
002B7:      	rm[BP_SAVE]	= AR
002B8:      	AR	 = -1
002B9:      	BP	+= AR
            ; //_A569F39CC_155:;				
            _A569F39CC_155:
            ; //	
            ; //_A569F39CC_156:;				
            _A569F39CC_156:
            ; //	asm I1 = inbuf+0;			
002BA:      	I1 = inbuf+0//
            ; //	sAX	= *(__int16*)sSI;		
002BB:      	AX	= rm[I1]
            ; //_A569F39CC_157:;				
            _A569F39CC_157:
            ; //	asm	AR = AX				
002BC:      	AR = AX
            ; //_A569F39CC_158:;				
            _A569F39CC_158:
            ; //	asm	I0 = AR				
002BD:      	I0 = AR
            ; //	
            ; //	
            ; //_A569F39CC_159:;				
            _A569F39CC_159:
            ; //	_i_1_2+0	= 0x40;			
002BE:      	I1	= rm[BP_SAVE]
002BF:      	AX	= 0x40
002C0:      	rm[I1]	= AX
            ; //L7F5A46A0_39:;					
            L7F5A46A0_39:
            ; //_A569F39CC_160:;				
            _A569F39CC_160:
            ; //	sSI	= (int)&_i_1_2;			
002C1:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
002C2:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
002C3:      	AR	= AX
            ; //	if(__jnz__)	goto L7F5A46A0_40;	
002C4:      	if NZ	jmp L7F5A46A0_40
            ; //	goto	L7F5A46A0_38;			
002C5:      	jmp	L7F5A46A0_38
            ; //L7F5A46A0_40:;					
            L7F5A46A0_40:
            ; //	
            ; //_A569F39CC_161:;				
            _A569F39CC_161:
            ; //	sAX	= 0x0000;			
002C6:      	AX	= 0x00
            ; //_A569F39CC_162:;				
            _A569F39CC_162:
            ; //	asm	rm[I0++] = AX			
002C7:      	rm[I0++] = AX
            ; //	
            ; //_A569F39CC_163:;				
            _A569F39CC_163:
            ; //	sSI	= (int)&_i_1_2;			
002C8:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
002C9:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
002CA:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
002CB:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
002CC:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
002CD:      	rm[I1] = CX - AR//
            ; //_A569F39CC_164:;				
            _A569F39CC_164:
            ; //	goto L7F5A46A0_39;			
002CE:      	jmp	L7F5A46A0_39
            ; //L7F5A46A0_38:;					
            L7F5A46A0_38:
            ; //L7F5A46A0_37:;					
            L7F5A46A0_37:
            ; //_A569F39CC_165:;				
            _A569F39CC_165:
            ; //	return;					
002CF:      	AR	= 1
002D0:      	BP	+= AR
002D1:      	pop	AR
002D2:      	rm[BP_SAVE]	= AR
002D3:      	rets
            ; //L7F5A46A0_35_end:;				
            L7F5A46A0_35_end:
            ; //_A569F39CC_166:;				
            _A569F39CC_166:
            ; //}
            ; //
            ; //rjmp void L7F5A46A0_41(__int16 _vol_0_4)	
            L7F5A46A0_41:
            ; //{
            ; //	__int16 _p_1_2;
            ; //	__int16 _i_1_4;
            ; //						
002D4:      	AR	= rm[BP_SAVE]
002D5:      	push	AR
002D6:      	AR	= BP
002D7:      	rm[BP_SAVE]	= AR
002D8:      	AR	 = -2
002D9:      	BP	+= AR
            ; //_A569F39CC_167:;				
            _A569F39CC_167:
            ; //	
            ; //_A569F39CC_168:;				
            _A569F39CC_168:
            ; //	asm I1 = ADPCM_Tmpi+0;			
002DA:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
002DB:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
002DC:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
002DD:      	AR	= CX
002DE:      	AX	+= AR
            ; //	sSI	= sAX;				
002DF:      	AR	= AX
002E0:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI++;		
002E1:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
002E2:      	DX	= rm[I1--]
            ; //	sfx_CHECKZEROLONG();			
002E3:      	AR	= AX
002E4:      	AR	|= DX
            ; //	if(__jnz__)	goto L7F5A46A0_45;	
002E5:      	if NZ	jmp L7F5A46A0_45
            ; //	goto	L7F5A46A0_44;			
002E6:      	jmp	L7F5A46A0_44
            ; //L7F5A46A0_45:;					
            L7F5A46A0_45:
            ; //	
            ; //_A569F39CC_169:;				
            _A569F39CC_169:
            ; //	asm I1 = ADPCM_Tmpi+0;			
002E7:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
002E8:      	AX	= rm[I1]
            ; //	sCX	= 0x000C;			
002E9:      	CX	= 0x0C
            ; //	sAX	= sAX + sCX;			
002EA:      	AR	= CX
002EB:      	AX	+= AR
            ; //_A569F39CC_170:;				
            _A569F39CC_170:
            ; //	asm	AR = AX				
002EC:      	AR = AX
            ; //_A569F39CC_171:;				
            _A569F39CC_171:
            ; //	asm	I0 = AR				
002ED:      	I0 = AR
            ; //	
            ; //	
            ; //_A569F39CC_172:;				
            _A569F39CC_172:
            ; //_A569F39CC_173:;				
            _A569F39CC_173:
            ; //	read_I0P();				
002EE:      	AX	= rm[I0++]
            ; //	io[0x36]	= sAX;			
002EF:      	AR	= AX
002F0:      	io[0x36]	= AR
            ; //_A569F39CC_174:;				
            _A569F39CC_174:
            ; //_A569F39CC_175:;				
            _A569F39CC_175:
            ; //	read_I0P();				
002F1:      	AX	= rm[I0++]
            ; //	io[0x36]	= sAX;			
002F2:      	AR	= AX
002F3:      	io[0x36]	= AR
            ; //_A569F39CC_176:;				
            _A569F39CC_176:
            ; //_A569F39CC_177:;				
            _A569F39CC_177:
            ; //	read_I0P();				
002F4:      	AX	= rm[I0++]
            ; //	io[0x36]	= sAX;			
002F5:      	AR	= AX
002F6:      	io[0x36]	= AR
            ; //_A569F39CC_178:;				
            _A569F39CC_178:
            ; //_A569F39CC_179:;				
            _A569F39CC_179:
            ; //	read_I0P();				
002F7:      	AX	= rm[I0++]
            ; //	io[0x36]	= sAX;			
002F8:      	AR	= AX
002F9:      	io[0x36]	= AR
            ; //_A569F39CC_180:;				
            _A569F39CC_180:
            ; //_A569F39CC_181:;				
            _A569F39CC_181:
            ; //	read_I0P();				
002FA:      	AX	= rm[I0++]
            ; //	io[0x3D]	= sAX;			
002FB:      	AR	= AX
002FC:      	io[0x3D]	= AR
            ; //_A569F39CC_182:;				
            _A569F39CC_182:
            ; //_A569F39CC_183:;				
            _A569F39CC_183:
            ; //	read_I0P();				
002FD:      	AX	= rm[I0++]
            ; //	io[0x3E]	= sAX;			
002FE:      	AR	= AX
002FF:      	io[0x3E]	= AR
            ; //_A569F39CC_184:;				
            _A569F39CC_184:
            ; //	sSI	= (int)&_vol_0_4;		
00300:      	AR	= 2
00301:      	I1	= rm[BP_SAVE]
00302:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00303:      	AX	= rm[I1]
            ; //	io[0x3C]	= sAX;			
00304:      	AR	= AX
00305:      	io[0x3C]	= AR
            ; //_A569F39CC_185:;				
            _A569F39CC_185:
            ; //	sAX	= io[0x3C];			
00306:      	AR	= io[0x3C]
00307:      	AX	= AR
            ; //_A569F39CC_186:;				
            _A569F39CC_186:
            ; //	asm I1 = inbuf+0;			
00308:      	I1 = inbuf+0//
            ; //	sAX	= *(__int16*)sSI;		
00309:      	AX	= rm[I1]
            ; //	sSI	= (int)&_p_1_2;			
0030A:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
0030B:      	rm[I1]	= AX
            ; //_A569F39CC_187:;				
            _A569F39CC_187:
            ; //	_i_1_4+0	= 0x20;			
0030C:      	AR	= -1
0030D:      	I1	= rm[BP_SAVE]
0030E:      	I1	+= AR
0030F:      	AX	= 0x20
00310:      	rm[I1]	= AX
            ; //L7F5A46A0_47:;					
            L7F5A46A0_47:
            ; //_A569F39CC_188:;				
            _A569F39CC_188:
            ; //	sSI	= (int)&_i_1_4;			
00311:      	AR	= -1
00312:      	I1	= rm[BP_SAVE]
00313:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00314:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_4;			
00315:      	AR	= -1
00316:      	I1	= rm[BP_SAVE]
00317:      	I1	+= AR
            ; //	asm AR = 0x0001;			
00318:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
00319:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
0031A:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
0031B:      	AR	= AX
            ; //	if(__jnz__)	goto L7F5A46A0_48;	
0031C:      	if NZ	jmp L7F5A46A0_48
            ; //	goto	L7F5A46A0_46;			
0031D:      	jmp	L7F5A46A0_46
            ; //L7F5A46A0_48:;					
            L7F5A46A0_48:
            ; //	
            ; //_A569F39CC_189:;				
            _A569F39CC_189:
            ; //	sAX	= 0;				
0031E:      	AX	= 0x00
            ; //	asm test io[0x00].b14;			
0031F:      	test io[0x00].b14//
            ; //	if(__jz__) goto L7F5A46A0_49;		
00320:      	if ZR	jmp L7F5A46A0_49
            ; //	sAX	= 1;				
00321:      	AX	= 0x01
            ; //L7F5A46A0_49:;					
            L7F5A46A0_49:
            ; //	sfx_CHECKZERO();			
00322:      	AR	= AX
            ; //	if(__jz__)	goto L7F5A46A0_51;	
00323:      	if ZR	jmp L7F5A46A0_51
            ; //	goto	L7F5A46A0_50;			
00324:      	jmp	L7F5A46A0_50
            ; //L7F5A46A0_51:;					
            L7F5A46A0_51:
            ; //	
            ; //_A569F39CC_190:;				
            _A569F39CC_190:
            ; //_A569F39CC_191:;				
            _A569F39CC_191:
            ; //	_SDSP_ADPCM_4Bit_SingleCH_decoder94C4563E();
00325:      	pch	= _SDSP_ADPCM_4Bit_SingleCH_decoder94C4563E
00326:      	lcall	_SDSP_ADPCM_4Bit_SingleCH_decoder94C4563E
            ; //	sfx_CHECKZERO();			
00327:      	AR	= AX
            ; //	if(__jz__)	goto L7F5A46A0_53;	
00328:      	if ZR	jmp L7F5A46A0_53
            ; //	goto	L7F5A46A0_52;			
00329:      	jmp	L7F5A46A0_52
            ; //L7F5A46A0_53:;					
            L7F5A46A0_53:
            ; //	
            ; //_A569F39CC_192:;				
            _A569F39CC_192:
            ; //	asm I1 = ADPCM_Tmpi+0;			
0032A:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
0032B:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
0032C:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
0032D:      	AR	= CX
0032E:      	AX	+= AR
            ; //	PUSH(sAX);				
0032F:      	push	AX
            ; //	sAX	= 0x0000;			
00330:      	AX	= 0x00
            ; //	sDX	= 0x0000;			
00331:      	DX	= 0x00
            ; //	sSI	= POP();			
00332:      	pop	I1
            ; //	sfx_STORSILONG();			
00333:      	rm[I1++]	= AX
00334:      	rm[I1--]	= DX
            ; //_A569F39CC_193:;				
            _A569F39CC_193:
            ; //	goto L7F5A46A0_43;			
00335:      	jmp	L7F5A46A0_43
            ; //L7F5A46A0_52:;					
            L7F5A46A0_52:
            ; //_A569F39CC_194:;				
            _A569F39CC_194:
            ; //_A569F39CC_195:;				
            _A569F39CC_195:
            ; //	asm I1 = ADPCM_Tmpi+0;			
00336:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
00337:      	AX	= rm[I1]
            ; //	sSI	= sAX;				
00338:      	AR	= AX
00339:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
0033A:      	AX	= rm[I1]
            ; //	io[0x36]	= sAX;			
0033B:      	AR	= AX
0033C:      	io[0x36]	= AR
            ; //L7F5A46A0_50:;					
            L7F5A46A0_50:
            ; //_A569F39CC_196:;				
            _A569F39CC_196:
            ; //_A569F39CC_197:;				
            _A569F39CC_197:
            ; //	sSI	= (int)&_p_1_2;			
0033D:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0033E:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
0033F:      	push	AX
            ; //	sSI	= (int)&_p_1_2;			
00340:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00341:      	AX	= rm[I1]
            ; //	sSI	= sAX;				
00342:      	AR	= AX
00343:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI++;		
00344:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
00345:      	DX	= rm[I1--]
            ; //	PUSH(sDX);				
00346:      	push	DX
            ; //	PUSH(sAX);				
00347:      	push	AX
            ; //	sAX	= io[0x3C];			
00348:      	AR	= io[0x3C]
00349:      	AX	= AR
            ; //	sfx_INT2LONG_AX();			
0034A:      	DX	= 0
0034B:      	test	AX.b15
0034C:      	if ZR jmp L16A17074_0
0034D:      	DX = -1
            L16A17074_0:
            ; //	sCX	= POP();			
0034E:      	pop	CX
            ; //	sBX	= POP();			
0034F:      	pop	BX
            ; //	sfx_ADDLONG();				
00350:      	AR	= CX
00351:      	AX	= AX + AR
00352:      	AR	= BX
00353:      	DX	= DX + AR + C
            ; //	sSI	= POP();			
00354:      	pop	I1
            ; //	sfx_STORSILONG();			
00355:      	rm[I1++]	= AX
00356:      	rm[I1--]	= DX
            ; //	sSI	= (int)&_p_1_2;			
00357:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0002;			
00358:      	AR = 0x0002//
            ; //	sAX	= *(__int16*)sSI;		
00359:      	AX	= rm[I1]
            ; //	asm rm[I1] = AX + AR;			
0035A:      	rm[I1] = AX + AR//
            ; //_A569F39CC_198:;				
            _A569F39CC_198:
            ; //	goto L7F5A46A0_47;			
0035B:      	jmp	L7F5A46A0_47
            ; //L7F5A46A0_46:;					
            L7F5A46A0_46:
            ; //	
            ; //_A569F39CC_199:;				
            _A569F39CC_199:
            ; //	asm I1 = ADPCM_Tmpi+0;			
0035C:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
0035D:      	AX	= rm[I1]
            ; //	sCX	= 0x000C;			
0035E:      	CX	= 0x0C
            ; //	sAX	= sAX + sCX;			
0035F:      	AR	= CX
00360:      	AX	+= AR
            ; //_A569F39CC_200:;				
            _A569F39CC_200:
            ; //	asm	AR = AX				
00361:      	AR = AX
            ; //_A569F39CC_201:;				
            _A569F39CC_201:
            ; //	asm	I0 = AR				
00362:      	I0 = AR
            ; //	
            ; //	
            ; //_A569F39CC_202:;				
            _A569F39CC_202:
            ; //	sAX	= io[0x36];			
00363:      	AR	= io[0x36]
00364:      	AX	= AR
            ; //_A569F39CC_203:;				
            _A569F39CC_203:
            ; //	asm	rm[I0++] = AX			
00365:      	rm[I0++] = AX
            ; //	
            ; //_A569F39CC_204:;				
            _A569F39CC_204:
            ; //	sAX	= io[0x36];			
00366:      	AR	= io[0x36]
00367:      	AX	= AR
            ; //_A569F39CC_205:;				
            _A569F39CC_205:
            ; //	asm	rm[I0++] = AX			
00368:      	rm[I0++] = AX
            ; //	
            ; //_A569F39CC_206:;				
            _A569F39CC_206:
            ; //	sAX	= io[0x36];			
00369:      	AR	= io[0x36]
0036A:      	AX	= AR
            ; //_A569F39CC_207:;				
            _A569F39CC_207:
            ; //	asm	rm[I0++] = AX			
0036B:      	rm[I0++] = AX
            ; //	
            ; //_A569F39CC_208:;				
            _A569F39CC_208:
            ; //	sAX	= io[0x36];			
0036C:      	AR	= io[0x36]
0036D:      	AX	= AR
            ; //_A569F39CC_209:;				
            _A569F39CC_209:
            ; //	asm	rm[I0++] = AX			
0036E:      	rm[I0++] = AX
            ; //	
            ; //_A569F39CC_210:;				
            _A569F39CC_210:
            ; //	sAX	= io[0x3D];			
0036F:      	AR	= io[0x3D]
00370:      	AX	= AR
            ; //_A569F39CC_211:;				
            _A569F39CC_211:
            ; //	asm	rm[I0++] = AX			
00371:      	rm[I0++] = AX
            ; //L7F5A46A0_44:;					
            L7F5A46A0_44:
            ; //_A569F39CC_212:;				
            _A569F39CC_212:
            ; //L7F5A46A0_43:;					
            L7F5A46A0_43:
            ; //_A569F39CC_213:;				
            _A569F39CC_213:
            ; //	return;					
00372:      	AR	= 2
00373:      	BP	+= AR
00374:      	pop	AR
00375:      	rm[BP_SAVE]	= AR
00376:      	rets
            ; //L7F5A46A0_41_end:;				
            L7F5A46A0_41_end:
            ; //_A569F39CC_214:;				
            _A569F39CC_214:
            ; //}
            ; //
            ; //rjmp void L7F5A46A0_54()			
            L7F5A46A0_54:
            ; //{
            ; //	__int16 _i_1_2;
            ; //						
00377:      	AR	= rm[BP_SAVE]
00378:      	push	AR
00379:      	AR	= BP
0037A:      	rm[BP_SAVE]	= AR
0037B:      	AR	 = -1
0037C:      	BP	+= AR
            ; //_A569F39CC_215:;				
            _A569F39CC_215:
            ; //	
            ; //_A569F39CC_216:;				
            _A569F39CC_216:
            ; //	asm I1 = inbuf+0;			
0037D:      	I1 = inbuf+0//
            ; //	sAX	= *(__int16*)sSI;		
0037E:      	AX	= rm[I1]
            ; //_A569F39CC_217:;				
            _A569F39CC_217:
            ; //	asm	AR = AX				
0037F:      	AR = AX
            ; //_A569F39CC_218:;				
            _A569F39CC_218:
            ; //	asm	I0 = AR				
00380:      	I0 = AR
            ; //	
            ; //	
            ; //_A569F39CC_219:;				
            _A569F39CC_219:
            ; //	sAX	= io[0x33];			
00381:      	AR	= io[0x33]
00382:      	AX	= AR
            ; //_A569F39CC_220:;				
            _A569F39CC_220:
            ; //	_i_1_2+0	= 0x20;			
00383:      	I1	= rm[BP_SAVE]
00384:      	AX	= 0x20
00385:      	rm[I1]	= AX
            ; //L7F5A46A0_58:;					
            L7F5A46A0_58:
            ; //_A569F39CC_221:;				
            _A569F39CC_221:
            ; //	sSI	= (int)&_i_1_2;			
00386:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00387:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
00388:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
00389:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
0038A:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
0038B:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
0038C:      	AR	= AX
            ; //	if(__jnz__)	goto L7F5A46A0_59;	
0038D:      	if NZ	jmp L7F5A46A0_59
            ; //	goto	L7F5A46A0_57;			
0038E:      	jmp	L7F5A46A0_57
            ; //L7F5A46A0_59:;					
            L7F5A46A0_59:
            ; //	
            ; //_A569F39CC_222:;				
            _A569F39CC_222:
            ; //_A569F39CC_223:;				
            _A569F39CC_223:
            ; //	read_I0P();				
0038F:      	AX	= rm[I0++]
            ; //	io[0x33]	= sAX;			
00390:      	AR	= AX
00391:      	io[0x33]	= AR
            ; //_A569F39CC_224:;				
            _A569F39CC_224:
            ; //_A569F39CC_225:;				
            _A569F39CC_225:
            ; //	read_I0M();				
00392:      	AX	= rm[I0--]
            ; //	io[0x33]	= sAX;			
00393:      	AR	= AX
00394:      	io[0x33]	= AR
            ; //	
            ; //_A569F39CC_226:;				
            _A569F39CC_226:
            ; //	sAX	= io[0x33];			
00395:      	AR	= io[0x33]
00396:      	AX	= AR
            ; //_A569F39CC_227:;				
            _A569F39CC_227:
            ; //	asm	rm[I0++2] = AX			
00397:      	rm[I0++2] = AX
            ; //_A569F39CC_228:;				
            _A569F39CC_228:
            ; //	goto L7F5A46A0_58;			
00398:      	jmp	L7F5A46A0_58
            ; //L7F5A46A0_57:;					
            L7F5A46A0_57:
            ; //_A569F39CC_229:;				
            _A569F39CC_229:
            ; //	asm I1 = inbuf+0;			
00399:      	I1 = inbuf+0//
            ; //	asm AR = rm[I1];			
0039A:      	AR = rm[I1]//
            ; //	asm not AR.b6;				
0039B:      	not AR.b6//
            ; //	asm rm[I1] = AR;			
0039C:      	rm[I1] = AR//
            ; //L7F5A46A0_56:;					
            L7F5A46A0_56:
            ; //_A569F39CC_230:;				
            _A569F39CC_230:
            ; //	return;					
0039D:      	AR	= 1
0039E:      	BP	+= AR
0039F:      	pop	AR
003A0:      	rm[BP_SAVE]	= AR
003A1:      	rets
            ; //L7F5A46A0_54_end:;				
            L7F5A46A0_54_end:
            ; //_A569F39CC_231:;				
            _A569F39CC_231:
            ; //}
            ; //
            ; //rjmp void _DoADPCM9CD0E20D()			
            _DoADPCM9CD0E20D:
            ; //{
            ; //	__int16 _i_1_2;
            ; //	__int16 _p_1_4;
            ; //						
003A2:      	AR	= rm[BP_SAVE]
003A3:      	push	AR
003A4:      	AR	= BP
003A5:      	rm[BP_SAVE]	= AR
003A6:      	AR	 = -2
003A7:      	BP	+= AR
            ; //_A569F39CC_232:;				
            _A569F39CC_232:
            ; //	
            ; //_A569F39CC_233:;				
            _A569F39CC_233:
            ; //	asm I1 = inbuf+0;			
003A8:      	I1 = inbuf+0//
            ; //	sAX	= *(__int16*)sSI;		
003A9:      	AX	= rm[I1]
            ; //	asm I1 = outbuf+0;			
003AA:      	I1 = outbuf+0//
            ; //	asm AR = rm[I1];			
003AB:      	AR = rm[I1]//
            ; //	asm AX = AX ^ AR;			
003AC:      	AX = AX ^ AR//
            ; //	asm AR = 0x0040;			
003AD:      	AR = 0x0040//
            ; //	asm AX = AX & AR;			
003AE:      	AX = AX & AR//
            ; //	sfx_CHECKZERO();			
003AF:      	AR	= AX
            ; //	if(__jz__)	goto L7F5A46A0_62;	
003B0:      	if ZR	jmp L7F5A46A0_62
            ; //	goto	L7F5A46A0_61;			
003B1:      	jmp	L7F5A46A0_61
            ; //L7F5A46A0_62:;					
            L7F5A46A0_62:
            ; //_A569F39CC_234:;				
            _A569F39CC_234:
            ; //	goto L7F5A46A0_60;			
003B2:      	jmp	L7F5A46A0_60
            ; //L7F5A46A0_61:;					
            L7F5A46A0_61:
            ; //_A569F39CC_235:;				
            _A569F39CC_235:
            ; //_A569F39CC_236:;				
            _A569F39CC_236:
            ; //	asm set io[0x09].b0;			
003B3:      	set io[0x09].b0//
            ; //_A569F39CC_237:;				
            _A569F39CC_237:
            ; //_A569F39CC_238:;				
            _A569F39CC_238:
            ; //	L7F5A46A0_35();				
003B4:      	pch	= L7F5A46A0_35
003B5:      	lcall	L7F5A46A0_35
            ; //_A569F39CC_239:;				
            _A569F39CC_239:
            ; //	asm AX = _adpFLTG0FBE3CB5+0;		
003B6:      	AX = _adpFLTG0FBE3CB5+0//
            ; //	sSI	= (int)&_p_1_4;			
003B7:      	AR	= -1
003B8:      	I1	= rm[BP_SAVE]
003B9:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
003BA:      	rm[I1]	= AX
            ; //_A569F39CC_240:;				
            _A569F39CC_240:
            ; //	asm AX = _adpch30670376+0;		
003BB:      	AX = _adpch30670376+0//
            ; //	asm I1 = ADPCM_Tmpi+0;			
003BC:      	I1 = ADPCM_Tmpi+0//
            ; //	*(__int16*)sSI	= sAX			
003BD:      	rm[I1]	= AX
            ; //_A569F39CC_241:;				
            _A569F39CC_241:
            ; //	_i_1_2+0	= 0x02;			
003BE:      	I1	= rm[BP_SAVE]
003BF:      	AX	= 0x02
003C0:      	rm[I1]	= AX
            ; //L7F5A46A0_64:;					
            L7F5A46A0_64:
            ; //_A569F39CC_242:;				
            _A569F39CC_242:
            ; //	sSI	= (int)&_i_1_2;			
003C1:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
003C2:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
003C3:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
003C4:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
003C5:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
003C6:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
003C7:      	AR	= AX
            ; //	if(__jnz__)	goto L7F5A46A0_65;	
003C8:      	if NZ	jmp L7F5A46A0_65
            ; //	goto	L7F5A46A0_63;			
003C9:      	jmp	L7F5A46A0_63
            ; //L7F5A46A0_65:;					
            L7F5A46A0_65:
            ; //	
            ; //_A569F39CC_243:;				
            _A569F39CC_243:
            ; //_A569F39CC_244:;				
            _A569F39CC_244:
            ; //	sSI	= (int)&_p_1_4;			
003CA:      	AR	= -1
003CB:      	I1	= rm[BP_SAVE]
003CC:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003CD:      	AX	= rm[I1]
            ; //	sSI	= (int)&_p_1_4;			
003CE:      	AR	= -1
003CF:      	I1	= rm[BP_SAVE]
003D0:      	I1	+= AR
            ; //	asm AR = 0x0001;			
003D1:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
003D2:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
003D3:      	rm[I1] = CX + AR//
            ; //	sSI	= sAX;				
003D4:      	AR	= AX
003D5:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
003D6:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
003D7:      	push	AX
            ; //	L7F5A46A0_41(STACK[sSP + 0]);		
003D8:      	pch	= L7F5A46A0_41
003D9:      	lcall	L7F5A46A0_41
            ; //	RESTORESP(1);				
003DA:      	pop	AR
            ; //_A569F39CC_245:;				
            _A569F39CC_245:
            ; //	asm I1 = ADPCM_Tmpi+0;			
003DB:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
003DC:      	AX	= rm[I1]
            ; //	sSI	= (int)&ADPCM_Tmpi;		
003DD:      	I1	= ADPCM_Tmpi
            ; //	sCX	= *(__int16*)sSI;		
003DE:      	CX	= rm[I1]
            ; //	asm AR = 0x0012;			
003DF:      	AR = 0x0012//
            ; //	asm rm[I1] = CX + AR;			
003E0:      	rm[I1] = CX + AR//
            ; //_A569F39CC_246:;				
            _A569F39CC_246:
            ; //	asm set io[0x09].b0;			
003E1:      	set io[0x09].b0//
            ; //_A569F39CC_247:;				
            _A569F39CC_247:
            ; //	goto L7F5A46A0_64;			
003E2:      	jmp	L7F5A46A0_64
            ; //L7F5A46A0_63:;					
            L7F5A46A0_63:
            ; //_A569F39CC_248:;				
            _A569F39CC_248:
            ; //_A569F39CC_249:;				
            _A569F39CC_249:
            ; //	L7F5A46A0_54();				
003E3:      	pch	= L7F5A46A0_54
003E4:      	lcall	L7F5A46A0_54
            ; //_A569F39CC_250:;				
            _A569F39CC_250:
            ; //	asm clr io[0x09].b0;			
003E5:      	clr io[0x09].b0//
            ; //_A569F39CC_251:;				
            _A569F39CC_251:
            ; //	asm clr io[0x09].b0;			
003E6:      	clr io[0x09].b0//
            ; //L7F5A46A0_60:;					
            L7F5A46A0_60:
            ; //_A569F39CC_252:;				
            _A569F39CC_252:
            ; //	return;					
003E7:      	AR	= 2
003E8:      	BP	+= AR
003E9:      	pop	AR
003EA:      	rm[BP_SAVE]	= AR
003EB:      	rets
            ; //_DoADPCM9CD0E20D_end:;				
            _DoADPCM9CD0E20D_end:
            ; //_A569F39CC_253:;				
            _A569F39CC_253:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\PLAYADP_65A00B9D.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\KEYPAD_0E0216C1.S.CODE.ASM> Start=========================
            ; keypad.c Code Start!!;
            VarRM[0:4095]={
             L5589D4CE_67,L5589D4CE_68,L5589D4CE_69 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _InitKey3C587B6D();
            ; //rjmp void _PollingKey3B90E3B1();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _InitKey3C587B6D()			
            _InitKey3C587B6D:
            ; //{
            ; //_A569F39CC_254:;				
            _A569F39CC_254:
            ; //	
            ; //_A569F39CC_255:;				
            _A569F39CC_255:
            ; //	asm clr io[0x04].b0;			
003EC:      	clr io[0x04].b0//
            ; //_A569F39CC_256:;				
            _A569F39CC_256:
            ; //	asm clr io[0x04].b1;			
003ED:      	clr io[0x04].b1//
            ; //_A569F39CC_257:;				
            _A569F39CC_257:
            ; //	asm clr io[0x04].b2;			
003EE:      	clr io[0x04].b2//
            ; //_A569F39CC_258:;				
            _A569F39CC_258:
            ; //	asm clr io[0x04].b3;			
003EF:      	clr io[0x04].b3//
            ; //_A569F39CC_259:;				
            _A569F39CC_259:
            ; //	asm clr io[0x05].b0;			
003F0:      	clr io[0x05].b0//
            ; //_A569F39CC_260:;				
            _A569F39CC_260:
            ; //	asm clr io[0x06].b0;			
003F1:      	clr io[0x06].b0//
            ; //_A569F39CC_261:;				
            _A569F39CC_261:
            ; //	asm set io[0x05].b2;			
003F2:      	set io[0x05].b2//
            ; //_A569F39CC_262:;				
            _A569F39CC_262:
            ; //	io[0x1E]	= 0x0005;		
003F3:      	AR	= 0x05
003F4:      	io[0x1E]	= AR
            ; //_A569F39CC_263:;				
            _A569F39CC_263:
            ; //	sAX	= 0x0007;			
003F5:      	AX	= 0x07
            ; //	sAX	= sAX | io[0x1F];		
003F6:      	AR	= io[0x1F]
003F7:      	AX	|= AR
            ; //	io[0x1F]	= sAX;			
003F8:      	AR	= AX
003F9:      	io[0x1F]	= AR
            ; //_A569F39CC_264:;				
            _A569F39CC_264:
            ; //	sAX	= 0x0000;			
003FA:      	AX	= 0x00
            ; //	sSI	= (int)&L5589D4CE_67;		
003FB:      	I1	= L5589D4CE_67
            ; //	*(__int16*)sSI	= sAX			
003FC:      	rm[I1]	= AX
            ; //_A569F39CC_265:;				
            _A569F39CC_265:
            ; //	sAX	= 0x0000;			
003FD:      	AX	= 0x00
            ; //	sSI	= (int)&L5589D4CE_68;		
003FE:      	I1	= L5589D4CE_68
            ; //	*(__int16*)sSI	= sAX			
003FF:      	rm[I1]	= AX
            ; //_A569F39CC_266:;				
            _A569F39CC_266:
            ; //	sAX	= 0x0200;			
00400:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_69;		
00402:      	I1	= L5589D4CE_69
            ; //	*(__int16*)sSI	= sAX			
00403:      	rm[I1]	= AX
            ; //L5589D4CE_70:;					
            L5589D4CE_70:
            ; //_A569F39CC_267:;				
            _A569F39CC_267:
            ; //	return;					
00404:      	rets
            ; //_InitKey3C587B6D_end:;				
            _InitKey3C587B6D_end:
            ; //_A569F39CC_268:;				
            _A569F39CC_268:
            ; //}
            ; //
            ; //rjmp void L5589D4CE_71()			
            L5589D4CE_71:
            ; //{
            ; //	__int16 _btn_1_2;
            ; //						
00405:      	AR	= rm[BP_SAVE]
00406:      	push	AR
00407:      	AR	= BP
00408:      	rm[BP_SAVE]	= AR
00409:      	AR	 = -1
0040A:      	BP	+= AR
            ; //_A569F39CC_269:;				
            _A569F39CC_269:
            ; //	
            ; //_A569F39CC_270:;				
            _A569F39CC_270:
            ; //	sAX	= 0x000F;			
0040B:      	AX	= 0x0F
            ; //	sAX	= sAX & io[0x07];		
0040C:      	AR	= io[0x07]
0040D:      	AX	&= AR
            ; //	sSI	= (int)&_btn_1_2;		
0040E:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
0040F:      	rm[I1]	= AX
            ; //_A569F39CC_271:;				
            _A569F39CC_271:
            ; //	sSI	= (int)&_btn_1_2;		
00410:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00411:      	AX	= rm[I1]
            ; //	goto L5589D4CE_73;			
00412:      	jmp	L5589D4CE_73
            ; //L5589D4CE_73:;					
            L5589D4CE_73:
            ; //_A569F39CC_272:;				
            _A569F39CC_272:
            ; //	return;					
00413:      	AR	= 1
00414:      	BP	+= AR
00415:      	pop	AR
00416:      	rm[BP_SAVE]	= AR
00417:      	rets
            ; //L5589D4CE_71_end:;				
            L5589D4CE_71_end:
            ; //_A569F39CC_273:;				
            _A569F39CC_273:
            ; //}
            ; //
            ; //rjmp void _PollingKey3B90E3B1()			
            _PollingKey3B90E3B1:
            ; //{
            ; //	__int16 _keynow_1_2;
            ; //	__int16 _i_1_4;
            ; //	__int16 _bits_1_6;
            ; //	__int16 _bitp_1_8;
            ; //	__int16 _pkey_1_10;
            ; //						
00418:      	AR	= rm[BP_SAVE]
00419:      	push	AR
0041A:      	AR	= BP
0041B:      	rm[BP_SAVE]	= AR
0041C:      	AR	 = -5
0041D:      	BP	+= AR
            ; //_A569F39CC_274:;				
            _A569F39CC_274:
            ; //	
            ; //_A569F39CC_275:;				
            _A569F39CC_275:
            ; //_A569F39CC_276:;				
            _A569F39CC_276:
            ; //	NEARCALL(L5589D4CE_71);			
0041E:      	call	L5589D4CE_71
            ; //	sSI	= (int)&_keynow_1_2;		
0041F:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
00420:      	rm[I1]	= AX
            ; //_A569F39CC_277:;				
            _A569F39CC_277:
            ; //	asm I1 = L5589D4CE_67+0;		
00421:      	I1 = L5589D4CE_67+0//
            ; //	sAX	= *(__int16*)sSI;		
00422:      	AX	= rm[I1]
            ; //	sSI	= (int)&_keynow_1_2;		
00423:      	I1	= rm[BP_SAVE]
            ; //	sCX	= *(__int16*)sSI;		
00424:      	CX	= rm[I1]
            ; //	sfx_CMP_AX_CX_JNE();			
00425:      	pch	= sfx_CMP_AX_CX_JNE
00426:      	lcall	sfx_CMP_AX_CX_JNE
            ; //	if(__je__)	goto L5589D4CE_76;	
00427:      	if ZR	jmp L5589D4CE_76
            ; //	goto	L5589D4CE_75;			
00428:      	jmp	L5589D4CE_75
            ; //L5589D4CE_76:;					
            L5589D4CE_76:
            ; //	
            ; //_A569F39CC_278:;				
            _A569F39CC_278:
            ; //	sSI	= (int)&_keynow_1_2;		
00429:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0042A:      	AX	= rm[I1]
            ; //	sSI	= (int)&L5589D4CE_67;		
0042B:      	I1	= L5589D4CE_67
            ; //	*(__int16*)sSI	= sAX			
0042C:      	rm[I1]	= AX
            ; //_A569F39CC_279:;				
            _A569F39CC_279:
            ; //	sAX	= 0x0200;			
0042D:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_69;		
0042F:      	I1	= L5589D4CE_69
            ; //	*(__int16*)sSI	= sAX			
00430:      	rm[I1]	= AX
            ; //_A569F39CC_280:;				
            _A569F39CC_280:
            ; //	goto L5589D4CE_74;			
00431:      	jmp	L5589D4CE_74
            ; //L5589D4CE_75:;					
            L5589D4CE_75:
            ; //_A569F39CC_281:;				
            _A569F39CC_281:
            ; //_A569F39CC_282:;				
            _A569F39CC_282:
            ; //	asm I1 = L5589D4CE_69+0;		
00432:      	I1 = L5589D4CE_69+0//
            ; //	sAX	= *(__int16*)sSI;		
00433:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
00434:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_78;	
00435:      	if NZ	jmp L5589D4CE_78
            ; //	goto	L5589D4CE_77;			
00436:      	jmp	L5589D4CE_77
            ; //L5589D4CE_78:;					
            L5589D4CE_78:
            ; //	
            ; //_A569F39CC_283:;				
            _A569F39CC_283:
            ; //	asm I1 = L5589D4CE_69+0;		
00437:      	I1 = L5589D4CE_69+0//
            ; //	sAX	= *(__int16*)sSI;		
00438:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
00439:      	CX	= 0x01
            ; //	sAX	= sAX - sCX;			
0043A:      	AR	= CX
0043B:      	AX	-= AR
            ; //	sSI	= (int)&L5589D4CE_69;		
0043C:      	I1	= L5589D4CE_69
            ; //	*(__int16*)sSI	= sAX			
0043D:      	rm[I1]	= AX
            ; //_A569F39CC_284:;				
            _A569F39CC_284:
            ; //	goto L5589D4CE_74;			
0043E:      	jmp	L5589D4CE_74
            ; //L5589D4CE_77:;					
            L5589D4CE_77:
            ; //_A569F39CC_285:;				
            _A569F39CC_285:
            ; //_A569F39CC_286:;				
            _A569F39CC_286:
            ; //	asm AX = #_keyfuncF06F3D55+0;		
0043F:      	AX = #_keyfuncF06F3D55+0//
            ; //	sSI	= (int)&_pkey_1_10;		
00441:      	AR	= -4
00442:      	I1	= rm[BP_SAVE]
00443:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00444:      	rm[I1]	= AX
            ; //_A569F39CC_287:;				
            _A569F39CC_287:
            ; //	sAX	= 0x0200;			
00445:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_69;		
00447:      	I1	= L5589D4CE_69
            ; //	*(__int16*)sSI	= sAX			
00448:      	rm[I1]	= AX
            ; //_A569F39CC_288:;				
            _A569F39CC_288:
            ; //	asm I1 = L5589D4CE_68+0;		
00449:      	I1 = L5589D4CE_68+0//
            ; //	sAX	= *(__int16*)sSI;		
0044A:      	AX	= rm[I1]
            ; //	asm I1 = L5589D4CE_67+0;		
0044B:      	I1 = L5589D4CE_67+0//
            ; //	asm AR = rm[I1];			
0044C:      	AR = rm[I1]//
            ; //	asm AX = AX ^ AR;			
0044D:      	AX = AX ^ AR//
            ; //	sSI	= (int)&_bits_1_6;		
0044E:      	AR	= -2
0044F:      	I1	= rm[BP_SAVE]
00450:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00451:      	rm[I1]	= AX
            ; //_A569F39CC_289:;				
            _A569F39CC_289:
            ; //	asm I1 = L5589D4CE_68+0;		
00452:      	I1 = L5589D4CE_68+0//
            ; //	sAX	= *(__int16*)sSI;		
00453:      	AX	= rm[I1]
            ; //	sSI	= (int)&_bitp_1_8;		
00454:      	AR	= -3
00455:      	I1	= rm[BP_SAVE]
00456:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00457:      	rm[I1]	= AX
            ; //_A569F39CC_290:;				
            _A569F39CC_290:
            ; //	asm I1 = L5589D4CE_67+0;		
00458:      	I1 = L5589D4CE_67+0//
            ; //	sAX	= *(__int16*)sSI;		
00459:      	AX	= rm[I1]
            ; //	sSI	= (int)&L5589D4CE_68;		
0045A:      	I1	= L5589D4CE_68
            ; //	*(__int16*)sSI	= sAX			
0045B:      	rm[I1]	= AX
            ; //_A569F39CC_291:;				
            _A569F39CC_291:
            ; //	_i_1_4+0	= 0x05;			
0045C:      	AR	= -1
0045D:      	I1	= rm[BP_SAVE]
0045E:      	I1	+= AR
0045F:      	AX	= 0x05
00460:      	rm[I1]	= AX
            ; //L5589D4CE_80:;					
            L5589D4CE_80:
            ; //_A569F39CC_292:;				
            _A569F39CC_292:
            ; //	sSI	= (int)&_i_1_4;			
00461:      	AR	= -1
00462:      	I1	= rm[BP_SAVE]
00463:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00464:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_4;			
00465:      	AR	= -1
00466:      	I1	= rm[BP_SAVE]
00467:      	I1	+= AR
            ; //	asm AR = 0x0001;			
00468:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
00469:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
0046A:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
0046B:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_81;	
0046C:      	if NZ	jmp L5589D4CE_81
            ; //	goto	L5589D4CE_79;			
0046D:      	jmp	L5589D4CE_79
            ; //L5589D4CE_81:;					
            L5589D4CE_81:
            ; //	
            ; //_A569F39CC_293:;				
            _A569F39CC_293:
            ; //	sAX	= 0;				
0046E:      	AX	= 0x00
            ; //	sSI	= (int)&_bits_1_6+0;		
0046F:      	AR	= -2
00470:      	I1	= rm[BP_SAVE]
00471:      	I1	+= AR
            ; //	asm AR = rm[I1];			
00472:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
00473:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_83;		
00474:      	if ZR	jmp L5589D4CE_83
            ; //	sAX	= 1;				
00475:      	AX	= 0x01
            ; //L5589D4CE_83:;					
            L5589D4CE_83:
            ; //	sfx_CHECKZERO();			
00476:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_84;	
00477:      	if NZ	jmp L5589D4CE_84
            ; //	goto	L5589D4CE_82;			
00478:      	jmp	L5589D4CE_82
            ; //L5589D4CE_84:;					
            L5589D4CE_84:
            ; //	
            ; //_A569F39CC_294:;				
            _A569F39CC_294:
            ; //	sAX	= 0;				
00479:      	AX	= 0x00
            ; //	sSI	= (int)&_bitp_1_8+0;		
0047A:      	AR	= -3
0047B:      	I1	= rm[BP_SAVE]
0047C:      	I1	+= AR
            ; //	asm AR = rm[I1];			
0047D:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
0047E:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_86;		
0047F:      	if ZR	jmp L5589D4CE_86
            ; //	sAX	= 1;				
00480:      	AX	= 0x01
            ; //L5589D4CE_86:;					
            L5589D4CE_86:
            ; //	sfx_CHECKZERO();			
00481:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_87;	
00482:      	if NZ	jmp L5589D4CE_87
            ; //	goto	L5589D4CE_85;			
00483:      	jmp	L5589D4CE_85
            ; //L5589D4CE_87:;					
            L5589D4CE_87:
            ; //	
            ; //_A569F39CC_295:;				
            _A569F39CC_295:
            ; //	sSI	= (int)&_pkey_1_10;		
00484:      	AR	= -4
00485:      	I1	= rm[BP_SAVE]
00486:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00487:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
00488:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
00489:      	AR	= CX
0048A:      	AX	+= AR
            ; //	sDI	= sAX;				
0048B:      	AR	= AX
0048C:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
0048D:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
0048E:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_89;	
0048F:      	if NZ	jmp L5589D4CE_89
            ; //	goto	L5589D4CE_88;			
00490:      	jmp	L5589D4CE_88
            ; //L5589D4CE_89:;					
            L5589D4CE_89:
            ; //_A569F39CC_296:;				
            _A569F39CC_296:
            ; //_A569F39CC_297:;				
            _A569F39CC_297:
            ; //	sSI	= (int)&_pkey_1_10;		
00491:      	AR	= -4
00492:      	I1	= rm[BP_SAVE]
00493:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00494:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
00495:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
00496:      	AR	= CX
00497:      	AX	+= AR
            ; //	sDI	= sAX;				
00498:      	AR	= AX
00499:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
0049A:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
0049B:      	AR	= AX
0049C:      	P1	= AR
0049D:      	P1.hh	= 0
0049E:      	fcall	pm[P1]
            ; //L5589D4CE_88:;					
            L5589D4CE_88:
            ; //_A569F39CC_298:;				
            _A569F39CC_298:
            ; //	goto L5589D4CE_90;			
0049F:      	jmp	L5589D4CE_90
            ; //L5589D4CE_85:;					
            L5589D4CE_85:
            ; //	
            ; //_A569F39CC_299:;				
            _A569F39CC_299:
            ; //	sSI	= (int)&_pkey_1_10;		
004A0:      	AR	= -4
004A1:      	I1	= rm[BP_SAVE]
004A2:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004A3:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
004A4:      	AR	= AX
004A5:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
004A6:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
004A7:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_92;	
004A8:      	if NZ	jmp L5589D4CE_92
            ; //	goto	L5589D4CE_91;			
004A9:      	jmp	L5589D4CE_91
            ; //L5589D4CE_92:;					
            L5589D4CE_92:
            ; //_A569F39CC_300:;				
            _A569F39CC_300:
            ; //_A569F39CC_301:;				
            _A569F39CC_301:
            ; //	sSI	= (int)&_pkey_1_10;		
004AA:      	AR	= -4
004AB:      	I1	= rm[BP_SAVE]
004AC:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004AD:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
004AE:      	AR	= AX
004AF:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
004B0:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
004B1:      	AR	= AX
004B2:      	P1	= AR
004B3:      	P1.hh	= 0
004B4:      	fcall	pm[P1]
            ; //L5589D4CE_91:;					
            L5589D4CE_91:
            ; //_A569F39CC_302:;				
            _A569F39CC_302:
            ; //L5589D4CE_90:;					
            L5589D4CE_90:
            ; //_A569F39CC_303:;				
            _A569F39CC_303:
            ; //	goto L5589D4CE_93;			
004B5:      	jmp	L5589D4CE_93
            ; //L5589D4CE_82:;					
            L5589D4CE_82:
            ; //	
            ; //_A569F39CC_304:;				
            _A569F39CC_304:
            ; //	sAX	= 0;				
004B6:      	AX	= 0x00
            ; //	sSI	= (int)&_bitp_1_8+0;		
004B7:      	AR	= -3
004B8:      	I1	= rm[BP_SAVE]
004B9:      	I1	+= AR
            ; //	asm AR = rm[I1];			
004BA:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
004BB:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_95;		
004BC:      	if ZR	jmp L5589D4CE_95
            ; //	sAX	= 1;				
004BD:      	AX	= 0x01
            ; //L5589D4CE_95:;					
            L5589D4CE_95:
            ; //	sfx_CHECKZERO();			
004BE:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_96;	
004BF:      	if NZ	jmp L5589D4CE_96
            ; //	goto	L5589D4CE_94;			
004C0:      	jmp	L5589D4CE_94
            ; //L5589D4CE_96:;					
            L5589D4CE_96:
            ; //	
            ; //_A569F39CC_305:;				
            _A569F39CC_305:
            ; //	sSI	= (int)&_pkey_1_10;		
004C1:      	AR	= -4
004C2:      	I1	= rm[BP_SAVE]
004C3:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004C4:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
004C5:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
004C6:      	AR	= CX
004C7:      	AX	+= AR
            ; //	sDI	= sAX;				
004C8:      	AR	= AX
004C9:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
004CA:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
004CB:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_98;	
004CC:      	if NZ	jmp L5589D4CE_98
            ; //	goto	L5589D4CE_97;			
004CD:      	jmp	L5589D4CE_97
            ; //L5589D4CE_98:;					
            L5589D4CE_98:
            ; //_A569F39CC_306:;				
            _A569F39CC_306:
            ; //_A569F39CC_307:;				
            _A569F39CC_307:
            ; //	sSI	= (int)&_pkey_1_10;		
004CE:      	AR	= -4
004CF:      	I1	= rm[BP_SAVE]
004D0:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004D1:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
004D2:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
004D3:      	AR	= CX
004D4:      	AX	+= AR
            ; //	sDI	= sAX;				
004D5:      	AR	= AX
004D6:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
004D7:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
004D8:      	AR	= AX
004D9:      	P1	= AR
004DA:      	P1.hh	= 0
004DB:      	fcall	pm[P1]
            ; //L5589D4CE_97:;					
            L5589D4CE_97:
            ; //_A569F39CC_308:;				
            _A569F39CC_308:
            ; //L5589D4CE_94:;					
            L5589D4CE_94:
            ; //_A569F39CC_309:;				
            _A569F39CC_309:
            ; //L5589D4CE_93:;					
            L5589D4CE_93:
            ; //_A569F39CC_310:;				
            _A569F39CC_310:
            ; //_A569F39CC_311:;				
            _A569F39CC_311:
            ; //	sSI	= (int)&_bits_1_6;		
004DC:      	AR	= -2
004DD:      	I1	= rm[BP_SAVE]
004DE:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004DF:      	AX	= rm[I1]
            ; //	asm sra AX, 1;				
004E0:      	sra AX, 1//
            ; //	sSI	= (int)&_bits_1_6;		
004E1:      	AR	= -2
004E2:      	I1	= rm[BP_SAVE]
004E3:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
004E4:      	rm[I1]	= AX
            ; //_A569F39CC_312:;				
            _A569F39CC_312:
            ; //	sSI	= (int)&_bitp_1_8;		
004E5:      	AR	= -3
004E6:      	I1	= rm[BP_SAVE]
004E7:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004E8:      	AX	= rm[I1]
            ; //	asm sra AX, 1;				
004E9:      	sra AX, 1//
            ; //	sSI	= (int)&_bitp_1_8;		
004EA:      	AR	= -3
004EB:      	I1	= rm[BP_SAVE]
004EC:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
004ED:      	rm[I1]	= AX
            ; //_A569F39CC_313:;				
            _A569F39CC_313:
            ; //	sSI	= (int)&_pkey_1_10;		
004EE:      	AR	= -4
004EF:      	I1	= rm[BP_SAVE]
004F0:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004F1:      	AX	= rm[I1]
            ; //	sSI	= (int)&_pkey_1_10;		
004F2:      	AR	= -4
004F3:      	I1	= rm[BP_SAVE]
004F4:      	I1	+= AR
            ; //	asm AR = 0x0003;			
004F5:      	AR = 0x0003//
            ; //	sCX	= *(__int16*)sSI;		
004F6:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
004F7:      	rm[I1] = CX + AR//
            ; //_A569F39CC_314:;				
            _A569F39CC_314:
            ; //	goto L5589D4CE_80;			
004F8:      	jmp	L5589D4CE_80
            ; //L5589D4CE_79:;					
            L5589D4CE_79:
            ; //L5589D4CE_74:;					
            L5589D4CE_74:
            ; //_A569F39CC_315:;				
            _A569F39CC_315:
            ; //	return;					
004F9:      	AR	= 5
004FA:      	BP	+= AR
004FB:      	pop	AR
004FC:      	rm[BP_SAVE]	= AR
004FD:      	rets
            ; //_PollingKey3B90E3B1_end:;			
            _PollingKey3B90E3B1_end:
            ; //_A569F39CC_316:;				
            _A569F39CC_316:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\KEYPAD_0E0216C1.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\LINKFILE_0F894B6D.S.CODE.ASM> Start=========================
            ; linkfile.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //naked void ADPCM_CH0_Data();
            ; //naked void ADPCM_CH1_Data();
            ; //naked void ADPCM_CH2_Data();
            ; //naked void ADPCM_CH3_Data();
            ; //naked void ADPCM_CH4_Data();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //__int16 _adpdata32993E3B[24] = {		
            _adpdata32993E3B:
            ; //	(int)&ADPCM_CH0_Data, (int)&ADPCM_CH0_Data.h|0x0800, 0x1FFF, 0x003F, (int)&ADPCM_CH1_Data, (int)&ADPCM_CH1_Data.h|0x0800, 0x3FFF, 0x003F, 
004FE:      DW #ADPCM_CH0_Data,#ADPCM_CH0_Data.h|0x0800,0x1FFF,0x003F,#ADPCM_CH1_Data,#ADPCM_CH1_Data.h|0x0800,0x3FFF,0x003F,
            ; //	(int)&ADPCM_CH2_Data, (int)&ADPCM_CH2_Data.h|0x0800, 0x3FFF, 0x003F, (int)&ADPCM_CH3_Data, (int)&ADPCM_CH3_Data.h|0x0800, 0x3FFF, 0x003F, 
00506:      DW #ADPCM_CH2_Data,#ADPCM_CH2_Data.h|0x0800,0x3FFF,0x003F,#ADPCM_CH3_Data,#ADPCM_CH3_Data.h|0x0800,0x3FFF,0x003F,
            ; //	(int)&ADPCM_CH4_Data, (int)&ADPCM_CH4_Data.h|0x0800, 0x3FFF, 0x003F, 0x0000, 0x0000, 0x0000, 0x0000
0050E:      DW #ADPCM_CH4_Data,#ADPCM_CH4_Data.h|0x0800,0x3FFF,0x003F,0x0000,0x0000,0x0000,0x0000,
            ; //};
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //naked void ADPCM_CH0_Data()			
            ADPCM_CH0_Data:
            ; //{
            ; //	asm	DW "adpcm\Media1_8000_4-12.xam"	
00DC3:      DW "adpcm\Media1_8000_4-12.xam"
            ; //}
            ; //
            ; //naked void ADPCM_CH1_Data()			
            ADPCM_CH1_Data:
            ; //{
            ; //	asm	DW "adpcm\Media1_16000_4-12.xam"
039D3:      DW "adpcm\Media1_16000_4-12.xam"
            ; //}
            ; //
            ; //naked void ADPCM_CH2_Data()			
            ADPCM_CH2_Data:
            ; //{
            ; //	asm	DW "adpcm\Media2_16000_4-12.xam"
0921E:      DW "adpcm\Media2_16000_4-12.xam"
            ; //}
            ; //
            ; //naked void ADPCM_CH3_Data()			
            ADPCM_CH3_Data:
            ; //{
            ; //	asm	DW "adpcm\Media3_16000_4-12.xam"
1331F:      DW "adpcm\Media3_16000_4-12.xam"
            ; //}
            ; //
            ; //naked void ADPCM_CH4_Data()			
            ADPCM_CH4_Data:
            ; //{
            ; //	asm	DW "adpcm\Media4_16000_4-12.xam"
155B7:      DW "adpcm\Media4_16000_4-12.xam"
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\LINKFILE_0F894B6D.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\TOUCH_AB036625.S.CODE.ASM> Start=========================
            ; touch.c Code Start!!;
            VarRM[0:4095]={
             L0DC315BC_102,L0DC315BC_103,_pE0B41DE7 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //void _touch_IRS1910CF89();
            ; //void _touch_init378E5983();
            ; //interrupt void _Touch_entry886E03ED();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //void _touch_IRS1910CF89()			
            _touch_IRS1910CF89:
            ; //{
            ; //_A569F39CC_317:;				
            _A569F39CC_317:
            ; //	
            ; //_A569F39CC_318:;				
            _A569F39CC_318:
            ; //	sAX	= 0;				
00516:      	AX	= 0x00
            ; //	asm test io[0x02].b5;			
00517:      	test io[0x02].b5//
            ; //	if(__jz__) goto L0DC315BC_105;		
00518:      	if ZR	jmp L0DC315BC_105
            ; //	sAX	= 1;				
00519:      	AX	= 0x01
            ; //L0DC315BC_105:;					
            L0DC315BC_105:
            ; //	sCX	= 0x0001;			
0051A:      	CX	= 0x01
            ; //	sfx_CMP_AX_CX_JE();			
0051B:      	AR	= AX
0051C:      	SF = AR - CX
            ; //	if(__je__)	goto L0DC315BC_107;	
0051D:      	if ZR	jmp L0DC315BC_107
            ; //	goto	L0DC315BC_106;			
0051E:      	pch =	L0DC315BC_106
0051F:      	ljmp	L0DC315BC_106
            ; //L0DC315BC_107:;					
            L0DC315BC_107:
            ; //_A569F39CC_319:;				
            _A569F39CC_319:
            ; //	asm	clr io[INTREQ].b5		
00520:      	clr io[INTREQ].b5
            ; //	
            ; //L0DC315BC_106:;					
            L0DC315BC_106:
            ; //_A569F39CC_320:;				
            _A569F39CC_320:
            ; //_A569F39CC_321:;				
            _A569F39CC_321:
            ; //	asm I1 = L0DC315BC_102+0;		
00521:      	I1 = L0DC315BC_102+0//
            ; //	sAX	= *(__int16*)sSI;		
00522:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
00523:      	CX	= 0x01
            ; //	sfx_CMP_AX_CX_JE();			
00524:      	AR	= AX
00525:      	SF = AR - CX
            ; //	if(__je__)	goto L0DC315BC_109;	
00526:      	if ZR	jmp L0DC315BC_109
            ; //	goto	L0DC315BC_108;			
00527:      	pch =	L0DC315BC_108
00528:      	ljmp	L0DC315BC_108
            ; //L0DC315BC_109:;					
            L0DC315BC_109:
            ; //	
            ; //_A569F39CC_322:;				
            _A569F39CC_322:
            ; //	io[0x08]	= 0x0004;		
00529:      	AR	= 0x04
0052A:      	io[0x08]	= AR
            ; //_A569F39CC_323:;				
            _A569F39CC_323:
            ; //	sAX	= 0x0000;			
0052B:      	AX	= 0x00
            ; //	sSI	= (int)&L0DC315BC_102;		
0052C:      	I1	= L0DC315BC_102
            ; //	*(__int16*)sSI	= sAX			
0052D:      	rm[I1]	= AX
            ; //	goto L0DC315BC_110;			
0052E:      	pch =	L0DC315BC_110
0052F:      	ljmp	L0DC315BC_110
            ; //L0DC315BC_108:;					
            L0DC315BC_108:
            ; //	
            ; //_A569F39CC_324:;				
            _A569F39CC_324:
            ; //	asm I1 = L0DC315BC_102+0;		
00530:      	I1 = L0DC315BC_102+0//
            ; //	sAX	= *(__int16*)sSI;		
00531:      	AX	= rm[I1]
            ; //	sSI	= (int)&L0DC315BC_102;		
00532:      	I1	= L0DC315BC_102
            ; //	PUSH(sAX);				
00533:      	push	AX
            ; //	sAX	= 0x0001;			
00534:      	AX	= 0x01
            ; //	sCX	= *(__int16*)sSI;		
00535:      	CX	= rm[I1]
            ; //	sCX	= sCX + sAX;			
00536:      	AR	= AX
00537:      	CX	+= AR
            ; //	*(__int16*)sSI	= sCX;			
00538:      	rm[I1]	= CX
            ; //	sAX	= POP();			
00539:      	pop	AX
            ; //_A569F39CC_325:;				
            _A569F39CC_325:
            ; //	io[0x08]	= 0x0000;		
0053A:      	AR	= 0x00
0053B:      	io[0x08]	= AR
            ; //L0DC315BC_110:;					
            L0DC315BC_110:
            ; //_A569F39CC_326:;				
            _A569F39CC_326:
            ; //L0DC315BC_104:;					
            L0DC315BC_104:
            ; //_A569F39CC_327:;				
            _A569F39CC_327:
            ; //	return;					
0053C:      	rets
            ; //_touch_IRS1910CF89_end:;			
            _touch_IRS1910CF89_end:
            ; //_A569F39CC_328:;				
            _A569F39CC_328:
            ; //}
            ; //
            ; //void _touch_init378E5983()			
            _touch_init378E5983:
            ; //{
            ; //_A569F39CC_329:;				
            _A569F39CC_329:
            ; //	
            ; //_A569F39CC_330:;				
            _A569F39CC_330:
            ; //	io[0x19]	= 0x007C;		
0053D:      	AR	= 0x7C
0053E:      	io[0x19]	= AR
            ; //_A569F39CC_331:;				
            _A569F39CC_331:
            ; //	asm clr io[0x19].b0;			
0053F:      	clr io[0x19].b0//
            ; //_A569F39CC_332:;				
            _A569F39CC_332:
            ; //	asm clr io[0x19].b1;			
00540:      	clr io[0x19].b1//
            ; //_A569F39CC_333:;				
            _A569F39CC_333:
            ; //	asm set io[0x19].b2;			
00541:      	set io[0x19].b2//
            ; //_A569F39CC_334:;				
            _A569F39CC_334:
            ; //	asm clr io[0x19].b3;			
00542:      	clr io[0x19].b3//
            ; //_A569F39CC_335:;				
            _A569F39CC_335:
            ; //	asm clr io[0x19].b4;			
00543:      	clr io[0x19].b4//
            ; //_A569F39CC_336:;				
            _A569F39CC_336:
            ; //	asm set io[0x19].b5;			
00544:      	set io[0x19].b5//
            ; //_A569F39CC_337:;				
            _A569F39CC_337:
            ; //	asm set io[0x19].b6;			
00545:      	set io[0x19].b6//
            ; //_A569F39CC_338:;				
            _A569F39CC_338:
            ; //	asm set io[0x19].b7;			
00546:      	set io[0x19].b7//
            ; //_A569F39CC_339:;				
            _A569F39CC_339:
            ; //	asm clr io[0x06].b0;			
00547:      	clr io[0x06].b0//
            ; //_A569F39CC_340:;				
            _A569F39CC_340:
            ; //	asm clr io[0x04].b3;			
00548:      	clr io[0x04].b3//
            ; //_A569F39CC_341:;				
            _A569F39CC_341:
            ; //	io[0x1E]	= 0x000F;		
00549:      	AR	= 0x0F
0054A:      	io[0x1E]	= AR
            ; //_A569F39CC_342:;				
            _A569F39CC_342:
            ; //	io[0x1F]	= 0x0001;		
0054B:      	AR	= 0x01
0054C:      	io[0x1F]	= AR
            ; //_A569F39CC_343:;				
            _A569F39CC_343:
            ; //	asm	set io[INTENA].b5		
0054D:      	set io[INTENA].b5
            ; //L0DC315BC_111:;					
            L0DC315BC_111:
            ; //_A569F39CC_344:;				
            _A569F39CC_344:
            ; //	return;					
0054E:      	rets
            ; //_touch_init378E5983_end:;			
            _touch_init378E5983_end:
            ; //_A569F39CC_345:;				
            _A569F39CC_345:
            ; //}
            ; //
            ; //interrupt void _Touch_entry886E03ED()		
            _Touch_entry886E03ED:
            ; //{						
0054F:      	push ax
00550:      	push bx
00551:      	push cx
00552:      	push dx
00553:      	push r0
00554:      	push r1
00555:      	push r2
00556:      	push r3
00557:      	push i1
00558:      	push p1
00559:      	push mx
0055A:      	push mr0
0055B:      	push mr1
0055C:      	push mr2
0055D:      	ar = p1.hh
0055E:      	push ar
            ; //_A569F39CC_346:;				
            _A569F39CC_346:
            ; //	
            ; //_A569F39CC_347:;				
            _A569F39CC_347:
            ; //	asm I1 = L0DC315BC_103+0;		
0055F:      	I1 = L0DC315BC_103+0//
            ; //	sAX	= *(__int16*)sSI;		
00560:      	AX	= rm[I1]
            ; //	sSI	= (int)&L0DC315BC_103;		
00561:      	I1	= L0DC315BC_103
            ; //	PUSH(sAX);				
00562:      	push	AX
            ; //	sAX	= 0x0001;			
00563:      	AX	= 0x01
            ; //	sCX	= *(__int16*)sSI;		
00564:      	CX	= rm[I1]
            ; //	sCX	= sCX + sAX;			
00565:      	AR	= AX
00566:      	CX	+= AR
            ; //	*(__int16*)sSI	= sCX;			
00567:      	rm[I1]	= CX
            ; //	sAX	= POP();			
00568:      	pop	AX
            ; //_A569F39CC_348:;				
            _A569F39CC_348:
            ; //	asm I1 = L0DC315BC_103+0;		
00569:      	I1 = L0DC315BC_103+0//
            ; //	sAX	= *(__int16*)sSI;		
0056A:      	AX	= rm[I1]
            ; //	sCX	= 0x0064;			
0056B:      	CX	= 0x64
            ; //	sfx_CMP_AX_CX_JG();			
0056C:      	pch	= sfx_CMP_AX_CX_JG
0056D:      	lcall	sfx_CMP_AX_CX_JG
            ; //	if(__je__)	goto L0DC315BC_114;	
0056E:      	if ZR	jmp L0DC315BC_114
            ; //	goto	L0DC315BC_113;			
0056F:      	pch =	L0DC315BC_113
00570:      	ljmp	L0DC315BC_113
            ; //L0DC315BC_114:;					
            L0DC315BC_114:
            ; //	
            ; //_A569F39CC_349:;				
            _A569F39CC_349:
            ; //_A569F39CC_350:;				
            _A569F39CC_350:
            ; //	_touch_IRS1910CF89();			
00571:      	pch	= _touch_IRS1910CF89
00572:      	lcall	_touch_IRS1910CF89
            ; //_A569F39CC_351:;				
            _A569F39CC_351:
            ; //	sAX	= 0x0000;			
00573:      	AX	= 0x00
            ; //	sSI	= (int)&L0DC315BC_103;		
00574:      	I1	= L0DC315BC_103
            ; //	*(__int16*)sSI	= sAX			
00575:      	rm[I1]	= AX
            ; //L0DC315BC_113:;					
            L0DC315BC_113:
            ; //_A569F39CC_352:;				
            _A569F39CC_352:
            ; //L0DC315BC_112:;					
            L0DC315BC_112:
            ; //_A569F39CC_353:;				
            _A569F39CC_353:
            ; //	return;					
00576:      	pop ar
00577:      	p1.hh = ar
00578:      	pop mr2
00579:      	pop mr1
0057A:      	pop mr0
0057B:      	pop mx
0057C:      	pop p1
0057D:      	pop i1
0057E:      	pop r3
0057F:      	pop r2
00580:      	pop r1
00581:      	pop r0
00582:      	pop dx
00583:      	pop cx
00584:      	pop bx
00585:      	pop ax
00586:      	reti
            ; //_Touch_entry886E03ED_end:;			
            _Touch_entry886E03ED_end:
            ; //_A569F39CC_354:;				
            _A569F39CC_354:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_touch_AB036625_s(void)	
            ginit_code_touch_AB036625_s:
            ; //{
            ; //	asm P1 = #ginit_seg_touch_AB036625_s+0;	
00587:      	P1 = #ginit_seg_touch_AB036625_s+0//
            ; //	asm I1 = L0DC315BC_102;			
0058A:      	I1 = L0DC315BC_102//
            ; //	sCX = 1;				
0058B:      	CX	= 0x01
            ; //	sfx_GLOBALINIT();			
0058C:      	pch	= sfx_GLOBALINIT
0058D:      	lcall	sfx_GLOBALINIT
            ; //
            ; //	asm P1 = #ginit_seg_touch_AB036625_s+1;	
0058E:      	P1 = #ginit_seg_touch_AB036625_s+1//
            ; //	asm I1 = L0DC315BC_103;			
00591:      	I1 = L0DC315BC_103//
            ; //	sCX = 1;				
00592:      	CX	= 0x01
            ; //	sfx_GLOBALINIT();			
00593:      	pch	= sfx_GLOBALINIT
00594:      	lcall	sfx_GLOBALINIT
            ; //
            ; //	return;					
00595:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //__int16 ginit_seg_touch_AB036625_s[2] = {	
            ginit_seg_touch_AB036625_s:
            ; //						
            DW 
            ; //	0x0000,					
00596:      DW 0x0000,
            ; //						
            DW 
            ; //	0x0000					
00597:      DW 0x0000,
            ; //};
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\TOUCH_AB036625.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\IO.ASM> Start=========================
            
            
            ; ~~ IO for DSP
            
            
            ; ~~ --------------------------
            ; void ClrWatchDog(void)
            ;~ ClrWatchDog:
            	;~ io[0x1D]=	AR
            	;~ rets
            
            
            ; ~~ --------------------------
            ; void dsi(void)
            ;~ dsi:
            	;~ clr		io[STATUS].b7
            	;~ nop
            	;~ rets
            
            
            ; ~~ --------------------------
            ; void eni(void)
            ;~ eni:
            	;~ set		io[STATUS].b7
            	;~ rets
            
            
            ; ~~ --------------------------
            ; int get_SATV(long value)
            get_SATV:
00598:      	AR=		BP
00599:      	AR=		AR + 1		; ~~ value
0059A:      	I1=		AR
0059B:      	AR=		SATV
0059C:      	AR=		rm[I1++]
0059D:      	SATV=		AR
0059E:      	AR=		rm[I1++]
0059F:      	SATV=		AR
005A0:      	AR=		SATV
005A1:      	AX=		AR
005A2:      	rets
            
            #ifdef _MSPEECHDSP_
            
            set_ADPHD:
            get_ADPHD:
            set_ADPDAT:
            get_ADPDAT:
            	AX=		0
            	rets
            
            #else
            
            
            ; ~~ --------------------------
            ; void set_ADPHD(int value)
            set_ADPHD:
005A3:      	AR=		BP
005A4:      	AR=		AR + 1		; ~~ value
005A5:      	I1=		AR
005A6:      	ADPHD=		rm[I1]
005A7:      	rets
            
            
            ; ~~ --------------------------
            ; int get_ADPHD(void)
            get_ADPHD:
005A8:      	AR=		ADPHD
005A9:      	AX=		AR
005AA:      	rets
            
            
            ; ~~ --------------------------
            ; void set_ADPDAT(int value)
            set_ADPDAT:
005AB:      	AR=		BP
005AC:      	AR=		AR + 1		; ~~ value
005AD:      	I1=		AR
005AE:      	ADPDAT=		rm[I1]
005AF:      	rets
            
            
            ; ~~ --------------------------
            ; int get_ADPDAT(void)
            get_ADPDAT:
005B0:      	AR=		ADPDAT
005B1:      	AX=		AR
005B2:      	rets
            
            #endif
            
            
            
            ; ~~ --------------------------
            ; int get_ADPPCM(void)
            get_FLTI:
            get_ADPPCM:
005B3:      	AR=		ADPPCM
005B4:      	AX=		AR
005B5:      	rets
            
            
            ; ~~ --------------------------
            ; int get_CBL(void)
            get_CBL:
005B6:      	AR=		CBL
005B7:      	AX=		AR
005B8:      	rets
            
            
            ; ~~ --------------------------
            ; int get_FLTO(void)
            get_FLTO:
005B9:      	AR=		FLTO
005BA:      	AX=		AR
005BB:      	rets
            
            
            ; ~~ --------------------------
            ; int get_FLTA(void)
            get_FLTA:
005BC:      	AR=		FLTA
005BD:      	AX=		AR
005BE:      	rets
            
            
            ; ~~ --------------------------
            ; int get_FLTP(void)
            get_FLTP:
005BF:      	AR=		FLTP
005C0:      	AX=		AR
005C1:      	rets
            
            ; ///////////////////////////////////////////////////////////////////////////
            ; ///////////////////////////////////////////////////////////////////////////
            
            ; ~~ --------------------------
            ; void set_UART(void)
            set_UART:
005C2:      	set		io[STATUS].b5
005C3:      	rets
            
            ; ~~ --------------------------
            ; void clr_UART(void)
            clr_UART:
005C4:      	clr		io[STATUS].b5
005C5:      	rets
            
            ; ~~ --------------------------
            ; void set_SPIM(void)
            set_SPIM:
005C6:      	set		io[STATUS].b8
005C7:      	rets
            
            ; ~~ --------------------------
            ; void clr_SPIM(void)
            clr_SPIM:
005C8:      	clr		io[STATUS].b8
005C9:      	rets
            
            ; ~~ --------------------------
            ; void set_SPIS(void)
            set_SPIS:
005CA:      	set		io[STATUS].b9
005CB:      	rets
            
            ; ~~ --------------------------
            ; void clr_SPIS(void)
            clr_SPIS:
005CC:      	clr		io[STATUS].b9
005CD:      	rets
            
            ; ~~ --------------------------
            ; void set_IntPrWR(void)
            set_IntPrWR:
005CE:      	set		io[STATUS].b11
005CF:      	rets
            
            ; ~~ --------------------------
            ; void clr_IntPrWR(void)
            clr_IntPrWR:
005D0:      	clr		io[STATUS].b11
005D1:      	rets
            
            ; ~~ --------------------------
            ; void set_IntPrWR(void)
            set_SD:
005D2:      	set		io[STATUS].b12
005D3:      	rets
            
            ; ~~ --------------------------
            ; void clr_IntPrWR(void)
            clr_SD:
005D4:      	clr		io[STATUS].b12
005D5:      	rets
            
            ; ~~ --------------------------
            ; void set_IntVWR(void)
            set_IntVWR:
005D6:      	set		io[STATUS].b13
005D7:      	rets
            
            ; ~~ --------------------------
            ; void clr_IntVWR(void)
            clr_IntVWR:
005D8:      	clr		io[STATUS].b13
005D9:      	rets
            
            ; ~~ --------------------------
            ; void set_INTENA(int value)
            set_INTENA:
005DA:      	AR=		BP
005DB:      	AR=		AR + 1		; ~~ value
005DC:      	I1=		AR
005DD:      	AR=		rm[I1]
005DE:      	io[INTENA]=	AR
005DF:      	rets
            
            ; ~~ --------------------------
            ; int get_INTENA(int value)
            get_INTENA:
005E0:      	AR=		io[INTENA]
005E1:      	AX=		AR
005E2:      	rets
            
            ; ~~ --------------------------
            ; void set_INTREQ(int value)
            set_INTREQ:
005E3:      	AR=		BP
005E4:      	AR=		AR + 1		; ~~ value
005E5:      	I1=		AR
005E6:      	AR=		rm[I1]
005E7:      	io[INTREQ]	=AR
005E8:      	rets
            
            ; ~~ --------------------------
            ; int get_INTREQ(int value)
            get_INTREQ:
005E9:      	AR=		io[INTREQ]
005EA:      	AX=		AR
005EB:      	rets
            
            ; ~~ --------------------------
            ; void set_IntVect(int value)
            set_IntVect:
005EC:      	AR=		BP
005ED:      	AR=		AR + 1		; ~~ value
005EE:      	I1=		AR
005EF:      	AR=		rm[I1]
005F0:      	io[IntVect]	=AR
005F1:      	rets
            
            ; ~~ --------------------------
            ; int get_IntVect(int value)
            get_IntVect:
005F2:      	AR=		io[IntVect]
005F3:      	AX=		AR
005F4:      	rets
            
            
            ; ~~ --------------------------
            ; int get_IOC_PA(int value)
            get_IOC_PA:
005F5:      	AR=		io[IOC_PA]
005F6:      	AX=		AR
005F7:      	rets
            
            
            ; ~~ --------------------------
            ; int get_IOC_PB(int value)
            get_IOC_PB:
005F8:      	AR=		io[IOC_PB]
005F9:      	AX=		AR
005FA:      	rets
            
            
            ; ~~ --------------------------
            ; int get_IOC_PC(int value)
            get_IOC_PC:
005FB:      	AR=		io[IOC_PC]
005FC:      	AX=		AR
005FD:      	rets
            
            ; ~~ --------------------------
            ; int get_PortA(int value)
            get_PortA:
005FE:      	AR=		io[PortA]
005FF:      	AX=		AR
00600:      	rets
            
            ; ~~ --------------------------
            ; int get_PortB(int value)
            get_PortB:
00601:      	AR=		io[PortB]
00602:      	AX=		AR
00603:      	rets
            
            
            ; ~~ --------------------------
            ; int get_PortC(int value)
            get_PortC:
00604:      	AR=		io[PortC]
00605:      	AX=		AR
00606:      	rets
            
            ; ~~ --------------------------
            ; void set_SPI_CTL(int value)
            set_SPI_CTL:
00607:      	AR=		BP
00608:      	AR=		AR + 1		; ~~ value
00609:      	I1=		AR
0060A:      	AR=		rm[I1]
0060B:      	io[SPI_CTL]=	AR
0060C:      	rets
            
            ; ~~ --------------------------
            ; int get_SPI_CTL(int value)
            get_SPI_CTL:
0060D:      	AR=		io[SPI_CTL]
0060E:      	AX=		AR
0060F:      	rets
            
            ; ~~ --------------------------
            ; void set_SPI_DAT(int value)
            set_SPI_DAT:
00610:      	AR=		BP
00611:      	AR=		AR + 1		; ~~ value
00612:      	I1=		AR
00613:      	AR=		rm[I1]
00614:      	io[SPI_DAT]=	AR
00615:      	rets
            
            ; ~~ --------------------------
            ; int get_SPI_DAT(int value)
            get_SPI_DAT:
00616:      	AR=		io[SPI_DAT]
00617:      	AX=		AR
00618:      	rets
            
            
            ; ~~ --------------------------
            ; void set_MISC(int value)
            set_MISC:
00619:      	AR=		BP
0061A:      	AR=		AR + 1		; ~~ value
0061B:      	I1=		AR
0061C:      	AR=		rm[I1]
            	;~ io[0x1C]	=AR
0061D:      	rets
            
            ; ~~ --------------------------
            ; int get_MISC(int value)
            get_MISC:
0061E:      	AR=		io[MISC]
0061F:      	AX=		AR
00620:      	rets
            
            ; ~~ --------------------------
            ; int get_Real_T(int value)
            get_Real_T:
            	;~ AR=		io[0x1D]
00621:      	AX=		AR
00622:      	rets
            
            
            ; ~~ --------------------------
            ; int get_MACOP(void)
            get_MACOP:
00623:      	AR=		MACOP
00624:      	AX=		AR
00625:      	rets
            
            
            ; ~~ --------------------------
            ; void set_INTMASK(int value)
            ; set_INTMASK:
            	; AR=			BP
            	; AR=			AR + 1		; ~~ value
            	; I1=			AR
            	; AR=			rm[I1]
            	; io[INTMASK]=AR
            	; rets
            
            ; ~~ --------------------------
            ; int get_INTMASK(int value)
            ; get_INTMASK:
            	; AR=			io[INTMASK]
            	; AX=			AR
            	; rets
            
            ; ~~ --------------------------
            ; int vXCHG(int value)
            vXCHG:
00626:      	AR=		BP
00627:      	AR=		AR + 1
00628:      	I1=		AR
00629:      	AR=		rm[I1]
0062A:      	xchg		AR
0062B:      	AX=		AR
0062C:      	rets
            
            ; ~~ --------------------------
            ; void cpuHalt(void)
            cpuHalt:
0062D:      	halt
            
            
            #ifdef _MFDSP_
            
            ; ~~ --------------------------
            ; void setSystemSpeed(int value)
            set_SystemSpeed:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SPEED]=	AR
            	rets
            
            
            ; ~~ --------------------------
            ; void set_SD_CTL(int value)
            set_SD_CTL:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SD_CTL]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SD_CTL(int value)
            get_SD_CTL:
            	AR=		io[SD_CTL]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SD_DAT(int value)
            set_SD_DAT:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SD_DAT]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SD_DAT(void)
            get_SD_DAT:
            	AR=		io[SD_DAT]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SD_RSP(int value)
            set_SD_RSP:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SD_RSP]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SD_RSP(int value)
            get_SD_RSP:
            	AR=		io[SD_RSP]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_UART_CTL(int value)
            set_UART_CTL:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[UART_CTL]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_UART_CTL(int value)
            get_UART_CTL:
            	AR=		io[UART_CTL]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_UART_DAT(int value)
            set_UART_DAT:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[UART_DAT]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_UART_DAT(int value)
            get_UART_DAT:
            	AR=		io[UART_DAT]
            	AX=		AR
            	rets
            
            
            ; By Tsao	20161103
            
            ; ~~ --------------------------
            ; void set_ADH_CFG0(int value)
            set_ADH_CFG0:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[ADH_CFG0]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_ADH_CFG0(void)
            get_ADH_CFG0:
            	AR=		io[ADH_CFG0]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_ADH_CFG1(int value)
            set_ADH_CFG1:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[ADH_CFG1]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_ADH_CFG1(void)
            get_ADH_CFG1:
            	AR=		io[ADH_CFG1]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; int get_ADH_DO(void)
            get_ADH_DO:
            	AR=		io[ADH_DO]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SPIS_CTL(int value)
            set_SPIS_CTL:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SPIS_CTL]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SPIS_CTL(int value)
            get_SPIS_CTL:
            	AR=		io[SPIS_CTL]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SPIS_DAT(int value)
            set_SPIS_DAT:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SPIS_DAT]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SPIS_DAT(int value)
            get_SPIS_DAT:
            	AR=		io[SPIS_DAT]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_GreenMode(int value)
            set_GreenMode:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[GREEN]=	AR
            	rets
            
            ; ~~ --------------------------
            ; void cpuStall(int value)
            cpuStall:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SLEEP]=	AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; set_SPI_DMA_CTL:
            	; AR=		BP
            	; AR=		AR + 1		// ~~ value
            	; I1=		AR
            	; AR=		rm[I1]
            	; io[SPI_DMA_CTL]=	AR
            	; rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            get_SPI_DMA_CTL:
            	AR=		io[SPI_DMA_CTL]
            	AX=		AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; set_SPI_DMA_RADR:
            	; AR=		BP
            	; AR=		AR + 1		// ~~ value
            	; I1=		AR
            	; AR=		rm[I1]
            	; io[SPI_DMA_RADR]=	AR
            	; rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            get_SPI_DMA_RADR:
            	AR=		io[SPI_DMA_RADR]
            	AX=		AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; set_SPI_DMA_DMANUM:
            	; AR=		BP
            	; AR=		AR + 1		// ~~ value
            	; I1=		AR
            	; AR=		rm[I1]
            	; io[0x55]=	AR
            	; rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            get_SPI_DMA_DMANUM:
            	AR=		io[SPI_DMA_DMANUM]
            	AX=		AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            
            #endif
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            read_I0:
0062E:      	AX=		rm[I0]
0062F:      	rets
            
            read_I0P:
00630:      	AX=		rm[I0++]
00631:      	rets
            
            read_I0P2:
00632:      	AX=		rm[I0++2]
00633:      	rets
            
            read_I0M:
00634:      	AX=		rm[I0--]
00635:      	rets
            
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            get_I0:
00636:      	AR=		I0
00637:      	AX=		AR
00638:      	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            read_P0:
00639:      	AX=		pm[P0]
0063A:      	rets
            
            read_P0P:
0063B:      	AX=		pm[P0++]
0063C:      	rets
            
            read_P0M:
0063D:      	AX=		pm[P0--]
0063E:      	rets
            
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            get_P0:
0063F:      	AR=		P0
00640:      	AX=		AR
00641:      	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            
            FA:
00642:      	AX=		1
00643:      	if FA jmp	@fa_label_1504
00644:      	AX=		0
            @fa_label_1504:
00645:      	rets
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\IO.ASM> End=========================
            
            ;=========================Include <DEPS\MEMSET_CDCF17ED.S.CODE.ASM> Start=========================
            ; C:\TRITAN\FDSP-IDE\tools\CC\lib\libc\memset.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rcall rjmp void _memset_sC3E11DB1(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8);
            ; //rcall rjmp void _memset_rC7200006(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8);
            ; //rcall rjmp void _memset5A9D755A(__int16 _s_0_4_0, __int16 _s_0_4_1, __int16 _c_0_8, __int16 _n_0_10);
            ; //
            ; //
            ; //
            ; //
            .code
            ; //rcall rjmp void _memset_sC3E11DB1(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8)
            _memset_sC3E11DB1:
            ; //{
            ; //	__int16 _ret_1_2;
            ; //						
00646:      	AR	= rm[BP_SAVE]
00647:      	push	AR
00648:      	AR	= BP
00649:      	rm[BP_SAVE]	= AR
0064A:      	AR	 = -1
0064B:      	BP	+= AR
            ; //_A569F39CC_355:;				
            _A569F39CC_355:
            ; //	
            ; //_A569F39CC_356:;				
            _A569F39CC_356:
            ; //	sSI	= (int)&_s_0_4;			
0064C:      	AR	= 2
0064D:      	I1	= rm[BP_SAVE]
0064E:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0064F:      	AX	= rm[I1]
            ; //	sSI	= (int)&_ret_1_2;		
00650:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
00651:      	rm[I1]	= AX
            ; //LF2D2B0F3_117:;					
            LF2D2B0F3_117:
            ; //_A569F39CC_357:;				
            _A569F39CC_357:
            ; //	sSI	= (int)&_n_0_8;			
00652:      	AR	= 4
00653:      	I1	= rm[BP_SAVE]
00654:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00655:      	AX	= rm[I1]
            ; //	sSI	= (int)&_n_0_8;			
00656:      	AR	= 4
00657:      	I1	= rm[BP_SAVE]
00658:      	I1	+= AR
            ; //	asm AR = 0x0001;			
00659:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
0065A:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
0065B:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
0065C:      	AR	= AX
            ; //	if(__jnz__)	goto LF2D2B0F3_118;	
0065D:      	if NZ	jmp LF2D2B0F3_118
            ; //	goto	LF2D2B0F3_116;			
0065E:      	jmp	LF2D2B0F3_116
            ; //LF2D2B0F3_118:;					
            LF2D2B0F3_118:
            ; //_A569F39CC_358:;				
            _A569F39CC_358:
            ; //	sSI	= (int)&_ret_1_2;		
0065F:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00660:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
00661:      	push	AX
            ; //	sSI	= (int)&_c_0_6;			
00662:      	AR	= 3
00663:      	I1	= rm[BP_SAVE]
00664:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00665:      	AX	= rm[I1]
            ; //	sSI	= POP();			
00666:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00667:      	rm[I1]	= AX
            ; //	sSI	= (int)&_ret_1_2;		
00668:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
00669:      	AR = 0x0001//
            ; //	sAX	= *(__int16*)sSI;		
0066A:      	AX	= rm[I1]
            ; //	asm rm[I1] = AX + AR;			
0066B:      	rm[I1] = AX + AR//
            ; //_A569F39CC_359:;				
            _A569F39CC_359:
            ; //	goto LF2D2B0F3_117;			
0066C:      	jmp	LF2D2B0F3_117
            ; //LF2D2B0F3_116:;					
            LF2D2B0F3_116:
            ; //_A569F39CC_360:;				
            _A569F39CC_360:
            ; //	sSI	= (int)&_s_0_4;			
0066D:      	AR	= 2
0066E:      	I1	= rm[BP_SAVE]
0066F:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00670:      	AX	= rm[I1]
            ; //	goto LF2D2B0F3_115;			
00671:      	jmp	LF2D2B0F3_115
            ; //LF2D2B0F3_115:;					
            LF2D2B0F3_115:
            ; //_A569F39CC_361:;				
            _A569F39CC_361:
            ; //	return;					
00672:      	AR	= 1
00673:      	BP	+= AR
00674:      	pop	AR
00675:      	rm[BP_SAVE]	= AR
00676:      	rets
            ; //_memset_sC3E11DB1_end:;				
            _memset_sC3E11DB1_end:
            ; //_A569F39CC_362:;				
            _A569F39CC_362:
            ; //}
            ; //
            ; //rcall rjmp void _memset_rC7200006(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8)
            _memset_rC7200006:
            ; //{
            ; //	__int16 _ret_1_2;
            ; //						
00677:      	AR	= rm[BP_SAVE]
00678:      	push	AR
00679:      	AR	= BP
0067A:      	rm[BP_SAVE]	= AR
0067B:      	AR	 = -1
0067C:      	BP	+= AR
            ; //_A569F39CC_363:;				
            _A569F39CC_363:
            ; //	
            ; //_A569F39CC_364:;				
            _A569F39CC_364:
            ; //	sSI	= (int)&_s_0_4;			
0067D:      	AR	= 2
0067E:      	I1	= rm[BP_SAVE]
0067F:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00680:      	AX	= rm[I1]
            ; //	sSI	= (int)&_ret_1_2;		
00681:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
00682:      	rm[I1]	= AX
            ; //LF2D2B0F3_121:;					
            LF2D2B0F3_121:
            ; //_A569F39CC_365:;				
            _A569F39CC_365:
            ; //	sSI	= (int)&_n_0_8;			
00683:      	AR	= 4
00684:      	I1	= rm[BP_SAVE]
00685:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00686:      	AX	= rm[I1]
            ; //	sSI	= (int)&_n_0_8;			
00687:      	AR	= 4
00688:      	I1	= rm[BP_SAVE]
00689:      	I1	+= AR
            ; //	asm AR = 0x0001;			
0068A:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
0068B:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
0068C:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
0068D:      	AR	= AX
            ; //	if(__jnz__)	goto LF2D2B0F3_122;	
0068E:      	if NZ	jmp LF2D2B0F3_122
            ; //	goto	LF2D2B0F3_120;			
0068F:      	jmp	LF2D2B0F3_120
            ; //LF2D2B0F3_122:;					
            LF2D2B0F3_122:
            ; //_A569F39CC_366:;				
            _A569F39CC_366:
            ; //	sSI	= (int)&_ret_1_2;		
00690:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00691:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
00692:      	push	AX
            ; //	sSI	= (int)&_c_0_6;			
00693:      	AR	= 3
00694:      	I1	= rm[BP_SAVE]
00695:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00696:      	AX	= rm[I1]
            ; //	sSI	= POP();			
00697:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00698:      	rm[I1]	= AX
            ; //	sSI	= (int)&_ret_1_2;		
00699:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
0069A:      	AR = 0x0001//
            ; //	sAX	= *(__int16*)sSI;		
0069B:      	AX	= rm[I1]
            ; //	asm rm[I1] = AX + AR;			
0069C:      	rm[I1] = AX + AR//
            ; //_A569F39CC_367:;				
            _A569F39CC_367:
            ; //	goto LF2D2B0F3_121;			
0069D:      	jmp	LF2D2B0F3_121
            ; //LF2D2B0F3_120:;					
            LF2D2B0F3_120:
            ; //_A569F39CC_368:;				
            _A569F39CC_368:
            ; //	sSI	= (int)&_s_0_4;			
0069E:      	AR	= 2
0069F:      	I1	= rm[BP_SAVE]
006A0:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
006A1:      	AX	= rm[I1]
            ; //	goto LF2D2B0F3_119;			
006A2:      	jmp	LF2D2B0F3_119
            ; //LF2D2B0F3_119:;					
            LF2D2B0F3_119:
            ; //_A569F39CC_369:;				
            _A569F39CC_369:
            ; //	return;					
006A3:      	AR	= 1
006A4:      	BP	+= AR
006A5:      	pop	AR
006A6:      	rm[BP_SAVE]	= AR
006A7:      	rets
            ; //_memset_rC7200006_end:;				
            _memset_rC7200006_end:
            ; //_A569F39CC_370:;				
            _A569F39CC_370:
            ; //}
            ; //
            ; //rcall rjmp void _memset5A9D755A(__int16 _s_0_4_0, __int16 _s_0_4_1, __int16 _c_0_8, __int16 _n_0_10)
            _memset5A9D755A:
            ; //{						
006A8:      	AR	= rm[BP_SAVE]
006A9:      	push	AR
006AA:      	AR	= BP
006AB:      	rm[BP_SAVE]	= AR
            ; //_A569F39CC_371:;				
            _A569F39CC_371:
            ; //	
            ; //_A569F39CC_372:;				
            _A569F39CC_372:
            ; //	sAX	= (int)&_s_0_4_0;		
006AC:      	AR	= 2
006AD:      	AX	= rm[BP_SAVE]
006AE:      	AX	+= AR
            ; //	sCX	= 0x0001;			
006AF:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
006B0:      	AR	= CX
006B1:      	AX	+= AR
            ; //	sSI	= sAX;				
006B2:      	AR	= AX
006B3:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
006B4:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
006B5:      	AR	= AX
            ; //	if(__jnz__)	goto LF2D2B0F3_125;	
006B6:      	if NZ	jmp LF2D2B0F3_125
            ; //	goto	LF2D2B0F3_124;			
006B7:      	jmp	LF2D2B0F3_124
            ; //LF2D2B0F3_125:;					
            LF2D2B0F3_125:
            ; //_A569F39CC_373:;				
            _A569F39CC_373:
            ; //_A569F39CC_374:;				
            _A569F39CC_374:
            ; //	sSI	= (int)&_n_0_10;		
006B8:      	AR	= 5
006B9:      	I1	= rm[BP_SAVE]
006BA:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
006BB:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
006BC:      	push	AX
            ; //	sSI	= (int)&_c_0_8;			
006BD:      	AR	= 4
006BE:      	I1	= rm[BP_SAVE]
006BF:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
006C0:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
006C1:      	push	AX
            ; //	sAX	= (int)&_s_0_4_0;		
006C2:      	AR	= 2
006C3:      	AX	= rm[BP_SAVE]
006C4:      	AX	+= AR
            ; //	sSI	= sAX;				
006C5:      	AR	= AX
006C6:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
006C7:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
006C8:      	push	AX
            ; //	_memset_rC7200006(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2]);
006C9:      	call	_memset_rC7200006
            ; //	RESTORESP(3);				
006CA:      	AR	= 3
006CB:      	BP	+= AR
            ; //	sDX	= 0x0800;			
006CC:      	DX	= 0x0800
            ; //	goto LF2D2B0F3_123;			
006CE:      	jmp	LF2D2B0F3_123
            ; //LF2D2B0F3_124:;					
            LF2D2B0F3_124:
            ; //_A569F39CC_375:;				
            _A569F39CC_375:
            ; //_A569F39CC_376:;				
            _A569F39CC_376:
            ; //_A569F39CC_377:;				
            _A569F39CC_377:
            ; //	sSI	= (int)&_n_0_10;		
006CF:      	AR	= 5
006D0:      	I1	= rm[BP_SAVE]
006D1:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
006D2:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
006D3:      	push	AX
            ; //	sSI	= (int)&_c_0_8;			
006D4:      	AR	= 4
006D5:      	I1	= rm[BP_SAVE]
006D6:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
006D7:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
006D8:      	push	AX
            ; //	sAX	= (int)&_s_0_4_0;		
006D9:      	AR	= 2
006DA:      	AX	= rm[BP_SAVE]
006DB:      	AX	+= AR
            ; //	sSI	= sAX;				
006DC:      	AR	= AX
006DD:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
006DE:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
006DF:      	push	AX
            ; //	_memset_sC3E11DB1(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2]);
006E0:      	call	_memset_sC3E11DB1
            ; //	RESTORESP(3);				
006E1:      	AR	= 3
006E2:      	BP	+= AR
            ; //	sDX	= 0;				
006E3:      	DX	= 0x00
            ; //	goto LF2D2B0F3_123;			
006E4:      	jmp	LF2D2B0F3_123
            ; //LF2D2B0F3_123:;					
            LF2D2B0F3_123:
            ; //_A569F39CC_378:;				
            _A569F39CC_378:
            ; //	return;					
006E5:      	pop	AR
006E6:      	rm[BP_SAVE]	= AR
006E7:      	rets
            ; //_memset5A9D755A_end:;				
            _memset5A9D755A_end:
            ; //_A569F39CC_379:;				
            _A569F39CC_379:
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\MEMSET_CDCF17ED.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\ADP12_EF8DA009.S.CODE.ASM> Start=========================
            ; C:\TRITAN\FDSP-IDE\tools\CC\lib\libadpcm\adp12.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //	nop
            ; //
            ; //
            ;=========================Include <DEPS\ADP12_EF8DA009.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBADPCM\ADP12_CSHELL-E.ASM> Start=========================
            
            
            
            
            
            _SDSP_ADPCM_4Bit_SingleCH_decoder94C4563E:
            ; {
006E8:      	PCH=            SDSP_ADPCM_4Bit_SingleCH_decoder
006E9:              lcall           SDSP_ADPCM_4Bit_SingleCH_decoder	; Z fail
006EA:              AX=		1
006EB:              if NZ jmp	L9E1082DD_0
006EC:              AX=		0
            L9E1082DD_0:
006ED:      	rets
            ; }
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBADPCM\ADP12_CSHELL-E.ASM> End=========================
            
            ;
            #LINKOBJ "C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBADPCM\XDSP_ADPCM_4BIT_DECV04.OBJ"
            ;
            
            ;=========================Include <DEPS\3D044B19_GINIT.S.CODE.ASM> Start=========================
            ; 3D044B19_ginit.s.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code(void)			
            ginit_code:
            ; //{
            ; //	ginit_code_touch_AB036625_s();		
00A23:      	pch	= ginit_code_touch_AB036625_s
00A24:      	lcall	ginit_code_touch_AB036625_s
            ; //	return;					
00A25:      	rets
            ; //}
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\3D044B19_GINIT.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> Start=========================
            
            
            ; ~~ CRT0 support functions
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GLOBALINIT(void)
            ; void sfx_LOCALINIT(void)
            ;
            ; in:
            ;     I1	- pointer to SRAM initial value
            ;     P1	- pointer to PROM initial data
            ;     CX	- total count (word)
            ;
            ; out:
            ;     none
            ;
            ; --------------------------------------------
            sfx_GLOBALINIT:
            sfx_LOCALINIT:
00A26:      	P1.hh=		0
00A27:      	jmp		@glinit_label_1409
            @glinit_loop_1409:
00A28:      	AR=		pm[P1++]
00A29:      	rm[I1++]=	AR
            @glinit_label_1409:
00A2A:      	loop		@glinit_loop_1409
00A2B:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MUL_AX_CX(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MUL_AX_CX:
            
00A2C:      	AR=		AX
00A2D:      	MX=		AR
00A2E:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00A2F:      	MACOP=		3
00A30:      	MR=		MX * AR
            #endif
            
00A31:      	AR=		MR0
00A32:      	AX=		AR
00A33:      	AR=		MR1
00A34:      	DX=		AR
00A35:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMUL_AX_CX(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMUL_AX_CX:
            
00A36:      	AR=		AX
00A37:      	MX=		AR
00A38:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
00A39:      	MACOP=		0
00A3A:      	MR=		MX * AR
            #endif
            
00A3B:      	AR=		MR0
00A3C:      	AX=		AR
00A3D:      	AR=		MR1
00A3E:      	DX=		AR
00A3F:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMULLONG(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMULLONG:
00A40:      	AR=		rm[BP_SAVE]
00A41:      	push		AR
00A42:      	AR=		BP
00A43:      	rm[BP_SAVE]=	AR
00A44:      	AR=		AR - 3
00A45:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
00A46:      	AR=		CX
00A47:      	MX=		AR
00A48:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00A49:      	MACOP=		3		; unsigned
00A4A:      	MR=		MX * AR
            #endif
            
00A4B:      	I1=		rm[BP_SAVE]
00A4C:      	AR=		2
00A4D:      	I1=		I1 - AR
00A4E:      	rm[I1++]=	MR0
00A4F:      	rm[I1++]=	MR1
00A50:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
00A51:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUS
            #else
00A52:      	MACOP=		1		; mx:unsigned / my:signed
00A53:      	MR=		MX * AR
            #endif
            
00A54:      	AR=		rm[I1]
00A55:      	AR=		AR + MR0
00A56:      	rm[I1++]=	AR
00A57:      	AR=		rm[I1]
00A58:      	AR=		AR + MR1 + C
00A59:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
00A5A:      	AR=		BX
00A5B:      	MX=		AR
00A5C:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULSU
            #else
00A5D:      	MACOP=		2		; mx:signed / my:unsigned
00A5E:      	MR=		MX * AR
            #endif
            
00A5F:      	AR=		rm[I1]
00A60:      	AR=		AR + MR0
00A61:      	rm[I1++]=	AR
00A62:      	AR=		rm[I1]
00A63:      	AR=		AR + MR1 + C
00A64:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
00A65:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
00A66:      	MACOP=		0		; mx:signed / my:signed
00A67:      	MR=		MX * AR
            #endif
            
00A68:      	AR=		rm[I1]
00A69:      	AR=		AR + MR0
00A6A:      	rm[I1]=		AR
            
00A6B:      	I1=		rm[BP_SAVE]
00A6C:      	CX=		rm[I1--]
00A6D:      	DX=		rm[I1--]
00A6E:      	AX=		rm[I1]
            
00A6F:      	AR=		3
00A70:      	BP=		BP + AR
00A71:      	pop		AR
00A72:      	rm[BP_SAVE]=	AR
            
00A73:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MULLONG(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MULLONG:
00A74:      	AR=		rm[BP_SAVE]
00A75:      	push		AR
00A76:      	AR=		BP
00A77:      	rm[BP_SAVE]=	AR
00A78:      	AR=		AR - 3
00A79:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
00A7A:      	AR=		CX
00A7B:      	MX=		AR
00A7C:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00A7D:      	MACOP=		3		; unsigned
00A7E:      	MR=		MX * AR
            #endif
            
00A7F:      	I1=		rm[BP_SAVE]
00A80:      	AR=		2
00A81:      	I1=		I1 - AR
00A82:      	rm[I1++]=	MR0
00A83:      	rm[I1++]=	MR1
00A84:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
00A85:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00A86:      	MR=		MX * AR
            #endif
            
00A87:      	AR=		rm[I1]
00A88:      	AR=		AR + MR0
00A89:      	rm[I1++]=	AR
00A8A:      	AR=		rm[I1]
00A8B:      	AR=		AR + MR1 + C
00A8C:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
00A8D:      	AR=		BX
00A8E:      	MX=		AR
00A8F:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00A90:      	MR=		MX * AR
            #endif
            
00A91:      	AR=		rm[I1]
00A92:      	AR=		AR + MR0
00A93:      	rm[I1++]=	AR
00A94:      	AR=		rm[I1]
00A95:      	AR=		AR + MR1 + C
00A96:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
00A97:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00A98:      	MR=		MX * AR
            #endif
            
00A99:      	AR=		rm[I1]
00A9A:      	AR=		AR + MR0
00A9B:      	rm[I1]=		AR
            
00A9C:      	I1=		rm[BP_SAVE]
00A9D:      	CX=		rm[I1--]
00A9E:      	DX=		rm[I1--]
00A9F:      	AX=		rm[I1]
            
00AA0:      	AR=		3
00AA1:      	BP=		BP + AR
00AA2:      	pop		AR
00AA3:      	rm[BP_SAVE]=	AR
            
00AA4:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIV_AX_CX(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIV_AX_CX:
            	; unsigned int reste = 0;
00AA5:      		DX=		0
            	; unsigned char count = 16;
00AA6:      		R0=		16
            	; BOOL c;
            
            	; do
            	@divword_loop_1824:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
00AA7:      			slz		AX, 1
            		; reste <<= 1;
00AA8:      			slc		DX, 1
            
            		; if (c)
            		; {
            			; reste |= 1;
            		; }
            		@divword_label_1822:
            
            		; if (reste >= y)
00AA9:      			AR=		DX
00AAA:      			AR-=		CX
00AAB:      			AR=		0
00AAC:      			AR=		AR - 0 + C - 1
00AAD:      			if AN jmp	@divword_label_1823
            		; {
            			; reste -= y;
00AAE:      				AR=		CX
00AAF:      				DX=		DX - AR
            			; ~~ x <- (result = 1)
            			; x |= 1;
00AB0:      				set		AX.b0
            		; }
            		@divword_label_1823:
            
00AB1:      		R0--
00AB2:      		if NZ jmp	@divword_loop_1824
            	; }while (--count);
            
            	; return x;
00AB3:      		rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIV_AX_CX(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIV_AX_CX:
            
            	; register int r;
            
            	; r = sfx_DIV_AX_CX((x < 0 ? -x : x), (y < 0 ? -y : y));
00AB4:      		R1=		0
00AB5:      		AR=		0
00AB6:      		test		AX.b15
00AB7:      		if ZR jmp	@divsword_label_1833
00AB8:      			AX=		AR - AX
00AB9:      			set		R1.b0
            		@divsword_label_1833:
00ABA:      		test		CX.b15
00ABB:      		if ZR jmp	@divsword_label_1834
00ABC:      			CX=		AR - CX
00ABD:      			set		R1.b1
            		@divsword_label_1834:
00ABE:      		call		sfx_DIV_AX_CX
            
            	; if ((x < 0) ^ (y < 0))
00ABF:      		AR=		R1
00AC0:      		slz		AR, 1
00AC1:      		AR^=		R1
00AC2:      		test		AR.b1
00AC3:      		if ZR jmp	@divsword_label_1835
            	; {
            		; return (0 - r);
00AC4:      			AR=		0
00AC5:      			AX=		AR - AX
00AC6:      			DX=		AR - DX
            
            	; }
            	@divsword_label_1835:
            
            	; return r;
00AC7:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIVLONG(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIVLONG:
            	; unsigned long reste = 0L;
00AC8:      		R0=		0	; L
00AC9:      		R1=		0	; H
            	; unsigned char count = 32;
00ACA:      		R2=		32
            	; BOOL c;
            
            	; do
            	@divulong_loop_1723:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
00ACB:      			slz		AX, 1
00ACC:      			slc		DX, 1
            		; reste <<= 1;
00ACD:      			slc		R0, 1
00ACE:      			slc		R1, 1
            
            		; if (c)
            		; {
            			; reste |= 1L;
            		; }
            		@divulong_label_1726:
            
            		; if (reste >= y)
00ACF:      			AR=		R0
00AD0:      			AR-=		CX
00AD1:      			AR=		R1
00AD2:      			AR=		AR - BX + C - 1
00AD3:      			if AN jmp	@divulong_label_1734
            		; {
            			; reste -= y;
00AD4:      				AR=		CX
00AD5:      				R0=		R0 - AR
00AD6:      				AR=		BX
00AD7:      				R1=		R1 - AR + C - 1
            			; ~~ x <- (result = 1)
            			; x |= 1L;
00AD8:      				set		AX.b0
            		; }
            		@divulong_label_1734:
            
00AD9:      		R2--
00ADA:      		if NZ jmp	@divulong_loop_1723
            	; }while (--count);
            
            	; return x;
00ADB:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIVLONG(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     BX:DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIVLONG:
            	; long r;
            
            	; r = divulong((x < 0 ? -x : x), (y < 0 ? -y : y));
00ADC:      		R3=		0
00ADD:      		AR=		0
00ADE:      		test		DX.b15
00ADF:      		if ZR jmp	@divslong_label_1759
00AE0:      			AX=		AR - AX
00AE1:      			DX=		AR - DX + C - 1
00AE2:      			set		R3.b0
            		@divslong_label_1759:
00AE3:      		test		BX.b15
00AE4:      		if ZR jmp	@divslong_label_1800
00AE5:      			CX=		AR - CX
00AE6:      			BX=		AR - BX + C - 1
00AE7:      			set		R3.b1
            		@divslong_label_1800:
00AE8:      		call		sfx_DIVLONG
            
            	; if ((x < 0) ^ (y < 0))
00AE9:      		AR=		R3
00AEA:      		slz		AR, 1
00AEB:      		AR^=		R3
00AEC:      		test		AR.b1
00AED:      		if ZR jmp	@divslong_label_1807
            	; {
            		; return -r;
00AEE:      			AR=		0
00AEF:      			AX=		AR - AX
00AF0:      			DX=		AR - DX + C - 1
00AF1:      			R0=		AR - R0
00AF2:      			R1=		AR - R1 + C - 1
            
            	; }
            	@divslong_label_1807:
            
            	; return r;
00AF3:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MOD_AX_CX(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_MOD_AX_CX:
00AF4:      	call		sfx_DIV_AX_CX
00AF5:      	AR=		DX
00AF6:      	AX=		AR
00AF7:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMOD_AX_CX(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMOD_AX_CX:
00AF8:      	call		sfx_IDIV_AX_CX
00AF9:      	AR=		DX
00AFA:      	AX=		AR
00AFB:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MODLONG(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_MODLONG:
00AFC:      	call		sfx_DIVLONG
00AFD:      	AR=		R0
00AFE:      	AX=		AR
00AFF:      	AR=		R1
00B00:      	DX=		AR
00B01:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMODLONG(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMODLONG:
00B02:      	call		sfx_IDIVLONG
00B03:      	AR=		R0
00B04:      	AX=		AR
00B05:      	AR=		R1
00B06:      	DX=		AR
00B07:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG:
            	; AR=		CX
            	; AX=		AX + AR
            	; AR=		BX
            	; DX=		DX + AR + C
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG_BXCX_DXAX(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG_BXCX_DXAX:
            	; AR=		AX
            	; CX=		CX + AR
            	; AR=		DX
            	; BX=		BX + AR + C
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBLONG(void)
            ;
            ; note:
            ;     signed sub
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SUBLONG:
            	; AR=		CX
            	; AX=		AX - AR
            	; AR=		BX
            	; DX=		DX - AR + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDDIOFS(void)
            ;
            ; note:
            ;     add P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDDIOFS:
00B08:      	AR=		AX
00B09:      	P1=		P1 + AR
00B0A:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDSIOFS(void)
            ;
            ; note:
            ;     add I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDSIOFS:
00B0B:      	AR=		AX
00B0C:      	I1=		I1 + AR
00B0D:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDAXOFS(void)
            ;
            ; note:
            ;     add AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_ADDAXOFS:
00B0E:      	AR=		CX
00B0F:      	AX=		AX + AR
00B10:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBDIOFS(void)
            ;
            ; note:
            ;     sub P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBDIOFS:
00B11:      	AR=		AX
00B12:      	P1=		P1 - AR
00B13:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBSIOFS(void)
            ;
            ; note:
            ;     sub I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBSIOFS:
00B14:      	AR=		AX
00B15:      	I1=		I1 - AR
00B16:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBAXOFS(void)
            ;
            ; note:
            ;     sub AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_SUBAXOFS:
00B17:      	AR=		CX
00B18:      	AX=		AX + AR
00B19:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_DXAX(void)
            ;
            ; note:
            ;     load long data from PROM to DX:AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG:
            ; sfx_GETDILONG_DXAX:
            	; AX=		pm[P1++]
            	; DX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_BXCX(void)
            ;
            ; note:
            ;     load long data from PROM to BX:CX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG_BXCX:
            	; CX=		pm[P1++]
            	; BX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_DXAX(void)
            ; void sfx_GETSILONG_DXAX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to DX:AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG:
            ; sfx_GETSILONG_D:
            ; sfx_GETSILONG_DXAX:
            ; sfx_GETSILONG_DXAX_D:
            	; AX=		rm[I1++]
            	; DX=		rm[I1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_BXCX(void)
            ; void sfx_GETSILONG_BXCX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to BX:CX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG_BXCX:
            ; sfx_GETSILONG_BXCX_D:
            	; CX=		rm[I1++]
            	; BX=		rm[I1--]
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ANDLONG(void)
            ;
            ; note:
            ;     AND two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ANDLONG:
            	; AR=		CX
            	; AX=		AX & AR
            	; AR=		BX
            	; DX=		DX & AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ORLONG(void)
            ;
            ; note:
            ;     OR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ORLONG:
            	; AR=		CX
            	; AX=		AX | AR
            	; AR=		BX
            	; DX=		DX | AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XORLONG(void)
            ;
            ; note:
            ;     XOR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_XORLONG:
            	; AR=		CX
            	; AX=		AX ^ AR
            	; AR=		BX
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHL_AX_CX(void)
            ;
            ; note:
            ;     left shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHL_AX_CX:
            	; jmp		@shlac_label_1653
            ; @shlac_loop_1653:
            	; slz		AX, 1
            ; @shlac_label_1653:
            	; loop		@shlac_loop_1653
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SHLLONG(void)
            ;
            ; note:
            ;     left shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHLLONG:
            	; jmp		@shllong_label_1653
            ; @shllong_loop_1653:
            	; slz		AX, 1
            	; slc		DX, 1
            ; @shllong_label_1653:
            	; loop		@shllong_loop_1653
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX_CX(void)
            ;
            ; note:
            ;     unsigned right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX_CX:
            	; jmp		@shrac_label_1657
            ; @shrac_loop_1657:
            	; clr		C
            	; src		AX, 1
            ; @shrac_label_1657:
            	; loop		@shrac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX_CX(void)
            ;
            ; note:
            ;     signed right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX_CX:
            	; jmp		@sarac_label_1657
            ; @sarac_loop_1657:
            	; sra		AX, 1
            ; @sarac_label_1657:
            	; loop		@sarac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SARLONG(void)
            ;
            ; note:
            ;     signed right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SARLONG:
            	; jmp		@sarlong_label_1657
            ; @sarlong_loop_1657:
            	; sra		DX, 1
            	; src		AX, 1
            ; @sarlong_label_1657:
            	; loop		@sarlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHRLONG(void)
            ;
            ; note:
            ;     unsigned right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- ulong data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHRLONG:
            	; jmp		@shrlong_label_1657
            ; @shrlong_loop_1657:
            	; clr		C
            	; src		DX, 1
            	; src		AX, 1
            ; @shrlong_label_1657:
            	; loop		@shrlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX(void)
            ;
            ; note:
            ;     unsigned right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX:
            	; clr		C
            	; src		AX, 1
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX(void)
            ;
            ; note:
            ;     signed right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX:
            	; sra		AX, 1
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG(void)
            ; void sfx_STORSILONG_D(void)		; for function's parameter
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG:
            ; sfx_STORSILONG_D:
            	; rm[I1++]=	AX
            	; rm[I1--]=	DX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG_BXCX(void)
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG_BXCX:
            	; rm[I1++]=	CX
            	; rm[I1--]=	BX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG:
00B1A:      	pm[P1++]=	AX
00B1B:      	pm[P1--]=	DX
00B1C:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG_BXCX:
00B1D:      	pm[P1++]=	CX
00B1E:      	pm[P1--]=	BX
00B1F:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CX to BX
            ;
            ; in:
            ;     CX	- signed short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_CX:
            ; sfx_INT2ULONG_CX:
            	; BX=		0
            	; test		CX.b15
            	; if ZR jmp	@i2lcx_label_1756
            	; BX=		-1
            ; @i2lcx_label_1756:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_CX(void)
            ;
            ; note:
            ;     convert short unsigned value CX to long (BX:CX)
            ;
            ; in:
            ;     CX	- unsigned short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_CX:
            ; sfx_UINT2ULONG_CX:
            	; BX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CL to BX:CH
            ;
            ; in:
            ;     CX	- signed char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_CX:
00B20:      	BX=		0
00B21:      	CX.h=		0
00B22:      	test		CX.b7
00B23:      	if ZR jmp	@c2lcx_label_1800
00B24:      	CX.h=		0xFF
00B25:      	BX=		-1
            @c2lcx_label_1800:
00B26:      	rets
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_CX(void)
            ;
            ; note:
            ;     convert unsigned char value CL to long (BX:CX)
            ;
            ; in:
            ;     CL	- unsigned char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_CX:
            	; CX.h=		0
            	; BX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AX to DX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_AX:
            ; sfx_INT2ULONG_AX:
            	; DX=		0
            	; test		AX.b15
            	; if ZR jmp	@i2lax_label_1756
            	; DX=		-1
            ; @i2lax_label_1756:
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_AX(void)
            ;
            ; note:
            ;     convert short unsigned value AX to long (DX:AX)
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_AX:
            ; sfx_UINT2ULONG_AX:
            	; DX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AL to DX:AH
            ;
            ; in:
            ;     AX	- signed char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_AX:
00B27:      	DX=		0
00B28:      	AX.h=		0
00B29:      	test		AX.b7
00B2A:      	if ZR jmp	@c2lax_label_1800
00B2B:      	AX.h=		0xFF
00B2C:      	DX=		-1
            @c2lax_label_1800:
00B2D:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_AX(void)
            ;
            ; note:
            ;     convert unsigned char value AL to long (DX:AX)
            ;
            ; in:
            ;     AL	- unsigned char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_AX:
            	; AX.h=		0
            	; DX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CALL_BY_AX(void)
            ;
            ; note:
            ;     call sub routine in AX (address)
            ;
            ; in:
            ;     AX	- sub routine address
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_CALL_BY_AX:
            	; AR=		AX
            	; P1=		AR
            	; P1.hh=		0
            	; fjmp		pm[P1]
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHG_AX_CX(void)
            ;
            ; note:
            ;     exchange AX CX value
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; result:
            ;     AX <-> CX
            ;
            ; --------------------------------------------
            ; sfx_XCHG_AX_CX:
            	; push		AX
            	; push		CX
            	; pop		AX
            	; pop		CX
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHGLONG(void)
            ;
            ; note:
            ;     exchange DX:AX BX:CX value
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; result:
            ;     DX:AX <-> BX:CX
            ;
            ; --------------------------------------------
            sfx_XCHGLONG:
00B2E:      	push		AX
00B2F:      	push		CX
00B30:      	pop		AX
00B31:      	pop		CX
00B32:      	push		DX
00B33:      	push		BX
00B34:      	pop		DX
00B35:      	pop		BX
00B36:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEG_AX(void)
            ;
            ; note:
            ;     negative AX
            ;
            ; in:
            ;     AX	- operator 1
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEG_AX:
            	; AR=		0
            	; AX=		AR - AX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEGLONG(void)
            ;
            ; note:
            ;     negative DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEGLONG:
            	; AR=		0
            	; AX=		AR - AX
            	; DX=		AR - DX + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOT_AX(void)
            ;
            ; note:
            ;     not AX
            ;
            ; in:
            ;     AX	- operator
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOT_AX:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOTLONG(void)
            ;
            ; note:
            ;     not DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOTLONG:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOT_AX(void)
            ;
            ; note:
            ;     logical NOT
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_LOGNOT_AX:
            	;; x86 code
            	;;   neg AX
            	;;   sbb AX,AX
            	;;   inc AX
            	; AR=		0
            	; AR=		AR - AX
            	; AX=		AR
            	; AX=		AR - AX + C - 1
            	; AX++
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOTLONG(void)
            ;
            ; note:
            ;     logical NOT (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            sfx_LOGNOTLONG:
            	; x86 code
            	;   neg AX
            	;   sbb AX,AX
            	;   inc AX
00B37:      	AR=		DX
00B38:      	DX=		0
00B39:      	AR=		AR | AX
00B3A:      	AX=		1
00B3B:      	if ZR jmp	@longnotl_label_1120
00B3C:      	AX=		0
            @longnotl_label_1120:
00B3D:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOL_AX(void)
            ;
            ; note:
            ;     logical BOOL
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOL_AX:
            	;; x86 code
            	;;   neg ax
            	;;   sbb ax,ax
            	;;   neg ax
            	; AR=		AX
            	; AX=		0
            	; if ZR jmp	@boolax_label_1758
            	; AX=		1
            ; @boolax_label_1758:
            	; rets
            
            	; AR=		-1
            	; AR=		AR + AX
            	; AX=		0
            	; AX += C
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOLLONG(void)
            ;
            ; note:
            ;     logical BOOL (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOLLONG:
            	; AR=		DX
            	; DX=		0
            	; AR=		AR | AX
            	; AX=		0
            	; if ZR jmp	@boollong_label_1801
            	; AX=		1
            ; @boollong_label_1801:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INITSISTOR(void)
            ;
            ; note:
            ;     for used in global/local variable initial
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     I1 + 1
            ;
            ; --------------------------------------------
            ; sfx_INITSISTOR:
            	; rm[I1++]=	AX
            	; rets
            
            ; --------------------------------------------
            
            ; sfx_INITSISTORLONG:
            	; rm[I1++]=	AX
            	; rm[I1++]=	DX
            	; rets
            
            
            ; ~~ condition assistant functions ~~
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; JNE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            sfx_CMP_AX_CX_U_JNE:
00B3E:      	DX=		0
00B3F:      	BX=		0
            sfx_CMPLONG_JNE:
00B40:      	AR=		CX
00B41:      	AX=		AX - AR
00B42:      	AR=		BX
00B43:      	AR=		DX - AR + C - 1
00B44:      	AR=		AR | AX
00B45:      	if EQ jmp	@sfx_cl_jne_f
00B46:      	set		Z		; true
00B47:      	rets
            @sfx_cl_jne_f:
00B48:      	clr		Z		; false
00B49:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JNE:
00B4A:      	DX=		0
00B4B:      	BX=		0
            sfx_CMPLONG_BCDA_JNE:
00B4C:      	AR=		AX
00B4D:      	CX=		CX - AR
00B4E:      	AR=		DX
00B4F:      	AR=		BX - AR + C - 1
00B50:      	AR=		AR | CX
00B51:      	if EQ jmp	@sfx_clbcda_jne_f
00B52:      	set		Z		; true
00B53:      	rets
            @sfx_clbcda_jne_f:
00B54:      	clr		Z		; false
00B55:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JNE:
00B56:      	AR=		CX
00B57:      	SF=		AX - AR
00B58:      	if EQ jmp	@sfx_ac_jne_f
00B59:      	set		Z
00B5A:      	rets
            @sfx_ac_jne_f:
00B5B:      	clr		Z
00B5C:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JNE:
00B5D:      	AR=		AX
00B5E:      	SF=		CX - AR
00B5F:      	if EQ jmp	@sfx_ca_jne_f
00B60:      	set		Z
00B61:      	rets
            @sfx_ca_jne_f:
00B62:      	clr		Z
00B63:      	rets
            
            
            
            ; JE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            
            
            sfx_CMP_AX_CX_U_JE:
00B64:      	DX=		0
00B65:      	BX=		0
            sfx_CMPLONG_JE:
00B66:      	AR=		CX
00B67:      	AX=		AX - AR
00B68:      	AR=		BX
00B69:      	AR=		DX - AR + C - 1
00B6A:      	AR=		AR | AX
00B6B:      	if NE jmp	@sfx_cl_jz_f
00B6C:      	set		Z		; true
00B6D:      	rets
            @sfx_cl_jz_f:
00B6E:      	clr		Z		; false
00B6F:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JE:
00B70:      	DX=		0
00B71:      	BX=		0
            sfx_CMPLONG_BCDA_JE:
00B72:      	AR=		AX
00B73:      	CX=		CX - AR
00B74:      	AR=		DX
00B75:      	AR=		BX - AR + C - 1
00B76:      	AR=		AR | CX
00B77:      	if NE jmp	@sfx_clbcda_jz_f
00B78:      	set		Z		; true
00B79:      	rets
            @sfx_clbcda_jz_f:
00B7A:      	clr		Z		; false
00B7B:      	rets
            
            ; ---------
            
            ; sfx_CMP_AX_CX_JE:
            	; AR=		CX
            	; SF=		AX - AR
            	; if NE jmp	@sfx_ac_je_f
            	; set		Z
            	; rets
            ; @sfx_ac_je_f:
            	; clr		Z
            	; rets
            
            ; ---------
            
            ; sfx_CMP_CX_AX_JE:
            	; AR=		AX
            	; SF=		CX - AR
            	; if NE jmp	@sfx_ca_je_f
            	; set		Z
            	; rets
            ; @sfx_ca_je_f:
            	; clr		Z
            	; rets
            
            
            
            ; JG group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; A - above (unsigned)
            ; G - greater (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JA:
            sfx_CMP_AX_CX_JA:
00B7C:      	DX=		0
00B7D:      	BX=		0
            sfx_CMPLONG_JG:
00B7E:      	AR=		CX
00B7F:      	AX=		AX - AR
00B80:      	AR=		BX
00B81:      	AR=		DX - AR + C - 1
00B82:      	if AN jmp	@sfx_cl_jg_f
            
            	; exclude EQU condition
00B83:      	AR=		AR | AX
00B84:      	if ZR jmp	@sfx_cl_jg_f
            
00B85:      	set		Z		; true
00B86:      	rets
            @sfx_cl_jg_f:
00B87:      	clr		Z		; false
00B88:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JA:
00B89:      	AR=		CX
00B8A:      	AX=		AX - AR
00B8B:      	AR=		BX
00B8C:      	DX=		DX - AR + C - 1
00B8D:      	AR=		0
00B8E:      	AR=		AR - 0 + C - 1
00B8F:      	if AN jmp	@sfx_cl_jg_f
            
00B90:      	AR=		AR | DX		; exclude EQU condition
00B91:      	AR=		AR | AX
00B92:      	if ZR jmp	@sfx_cl_jg_f
            
00B93:      	set		Z		; true
00B94:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JA:
            sfx_CMP_CX_AX_JA:
00B95:      	DX=		0
00B96:      	BX=		0
            sfx_CMPLONG_BCDA_JG:
00B97:      	AR=		AX
00B98:      	CX=		CX - AR
00B99:      	AR=		DX
00B9A:      	AR=		BX - AR + C - 1
00B9B:      	if AN jmp	@sfx_clbcda_jg_f
            
00B9C:      	AR=		AR | CX		; exclude EQU condition
00B9D:      	if ZR jmp	@sfx_clbcda_jg_f
            
00B9E:      	set		Z		; true
00B9F:      	rets
            @sfx_clbcda_jg_f:
00BA0:      	clr		Z		; false
00BA1:      	rets
            
            ; ~~---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JA:
00BA2:      	AR=		AX
00BA3:      	CX=		CX - AR
00BA4:      	AR=		DX
00BA5:      	BX=		BX - AR + C - 1
00BA6:      	AR=		0
00BA7:      	AR=		AR - 0 + C - 1
00BA8:      	if AN jmp	@sfx_clbcda_jg_f
            
00BA9:      	AR=		AR | BX		; exclude EQU condition
00BAA:      	AR=		AR | CX
00BAB:      	if ZR jmp	@sfx_clbcda_jg_f
            
00BAC:      	set		Z		; true
00BAD:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JG:
00BAE:      	AR=		CX
00BAF:      	SF=		AX - AR
00BB0:      	if LE jmp	@sfx_cmp_ac_jg_f
00BB1:      	set		Z
00BB2:      	rets
            @sfx_cmp_ac_jg_f:
00BB3:      	clr		Z
00BB4:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JG:
00BB5:      	AR=		AX
00BB6:      	SF=		CX - AR
00BB7:      	if LE jmp	@sfx_cmp_ca_jg_f
00BB8:      	set		Z
00BB9:      	rets
            @sfx_cmp_ca_jg_f:
00BBA:      	clr		Z
00BBB:      	rets
            
            
            ; JGE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JAE:
            sfx_CMP_AX_CX_JAE:
00BBC:      	DX=		0
00BBD:      	BX=		0
            sfx_CMPLONG_JGE:
00BBE:      	AR=		CX
00BBF:      	AX=		AX - AR
00BC0:      	AR=		BX
00BC1:      	DX=		DX - AR + C - 1
00BC2:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
            
00BC3:      	set		Z		; true
00BC4:      	rets
            @sfx_cl_jge_f:
00BC5:      	clr		Z		; false
00BC6:      	rets
            
            ; ~~-----------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JAE:
00BC7:      	AR=		CX
00BC8:      	AX=		AX - AR
00BC9:      	AR=		BX
00BCA:      	DX=		DX - AR + C - 1
00BCB:      	AR=		0
00BCC:      	AR=		AR - 0 + C - 1
00BCD:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
00BCE:      	set		Z		; true
00BCF:      	rets
            
            ; ---------
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JAE:
            sfx_CMP_CX_AX_JAE:
00BD0:      	DX=		0
00BD1:      	BX=		0
            sfx_CMPLONG_BCDA_JGE:
00BD2:      	AR=		AX
00BD3:      	CX=		CX - AR
00BD4:      	AR=		DX
00BD5:      	BX=		BX - AR + C - 1
00BD6:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
            
00BD7:      	set		Z		; true
00BD8:      	rets
            @sfx_clbcda_jge_f:
00BD9:      	clr		Z		; false
00BDA:      	rets
            
            ; ---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JAE:
00BDB:      	AR=		AX
00BDC:      	CX=		CX - AR
00BDD:      	AR=		DX
00BDE:      	BX=		BX - AR + C - 1
00BDF:      	AR=		0
00BE0:      	AR=		AR - 0 + C - 1
00BE1:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
00BE2:      	set		Z		; true
00BE3:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JGE:
00BE4:      	AR=		CX
00BE5:      	SF=		AX - AR
00BE6:      	if AN jmp	@sfx_cmp_ac_jge_f
00BE7:      	set		Z
00BE8:      	rets
            @sfx_cmp_ac_jge_f:
00BE9:      	clr		Z
00BEA:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JGE:
00BEB:      	AR=		AX
00BEC:      	SF=		CX - AR
00BED:      	if AN jmp	@sfx_cmp_ca_jge_f
00BEE:      	set		Z
00BEF:      	rets
            @sfx_cmp_ca_jge_f:
00BF0:      	clr		Z
00BF1:      	rets
            
            
            ; JL group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; B - below (unsigned)
            ; L - less (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JB:
            sfx_CMP_AX_CX_JB:
00BF2:      	DX=		0
00BF3:      	BX=		0
            sfx_CMPLONG_JL:
00BF4:      	AR=		CX
00BF5:      	AX=		AX - AR
00BF6:      	AR=		BX
00BF7:      	AR=		DX - AR + C - 1
00BF8:      	if AN jmp	@sfx_cl_jl_chk
            
            @sfx_cl_jl_f:
00BF9:      	clr		Z		; false
00BFA:      	rets
            
            @sfx_cl_jl_chk:
00BFB:      	AR=		AR | AX		; exclude EQU condition
00BFC:      	if ZR jmp	@sfx_cl_jl_f
00BFD:      	set		Z
00BFE:      	rets
            
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JB:
00BFF:      	AR=		CX
00C00:      	AX=		AX - AR
00C01:      	AR=		BX
00C02:      	DX=		DX - AR + C - 1
00C03:      	AR=		0
00C04:      	AR=		AR - 0 + C - 1
00C05:      	if AN jmp	@sfx_cl_jb_chk
            
            @sfx_cl_jb_f:
00C06:      	clr		Z		; false
00C07:      	rets
            
            @sfx_cl_jb_chk:
00C08:      	AR=		AR | DX
00C09:      	AR=		AR | AX		; exclude EQU condition
00C0A:      	if ZR jmp	@sfx_cl_jb_f
00C0B:      	set		Z
00C0C:      	rets
            
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JB:
            sfx_CMP_CX_AX_JB:
00C0D:      	DX=		0
00C0E:      	BX=		0
            sfx_CMPLONG_BCDA_JL:
00C0F:      	AR=		AX
00C10:      	CX=		CX - AR
00C11:      	AR=		DX
00C12:      	AR=		BX - AR + C - 1
00C13:      	if AN jmp	@sfx_clbcda_jl_chk
            
            @sfx_clbcda_jl_f:
00C14:      	clr		Z		; false
00C15:      	rets
            
            @sfx_clbcda_jl_chk:
00C16:      	AR=		AR | CX		; exclude EQU condition
00C17:      	if ZR jmp	@sfx_clbcda_jl_f
00C18:      	set		Z		; true
00C19:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JB:
00C1A:      	AR=		AX
00C1B:      	CX=		CX - AR
00C1C:      	AR=		DX
00C1D:      	BX=		BX - AR + C - 1
00C1E:      	AR=		0
00C1F:      	AR=		AR - 0 + C - 1
00C20:      	if AN jmp	@sfx_clbcda_jb_chk
            
            @sfx_clbcda_jb_f:
00C21:      	clr		Z		; false
00C22:      	rets
            
            @sfx_clbcda_jb_chk:
00C23:      	AR=		AR | CX
00C24:      	AR=		AR | BX
00C25:      	if ZR jmp	@sfx_clbcda_jb_f
00C26:      	set		Z		; true
00C27:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JL:
00C28:      	AR=		CX
00C29:      	SF=		AX - AR
00C2A:      	if GE jmp	@sfx_cmp_ac_jl_f
00C2B:      	set		Z
00C2C:      	rets
            @sfx_cmp_ac_jl_f:
00C2D:      	clr		Z
00C2E:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JL:
00C2F:      	AR=		AX
00C30:      	SF=		CX - AR
00C31:      	if GE jmp	@sfx_cmp_ca_jl_f
00C32:      	set		Z
00C33:      	rets
            @sfx_cmp_ca_jl_f:
00C34:      	clr		Z
00C35:      	rets
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JBE:
            sfx_CMP_AX_CX_JBE:
00C36:      	DX=		0
00C37:      	BX=		0
            sfx_CMPLONG_JLE:
00C38:      	AR=		CX
00C39:      	AX=		AX - AR
00C3A:      	AR=		BX
00C3B:      	AR=		DX - AR + C - 1
00C3C:      	if AN jmp	@sfx_cl_jle_t
            
00C3D:      	AR=		AR | AX		; include EQU condition
00C3E:      	if ZR jmp	@sfx_cl_jle_t
            
00C3F:      	clr		Z		; false
00C40:      	rets
            @sfx_cl_jle_t:
00C41:      	set		Z		; true
00C42:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JBE:
00C43:      	AR=		CX
00C44:      	AX=		AX - AR
00C45:      	AR=		BX
00C46:      	DX=		DX - AR + C - 1
00C47:      	AR=		0
00C48:      	AR=		AR - 0 + C - 1
00C49:      	if AN jmp	@sfx_cl_jle_t
            
00C4A:      	AR=		AR | DX
00C4B:      	AR=		AR | AX
00C4C:      	if ZR jmp	@sfx_cl_jle_t
            
00C4D:      	clr		Z		; false
00C4E:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JBE:
            sfx_CMP_CX_AX_JBE:
00C4F:      	DX=		0
00C50:      	BX=		0
            sfx_CMPLONG_BCDA_JLE:
00C51:      	AR=		AX
00C52:      	CX=		CX - AR
00C53:      	AR=		DX
00C54:      	AR=		BX - AR + C - 1
00C55:      	if AN jmp	@sfx_clbcda_jle_t
            
00C56:      	AR=		AR | CX		; include EQU condition
00C57:      	if ZR jmp	@sfx_clbcda_jle_t
            
00C58:      	clr		Z		; false
00C59:      	rets
            @sfx_clbcda_jle_t:
00C5A:      	set		Z		; true
00C5B:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JBE:
00C5C:      	AR=		AX
00C5D:      	CX=		CX - AR
00C5E:      	AR=		DX
00C5F:      	BX=		BX - AR + C - 1
00C60:      	AR=		0
00C61:      	AR=		AR - 0 + C - 1
00C62:      	if AN jmp	@sfx_clbcda_jle_t
            
00C63:      	AR=		AR | BX
00C64:      	AR=		AR | CX
00C65:      	if ZR jmp	@sfx_clbcda_jle_t
            
00C66:      	clr		Z		; false
00C67:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JLE:
00C68:      	AR=		CX
00C69:      	SF=		AX - AR
00C6A:      	if LE jmp	@sfx_cmp_ac_jl_t
00C6B:      	clr		Z
00C6C:      	rets
            @sfx_cmp_ac_jl_t:
00C6D:      	set		Z
00C6E:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JLE:
00C6F:      	AR=		AX
00C70:      	SF=		CX - AR
00C71:      	if LE jmp	@sfx_cmp_ca_jl_t
00C72:      	clr		Z
00C73:      	rets
            @sfx_cmp_ca_jl_t:
00C74:      	set		Z
00C75:      	rets
            
            
            ; ~!~ bit-field support
            
            @sfx_ortable_0:
00C76:      	DW 0xFFFE
            @sfx_ortable_1:
00C77:      	DW 0xFFFC
            @sfx_ortable_2:
00C78:      	DW 0xFFF8
            @sfx_ortable_3:
00C79:      	DW 0xFFF0
            @sfx_ortable_4:
00C7A:      	DW 0xFFE0
            @sfx_ortable_5:
00C7B:      	DW 0xFFC0
            @sfx_ortable_6:
00C7C:      	DW 0xFF80
            @sfx_ortable_7:
00C7D:      	DW 0xFF00
            @sfx_ortable_8:
00C7E:      	DW 0xFE00
            @sfx_ortable_9:
00C7F:      	DW 0xFC00
            @sfx_ortable_10:
00C80:      	DW 0xF800
            @sfx_ortable_11:
00C81:      	DW 0xF000
            @sfx_ortable_12:
00C82:      	DW 0xE000
            @sfx_ortable_13:
00C83:      	DW 0xC000
            @sfx_ortable_14:
00C84:      	DW 0x8000
            
            ; ~!~
            
            @sfx_orhigh:
00C85:      	AR=		pm[P1]
00C86:      	DX=		DX | AR
00C87:      	rets
            
            @sfx_orhigh_dx:
00C88:      	DX=		-1
            @sfx_orlow:
00C89:      	AR=		pm[P1]
00C8A:      	AX=		AX | AR
            @sfx_sextw_rets:
00C8B:      	rets
            
            ; ~!~ signed short
            
            sfx_SignExtW0:
00C8C:      	P1=		#@sfx_ortable_0
00C8F:      	test		AX.b0
00C90:      	if ZR jmp	@sfx_sextw_rets
00C91:      	jmp		@sfx_orlow
            
            sfx_SignExtW1:
00C92:      	P1=		#@sfx_ortable_1
00C95:      	test		AX.b1
00C96:      	if ZR jmp	@sfx_sextw_rets
00C97:      	jmp		@sfx_orlow
            
            sfx_SignExtW2:
00C98:      	P1=		#@sfx_ortable_2
00C9B:      	test		AX.b2
00C9C:      	if ZR jmp	@sfx_sextw_rets
00C9D:      	jmp		@sfx_orlow
            
            sfx_SignExtW3:
00C9E:      	P1=		#@sfx_ortable_3
00CA1:      	test		AX.b3
00CA2:      	if ZR jmp	@sfx_sextw_rets
00CA3:      	jmp		@sfx_orlow
            
            sfx_SignExtW4:
00CA4:      	P1=		#@sfx_ortable_4
00CA7:      	test		AX.b4
00CA8:      	if ZR jmp	@sfx_sextw_rets
00CA9:      	jmp		@sfx_orlow
            
            sfx_SignExtW5:
00CAA:      	P1=		#@sfx_ortable_5
00CAD:      	test		AX.b5
00CAE:      	if ZR jmp	@sfx_sextw_rets
00CAF:      	jmp		@sfx_orlow
            
            sfx_SignExtW6:
00CB0:      	P1=		#@sfx_ortable_6
00CB3:      	test		AX.b6
00CB4:      	if ZR jmp	@sfx_sextw_rets
00CB5:      	jmp		@sfx_orlow
            
            sfx_SignExtW7:
00CB6:      	P1=		#@sfx_ortable_7
00CB9:      	test		AX.b7
00CBA:      	if ZR jmp	@sfx_sextw_rets
00CBB:      	jmp		@sfx_orlow
            
            sfx_SignExtW8:
00CBC:      	P1=		#@sfx_ortable_8
00CBF:      	test		AX.b8
00CC0:      	if ZR jmp	@sfx_sextw_rets
00CC1:      	jmp		@sfx_orlow
            
            sfx_SignExtW9:
00CC2:      	P1=		#@sfx_ortable_9
00CC5:      	test		AX.b9
00CC6:      	if ZR jmp	@sfx_sextw_rets
00CC7:      	jmp		@sfx_orlow
            
            sfx_SignExtW10:
00CC8:      	P1=		#@sfx_ortable_10
00CCB:      	test		AX.b10
00CCC:      	if ZR jmp	@sfx_sextw_rets
00CCD:      	jmp		@sfx_orlow
            
            sfx_SignExtW11:
00CCE:      	P1=		#@sfx_ortable_11
00CD1:      	test		AX.b11
00CD2:      	if ZR jmp	@sfx_sextw_rets
00CD3:      	jmp		@sfx_orlow
            
            sfx_SignExtW12:
00CD4:      	P1=		#@sfx_ortable_12
00CD7:      	test		AX.b12
00CD8:      	if ZR jmp	@sfx_sextw_rets
00CD9:      	jmp		@sfx_orlow
            
            sfx_SignExtW13:
00CDA:      	P1=		#@sfx_ortable_13
00CDD:      	test		AX.b13
00CDE:      	if ZR jmp	@sfx_sextw_rets
00CDF:      	jmp		@sfx_orlow
            
            sfx_SignExtW14:
00CE0:      	P1=		#@sfx_ortable_14
00CE3:      	test		AX.b14
00CE4:      	if ZR jmp	@sfx_sextw_rets
00CE5:      	jmp		@sfx_orlow
            
            ; ~!~ signed long
            
            sfx_SignExtL0:
00CE6:      	P1=		#@sfx_ortable_0
00CE9:      	test		AX.b0
00CEA:      	if ZR jmp	@sfx_sextw_rets
00CEB:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL1:
00CEC:      	P1=		#@sfx_ortable_1
00CEF:      	test		AX.b1
00CF0:      	if ZR jmp	@sfx_sextw_rets
00CF1:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL2:
00CF2:      	P1=		#@sfx_ortable_2
00CF5:      	test		AX.b2
00CF6:      	if ZR jmp	@sfx_sextw_rets
00CF7:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL3:
00CF8:      	P1=		#@sfx_ortable_3
00CFB:      	test		AX.b3
00CFC:      	if ZR jmp	@sfx_sextw_rets
00CFD:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL4:
00CFE:      	P1=		#@sfx_ortable_4
00D01:      	test		AX.b4
00D02:      	if ZR jmp	@sfx_sextw_rets
00D03:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL5:
00D04:      	P1=		#@sfx_ortable_5
00D07:      	test		AX.b5
00D08:      	if ZR jmp	@sfx_sextw_rets
00D09:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL6:
00D0A:      	P1=		#@sfx_ortable_6
00D0D:      	test		AX.b6
00D0E:      	if ZR jmp	@sfx_sextw_rets
00D0F:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL7:
00D10:      	P1=		#@sfx_ortable_7
00D13:      	test		AX.b7
00D14:      	if ZR jmp	@sfx_sextw_rets
00D15:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL8:
00D16:      	P1=		#@sfx_ortable_8
00D19:      	test		AX.b8
00D1A:      	if ZR jmp	@sfx_sextw_rets
00D1B:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL9:
00D1C:      	P1=		#@sfx_ortable_9
00D1F:      	test		AX.b9
00D20:      	if ZR jmp	@sfx_sextw_rets
00D21:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL10:
00D22:      	P1=		#@sfx_ortable_10
00D25:      	test		AX.b10
00D26:      	if ZR jmp	@sfx_sextw_rets
00D27:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL11:
00D28:      	P1=		#@sfx_ortable_11
00D2B:      	test		AX.b11
00D2C:      	if ZR jmp	@sfx_sextw_rets
00D2D:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL12:
00D2E:      	P1=		#@sfx_ortable_12
00D31:      	test		AX.b12
00D32:      	if ZR jmp	@sfx_sextw_rets
00D33:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL13:
00D34:      	P1=		#@sfx_ortable_13
00D37:      	test		AX.b13
00D38:      	if ZR jmp	@sfx_sextw_rets
00D39:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL14:
00D3A:      	P1=		#@sfx_ortable_14
00D3D:      	test		AX.b14
00D3E:      	if ZR jmp	@sfx_sextw_rets
00D3F:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL15:
00D40:      	test		AX.b15
00D41:      	if ZR jmp	@sfx_sextw_rets
00D42:      	DX=		-1
00D43:      	rets
            
            sfx_SignExtL16:
00D44:      	P1=		#@sfx_ortable_0
00D47:      	test		DX.b0
00D48:      	if ZR jmp	@sfx_sextw_rets
00D49:      	jmp		@sfx_orhigh
            
            sfx_SignExtL17:
00D4A:      	P1=		#@sfx_ortable_1
00D4D:      	test		DX.b1
00D4E:      	if ZR jmp	@sfx_sextw_rets
00D4F:      	jmp		@sfx_orhigh
            
            sfx_SignExtL18:
00D50:      	P1=		#@sfx_ortable_2
00D53:      	test		DX.b2
00D54:      	if ZR jmp	@sfx_sextw_rets
00D55:      	jmp		@sfx_orhigh
            
            sfx_SignExtL19:
00D56:      	P1=		#@sfx_ortable_3
00D59:      	test		DX.b3
00D5A:      	if ZR jmp	@sfx_sextw_rets
00D5B:      	jmp		@sfx_orhigh
            
            sfx_SignExtL20:
00D5C:      	P1=		#@sfx_ortable_4
00D5F:      	test		DX.b4
00D60:      	if ZR jmp	@sfx_sextw_rets
00D61:      	jmp		@sfx_orhigh
            
            sfx_SignExtL21:
00D62:      	P1=		#@sfx_ortable_5
00D65:      	test		DX.b5
00D66:      	if ZR jmp	@sfx_sextw_rets
00D67:      	jmp		@sfx_orhigh
            
            sfx_SignExtL22:
00D68:      	P1=		#@sfx_ortable_6
00D6B:      	test		DX.b6
00D6C:      	if ZR jmp	@sfx_sextw_rets
00D6D:      	jmp		@sfx_orhigh
            
            sfx_SignExtL23:
00D6E:      	P1=		#@sfx_ortable_7
00D71:      	test		DX.b7
00D72:      	if ZR jmp	@sfx_sextw_rets
00D73:      	jmp		@sfx_orhigh
            
            sfx_SignExtL24:
00D74:      	P1=		#@sfx_ortable_8
00D77:      	test		DX.b8
00D78:      	if ZR jmp	@sfx_sextw_rets
00D79:      	jmp		@sfx_orhigh
            
            sfx_SignExtL25:
00D7A:      	P1=		#@sfx_ortable_9
00D7D:      	test		DX.b9
00D7E:      	if ZR jmp	@sfx_sextw_rets
00D7F:      	jmp		@sfx_orhigh
            
            sfx_SignExtL26:
00D80:      	P1=		#@sfx_ortable_10
00D83:      	test		DX.b10
00D84:      	if ZR jmp	@sfx_sextw_rets
00D85:      	jmp		@sfx_orhigh
            
            sfx_SignExtL27:
00D86:      	P1=		#@sfx_ortable_11
00D89:      	test		DX.b11
00D8A:      	if ZR jmp	@sfx_sextw_rets
00D8B:      	jmp		@sfx_orhigh
            
            sfx_SignExtL28:
00D8C:      	P1=		#@sfx_ortable_12
00D8F:      	test		DX.b12
00D90:      	if ZR jmp	@sfx_sextw_rets
00D91:      	jmp		@sfx_orhigh
            
            sfx_SignExtL29:
00D92:      	P1=		#@sfx_ortable_13
00D95:      	test		DX.b13
00D96:      	if ZR jmp	@sfx_sextw_rets
00D97:      	jmp		@sfx_orhigh
            
            sfx_SignExtL30:
00D98:      	P1=		#@sfx_ortable_14
00D9B:      	test		DX.b14
00D9C:      	if ZR jmp	@sfx_sextw_rets
00D9D:      	jmp		@sfx_orhigh
            
            
            ; ~.~--------------------
            ; I1, AX
            
            sfx_REPMOV_SS:
            @sfx_repmov_ss_loop_1804:
00D9E:      	push		I1
00D9F:      	AR=		AX
00DA0:      	I1=		AR
00DA1:      	AR=		rm[I1]
00DA2:      	pop		I1
00DA3:      	rm[I1++]=	AR
00DA4:      	AX++
00DA5:      	loop		@sfx_repmov_ss_loop_1804
00DA6:      	rets
            
            ; ~~
            
            sfx_REPMOV_SR:
00DA7:      	AR=		AX
00DA8:      	P1=		AR
            @sfx_repmov_sr_loop_1804:
00DA9:      	rm[I1++]=	pm[P1++]
00DAA:      	loop		@sfx_repmov_sr_loop_1804
00DAB:      	rets
            
            
            ; ~~
            
            sfx_REPMOV_RS:
00DAC:      	AR=		AX
00DAD:      	I1=		AR
            @sfx_repmov_rs_loop_1804:
00DAE:      	AR=		rm[I1++]
00DAF:      	pm[P1++]=	AR
00DB0:      	loop		@sfx_repmov_rs_loop_1804
00DB1:      	rets
            
            ; ~~
            
            sfx_REPMOV_RR:
            @sfx_repmov_rr_loop_1804:
00DB2:      	push		P1
00DB3:      	AR=		AX
00DB4:      	P1=		AR
00DB5:      	AR=		pm[P1]
00DB6:      	pop		P1
00DB7:      	pm[P1++]=	AR
00DB8:      	AX++
00DB9:      	loop		@sfx_repmov_rr_loop_1804
00DBA:      	rets
            
            ; ~~
            
            ; sfx_CHECKZERO:
            	; AR=		AX
            	; rets
            
            ; ~~
            
            ; sfx_CHECKZEROLONG:
            	; AR=		AX
            	; AR=		AR | DX
            	; rets
            
            ; ~~
            
            
            #ifdef PRAM_BANK
            
            ;  ~~ simple link list for PRAM allocate
            
            ;  +---------+---------+
            ;  | field 0 | field 1 |
            ;  +---------+---------+
            ;  |   PROM  |  next   |
            ;  +---------+---------+
            
            sfx_DynFastCallInit:
            ; {
            	P1.hh=		PRAM_BANK
            	P1=		PRAM_OFFSET
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	rets
            ; }
            
            
            ; ~~ for C / ASM progam compatible used
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            ; bool sfx_DynFindPrg(PRGADR)
            ;
            ; in:
            ;    P1		- function start address
            ;
            ; out:
            ;     Z		- found, P0 = program entry address at PRAM
            ;     NZ	- not found, P0 = free space (list) start at PRAM
            ; ----------------------------------------------------------------
            
            sfx_DynFindPrg:
            ; {
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfp_loop_1320:
            	AR=		pm[P0++]	; program address
            	if ZR jmp	@sfxdfp_label_1321
            	SF=		AR - P1
            	if NE jmp	@sfxdfp_label_1323
            
            	P0++
            	set		Z
            	rets
            
            @sfxdfp_label_1323:
            	AR=		pm[P0]		; next
            	P0=		0xFC00
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfp_label_1655
            	P0=		AR
            	jmp		@sfxdfp_loop_1320
            
            @sfxdfp_label_1321:
            	P0--				; list
            	clr		Z
            	rets
            
            @sfxdfp_label_1655:
            ; ~~ list broken...
            	P0=		PRAM_OFFSET
            	clr		Z
            	rets
            ; }
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free link start
            ; AX = function end address
            
            
            sfx_DynBooking:
            ; {
            	; check if PRG to big to fit in PRAM
            
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	; ~~ can not cache PRG (total PRAM_SIZE) ??
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdb_label_1345
            
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdb_label_1349
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdb_label_1349:
            	; create link list
            
            	AR=		P1
            	pm[P0++]=	AR		; PRG
            	AR=		P0
            	AR=		AR - 3		; remove 1 list and 1 next
            	CX=		CX + AR
            	pm[P0++]=	CX		; next
            
            	push		P1
            	P1=		#@sfxdfc_label_1840
            	AR=		pm[P1]		; inst -> P1.hh = 0
            	pm[P0++]=	AR
            	AR=		CX
            	P1=		AR
            	P1.hh=		PRAM_BANK
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	pop		P1
            
            	set		Z
            	rets
            
            @sfxdb_label_1345:
            	P0.hh=		0
            	clr		Z
            	rets
            ; }
            
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free PRG entry
            ; AX = function end address
            
            sfx_DynCache:
            	push		P0
            	AR=		AX
            	AR=		AR - P1
            	CX=		AR
            	jmp		@sfxdynch_label_1650
            @sfxdynch_loop_1650:
            	AR=		pm[P1++]
            	pm[P0++]=	AR
            @sfxdynch_label_1650:
            	loop		@sfxdynch_loop_1650
            	pop		P0
            	P0--
            	rets
            
            ; --------------------------------------------------------
            
            
            ; ~~ for C
            
            ; P1 = function start address
            ; AX = function end address
            
            sfx_DynFastCall:
            ; {
            	; look up function entry by prom address (P1)
            
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfc_label_1759:
            
            	; 0      1      2
            	; +------+------+------+
            	; | ID   | Next | Real |
            	; +------+------+------+
            
            	AR=		pm[P0++]		; next
            	if ZR jmp	@sfxdfc_label_1758
            	SF=		AR - P1
            	if EQ jmp	@sfxdfc_label_1722
            	AR=		pm[P0]
            
            	#if _OPT_PRAMSize_ == 2048
            		P0=		0xFC00
            	#else
            		P0=		0xF800
            	#endif
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfc_label_2035
            	P0=		AR
            	jmp		@sfxdfc_label_1759
            
            @sfxdfc_label_2035:
            	P0=		PRAM_OFFSET + 1
            
            ; -----
            
            @sfxdfc_label_1758:
            
            	; look for remain free space
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	P0--
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdfc_label_1840
            
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdfc_label_1817
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdfc_label_1817:
            
            	; copy program to pram
            
            	; ~~ PROM field
            		AR=		P1
            		pm[P0++]=	AR
            	; ~~ next field
            		AR=		P0
            		AR=		AR - 3		; remove 1 list and 1 next
            		CX=		CX + AR
            		pm[P0++]=	CX		; next
            
            	; ~~ booking
            		push		P1
            		P1=		#@sfxdfc_label_1840
            		AR=		pm[P1]		; inst -> P1.hh = 0
            		pm[P0++]=	AR
            		AR=		CX
            		P1=		AR
            		P1.hh=		PRAM_BANK
            		AR=		0
            		pm[P1++]=	AR
            		pm[P1]=		AR
            		P1.hh=		0
            		pop		P1
            
            	; copy instruction  "P0.hh = 0"
            		push		P0		; save exec address
            	@sfxdfc_loop_1829:
            		AR=		pm[P1++]
            		pm[P0++]=	AR
            		AR=		P0
            		SF=		AR - CX
            		if AN jmp	@sfxdfc_loop_1829
            		pop		P0
            		P0--
            		fjmp		pm[P0]
            
            @sfxdfc_label_1722:
            	P0++			; program entry
            	fjmp		pm[P0]
            
            @sfxdfc_label_1840:
            	P0.hh=		0
            
            @sfxdfc_label_1733:
            	; free space too small, direct run
            	fjmp		pm[P1]
            ; }
            
            
            
            
            #endif
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> End=========================
            
            
            
            // .code segment
            
            WAKEUP_PROC:
00DBB:      	PCH=	SYS_PROG_ENTRY
00DBC:      	ljmp	SYS_PROG_ENTRY
            
            IntVectTable:
00DBD:      	DW #_Touch_entry886E03ED
00DBE:      	DW #EMPTY_INTENTRY
00DBF:      	DW #EMPTY_INTENTRY
00DC0:      	DW #EMPTY_INTENTRY
00DC1:      	DW #EMPTY_INTENTRY
00DC2:      	DW #_PWM_Entry4EB0B003
            
            // .code ends
            ;;FDSP-IDE V2.64
            _SYSTEM_MAIN_PROGRAM_END_ADDRESS: 
