            ;=========================Include <OPTION.INC> Start=========================
            //--------------------------------------------------------------------------------------------------
            // TRITAN FDSP-IDE Option define file.
            // WARNING! All changes made in this file will be lost when recompiling.
            //--------------------------------------------------------------------------------------------------
            // Part number    : TRSF16127A
            // Option version : 2.3
            // Base Information--------------------------------------------------------------------------------
            #define       _OPT_TRSF16127A_                
            #define       _OPT_PROMSize_                0x20000   //PROM Size
            #define       _OPT_SRAMSize_                3072      //SRAM Size
            // I/O Configuration--------------------------------------------------------------------------------
            #define       _OPT_EXTReset_EN_             0         //EXT Reset Enable,0:Disable,1:Enable
            #define       _OPT_EXTINT1_EN_              0         //EXTINT1_EN,0:Disable,1:Enable
            #define       _OPT_EXTINT0_EN_              0         //EXTINT0_EN,0:Disable,1:Enable
            #define       _OPT_SpreadSpectrum_          0         //Spread Spectrum Enable,0:Disable,1:Enable
            #define       _OPT_EXTResetPin_             0         //EXT Reset Pin Select,0:PB3,1:PC3
            #define       _OPT_EXTINT1_INV_             0         //EXTINT1_INV,0:Disable,1:Enable
            #define       _OPT_EXTINT0_INV_             0         //EXTINT0_INV,0:Disable,1:Enable
            // Memory Configuration-----------------------------------------------------------------------------
            #define       _OPT_PRAMBank_                0         //PRAM Bank
            #define       _OPT_PRAMSize_                0         //PRAM Size(Words)
            #define       _OPT_WriteSegmentProtection_  0x0FFFF   //Write Segment Protection(0000H~ )
            // System Control Setup-----------------------------------------------------------------------------
            #define       _OPT_Bank0Speed_              11        //Bank0 Speed(MHz)
            #define       _OPT_RTCINT_                  1         //RTC interrupt,0:Disable,1:Enable
            #define       _OPT_RTCinHalt_               0         //RTC LP32K in Halt Mode,0:Disable,1:Enable
            #define       _OPT_LVR_                     2200      //LVR(mv)
            #define       _OPT_WatchDog_                256       //Watch dog(ms)
            #define       _OPT_ICEEnable_               1         //ICE Disable/Enable,0:Disable,1:Enable
            // Audio Configuration------------------------------------------------------------------------------
            #define       _OPT_AudioSamplingRate_       32        //Audio Sampling Rate(KHz)
            #define       _OPT_PWMBit_                  16        //PWM Bit
            #define       _OPT_DACFIFO_                 1         //DAC FIFO,0:Disable,1:Enable
            //--------------------------------------------------------------------------------------------------
            ;=========================Include <OPTION.INC> End=========================
            
            #define DSP_SRAM_SIZE		3072
            #define DSP_VECT_SUPPORT		6
            #define _PROJECT_CONFIG_FILE_		
            #define DTX_WORD_ADR		
            #define MIDIPCMDEC		
            #define _PWM_32K_		
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> Start=========================
            
            ; =====================
            ;      COMMON I/O
            ; =====================
            
            #ifdef _MFDSP_
            
            ; {
            	STATUS          EQU             00H             ;R/W, BIT0: Zero.
            							;R/W, BIT1: Carry.
            							;R/W, BIT2: Overflow.
            							;R/W, BIT3: Negative.
            							;R/W, BIT7: Global Interrupt Enable.
            							;R/W, BIT[12:8]: SD_EN, TRA_EN, ADH_EN, SPIS_EN, SPIM_EN.
            							;R/W, BIT13: Interrupt Vector Table Access Enable.
            							;R/W, BIT14: Filter Buffer Available.
            							;R/W, BIT15: Parser Buffer Available.
            
            	INTENA          EQU             01H             ;R/W, Int Enable.
            	INTREQ          EQU             02H             ;R/W, Int Request.
            	IntVect         EQU             03H             ;R/W, Interrupt Table
            	IOC_PA          EQU             04H             ;R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB          EQU             05H             ;R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PCI         EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PC          EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA           EQU             07H             ;R/W, General input/output port.
            	PortB           EQU             08H             ;R/W, General input/output port.
            	PortCI          EQU             09H             ;R/W, General input/output port.
            	PortC           EQU             09H             ;R/W, General input/output port.
            	INTMASK         EQU             0AH             ;R/W, Int Mask.
            	SPIS_CTL        EQU             0BH             ;R/W, SPI slaver control register.
            	SPIS_DAT        EQU             0CH             ;R/W, SPI slaver data    register.
            	SPI_CTL         EQU             0DH             ;R/W, SPI master control register.
            	SPI_DAT         EQU             0EH             ;R/W, SPI master data    register.
            	SD_CTL          EQU             0FH             ;R/W, SD card interface control register.
            	SD_DAT          EQU             10H             ;R/W, SD card interface data.
            	SD_RSP          EQU             11H             ;R/W, SD card interface response register.
            	UART_CTL        EQU             12H
            	UART_DAT        EQU             13H
            	DPPWM           EQU             14H
            	//------------------------------------
            	PUPD_PA         EQU             15H             ;R/W, PortA  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	DACL            EQU             16H
            	DACR            EQU             17H
            	USB_CTL         EQU             18H
            	USB_DAT         EQU             19H
            	PUPD_PB         EQU             1AH             ;R/W, PortB  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	PUPD_PC         EQU             1BH             ;R/W, PortC  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	MISC            EQU             1CH
            	ClrWDT          EQU             1DH             ;W, Clear Watch-dog reset.
            	Real_T          EQU             1DH             ;R, System Real-Time Counter, base on 31.25us
            	IOP_IX          EQU             1EH             ;W, Programming IO Port index .
            	IOP_DAT         EQU             1FH             ;W, Programming IO Port Data .
            
            	//------------------------------------
            	// Virtual         Program IO Port
            	IOP_Timer1      EQU             00H
            	IOP_Timer2      EQU             01H
            	IOP_RTC32K      EQU             02H
            	IOP_PreScale    EQU             03H
            	IOP_FGREEN32K   EQU             04H
            	IOP_ODEN_PA     EQU             05H
            	IOP_ODEN_PB     EQU             06H
            	IOP_ODEN_PC     EQU             07H
            
            	IOP_TOUCH_CFG   EQU             08H
            	IOP_TOUCH_DAT   EQU             09H
            
            	IOP_CLK_CFG     EQU             0AH
            	IOP_CLK_DAT1    EQU             0BH
            	IOP_CLK_DAT2    EQU             0CH
            	IOP_CUR_PA      EQU             0DH
            	IOP_CUR_PB      EQU             0EH
            	IOP_CUR_PC      EQU             0FH
            
            	//------------------------------------
            	// IO[0x40-0x7F]
            	ADH_CFG0        EQU             40H
            	ADH_CFG1        EQU             41H
            	ADH_CFG2        EQU             42H
            	ADH_CFG3        EQU             43H
            	ADH_DO          EQU             44H
            
            	ADL_CFG         EQU             45H
            
            	TRA_CFG         EQU             46H
            	TRA_DAT         EQU             47H
            
            	I2C_CTL         EQU             48H
            	I2C_DAT         EQU             49H
            	I2C_CMD         EQU             4AH
            	I2C_SR          EQU             4AH             ; same as I2C_CMD
            
            	I80_CTL         EQU             4BH
            	I80_INX         EQU             4CH
            	I80_DAT         EQU             4DH
            	I80_RADR        EQU             4EH
            	I80_DMANUM      EQU             4FH
            
            	SD_DMA_CTL      EQU             50H
            	SD_DMA_RADR     EQU             51H
            	SD_DMA_DMANUM   EQU             52H
            
            	SPI_DMA_CTL     EQU             53H
            	SPI_DMA_RADR    EQU             54H
            	SPI_DMA_DMANUM  EQU             55H
            
            	USB_DMA_CTL     EQU             56H
            	USB_DMA_RADR    EQU             57H
            	USB_DMA_DMANUM  EQU             58H
            
            	SSC             EQU             63H
            	MIC             EQU             64H
            	GREEN           EQU             65H
            	SLEEP           EQU             66H
            	SPEED           EQU             67H
            	PR              EQU             68H
            
            	//------------------------------------
            	IOP_WAKEN_PA    EQU             10H
            	IOP_WAKEN_PB    EQU             11H
            	IOP_WAKEN_PC    EQU             12H
            ; }
            
            #endif
            
            
            
            
            #ifdef _MSPEECHDSP_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            
            #ifdef _MSPEECHDSP2_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            
            
            ;-----------------------------------------------------------
            
            #ifdef NO_OPTIMAL_RM
            
            
            #else
            
            #define Optimal_RM	; Optimal RAM function Enable
            
            #endif
            
            
            VarRM[0:127] = {
            BP_SAVE,
            
            }
            
            VarRM[128:511] = {
            
            }
            
            VarRM[512:4095] = {
            
            }
            
            ShareVar = {
            
            }
            
            ;--------------------------------------------------------------------
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> Start=========================
            
            	org	0000h
            RSTB_ENTRY:
00000:      	PCH=		SYS_PROG_ENTRY
00001:      	ljmp		SYS_PROG_ENTRY
            
            
            	org	0004h
            WAKEUP_ENTRY:
00004:      	PCH=		WAKEUP_PROC
00005:      	ljmp		WAKEUP_PROC
            
            
            	org	0100h
            
            
            
            SYS_PROG_ENTRY:
            	; ~~ DSP initial
            
00100:      	dsi
00101:      	nop
00102:      	AR=		@STACKBOTTOM
00104:      	BP=		AR
00105:      	AR=		DSP_SRAM_SIZE
00107:      	AR--
00108:      	CX=		AR
00109:      	I1=		AR
0010A:      	AR=		0
            @clearram_loop_1705:
0010B:      	rm[I1--]=	AR
0010C:      	loop		@clearram_loop_1705
            
0010D:      	io[ClrWDT]=	AR
            
0010E:      	set		io[STATUS].b13
0010F:      	CX=		DSP_VECT_SUPPORT
00110:      	P1=		#IntVectTable
00113:      	jmp		@setintvect_label_1548
            @setintvect_loop_1548:
00114:      	AR=		pm[P1++]
00115:      	io[IntVect]=	AR
            @setintvect_label_1548:
00116:      	loop		@setintvect_loop_1548
            
00117:      	clr		io[STATUS].b13
            
            	; ~~ C code
            
            #ifdef PRAM_BANK
            	PCH=		sfx_DynFastCallInit
            	lcall		sfx_DynFastCallInit
            #endif
            
00118:      	PCH=		ginit_code
00119:      	lcall		ginit_code
            
0011A:      	PCH=		_main
0011B:      	lcall		_main
0011C:      	jmp		SYS_PROG_ENTRY
            
            
            /* ================================================================= */
            // ------------- Interrupt Service Routine--------------------------
            /* ================================================================= */
            
            EMPTY_INTENTRY:
0011D:      	reti
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> End=========================
            
            ;=========================Include <DEPS\F_467EBAA5.S.CODE.ASM> Start=========================
            ; F.C Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _main();
            ; //rjmp void _KeyPlaySongC44FFB6D();
            ; //rjmp void _KeyPlayStop0C3B8DB1();
            ; //rjmp void _KeyPlayNextAFBA8CED();
            ; //rjmp void _KeyPlayPrev8E98A35A();
            ; //rjmp void _KeyModEEAB4D5A();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _main()				
            _main:
            ; //{
            ; //_AB97CD6AD_0:;					
            _AB97CD6AD_0:
            ; //	
            ; //_AB97CD6AD_1:;					
            _AB97CD6AD_1:
            ; //_AB97CD6AD_2:;					
            _AB97CD6AD_2:
            ; //	_InitialDA4A7CC4();			
0011E:      	pch	= _InitialDA4A7CC4
0011F:      	lcall	_InitialDA4A7CC4
            ; //_AB97CD6AD_3:;					
            _AB97CD6AD_3:
            ; //_AB97CD6AD_4:;					
            _AB97CD6AD_4:
            ; //	_InitKey3C587B6D();			
00120:      	pch	= _InitKey3C587B6D
00121:      	lcall	_InitKey3C587B6D
            ; //_AB97CD6AD_5:;					
            _AB97CD6AD_5:
            ; //	asm set io[0x06].b0;			
00122:      	set io[0x06].b0//
            ; //_AB97CD6AD_6:;					
            _AB97CD6AD_6:
            ; //	asm set io[0x06].b1;			
00123:      	set io[0x06].b1//
            ; //_AB97CD6AD_7:;					
            _AB97CD6AD_7:
            ; //	asm clr io[0x09].b0;			
00124:      	clr io[0x09].b0//
            ; //_AB97CD6AD_8:;					
            _AB97CD6AD_8:
            ; //	asm clr io[0x09].b1;			
00125:      	clr io[0x09].b1//
            ; //_AB97CD6AD_9:;					
            _AB97CD6AD_9:
            ; //_AB97CD6AD_10:;					
            _AB97CD6AD_10:
            ; //	dtxInitialize();			
00126:      	pch	= dtxInitialize
00127:      	lcall	dtxInitialize
            ; //LC9A47239_4:;					
            LC9A47239_4:
            ; //_AB97CD6AD_11:;					
            _AB97CD6AD_11:
            ; //_AB97CD6AD_12:;					
            _AB97CD6AD_12:
            ; //	asm AX = #melody+0;			
00128:      	AX = #melody+0//
            ; //	asm DX = #melody.n2			
0012A:      	DX = #melody.n2
            ; //	asm set DX.b11				
0012B:      	set DX.b11
            ; //	_dtxFindToneEntry12F3B4ED(STACK[sSP + 0], STACK[sSP + 1]);
0012C:      	pch	= _dtxFindToneEntry12F3B4ED
0012D:      	lcall	_dtxFindToneEntry12F3B4ED
            ; //	sfx_CHECKZERO();			
0012E:      	AR	= AX
            ; //	if(__jz__)	goto LC9A47239_5;	
0012F:      	if ZR	jmp LC9A47239_5
            ; //	goto	LC9A47239_3;			
00130:      	jmp	LC9A47239_3
            ; //LC9A47239_5:;					
            LC9A47239_5:
            ; //	
            ; //LC9A47239_7:;					
            LC9A47239_7:
            ; //_AB97CD6AD_13:;					
            _AB97CD6AD_13:
            ; //	goto LC9A47239_7;			
00131:      	jmp	LC9A47239_7
            ; //LC9A47239_6:;					
            LC9A47239_6:
            ; //	goto LC9A47239_4;			
00132:      	jmp	LC9A47239_4
            ; //LC9A47239_3:;					
            LC9A47239_3:
            ; //_AB97CD6AD_14:;					
            _AB97CD6AD_14:
            ; //_AB97CD6AD_15:;					
            _AB97CD6AD_15:
            ; //	dtxInitParameters();			
00133:      	pch	= dtxInitParameters
00134:      	lcall	dtxInitParameters
            ; //_AB97CD6AD_16:;					
            _AB97CD6AD_16:
            ; //_AB97CD6AD_17:;					
            _AB97CD6AD_17:
            ; //	dtxReadTune();				
00135:      	pch	= dtxReadTune
00136:      	lcall	dtxReadTune
            ; //_AB97CD6AD_18:;					
            _AB97CD6AD_18:
            ; //	sAX	= 0x0000;			
00137:      	AX	= 0x00
            ; //	asm I1 = _songidx8C42F7DA+0;		
00138:      	I1 = _songidx8C42F7DA+0//
            ; //	*(__int16*)sSI	= sAX			
00139:      	rm[I1]	= AX
            ; //_AB97CD6AD_19:;					
            _AB97CD6AD_19:
            ; //	sAX	= 0x7FFF;			
0013A:      	AX	= 0x7FFF
            ; //	asm I1 = dtxfltg+0;			
0013C:      	I1 = dtxfltg+0//
            ; //	*(__int16*)sSI	= sAX			
0013D:      	rm[I1]	= AX
            ; //LC9A47239_9:;					
            LC9A47239_9:
            ; //_AB97CD6AD_20:;					
            _AB97CD6AD_20:
            ; //_AB97CD6AD_21:;					
            _AB97CD6AD_21:
            ; //	asm	io[ClrWDT] = AR			
0013E:      	io[ClrWDT] = AR
            ; //	
            ; //_AB97CD6AD_22:;					
            _AB97CD6AD_22:
            ; //_AB97CD6AD_23:;					
            _AB97CD6AD_23:
            ; //	_PollingKey3B90E3B1();			
0013F:      	pch	= _PollingKey3B90E3B1
00140:      	lcall	_PollingKey3B90E3B1
            ; //_AB97CD6AD_24:;					
            _AB97CD6AD_24:
            ; //_AB97CD6AD_25:;					
            _AB97CD6AD_25:
            ; //	_KeyShowLEDA84888EC();			
00141:      	pch	= _KeyShowLEDA84888EC
00142:      	lcall	_KeyShowLEDA84888EC
            ; //	goto LC9A47239_9;			
00143:      	jmp	LC9A47239_9
            ; //LC9A47239_8:;					
            LC9A47239_8:
            ; //LC9A47239_2:;					
            LC9A47239_2:
            ; //_AB97CD6AD_26:;					
            _AB97CD6AD_26:
            ; //	return;					
00144:      	rets
            ; //_main_end:;					
            _main_end:
            ; //_AB97CD6AD_27:;					
            _AB97CD6AD_27:
            ; //}
            ; //
            ; //rjmp void _KeyPlaySongC44FFB6D()		
            _KeyPlaySongC44FFB6D:
            ; //{
            ; //_AB97CD6AD_28:;					
            _AB97CD6AD_28:
            ; //	
            ; //_AB97CD6AD_29:;					
            _AB97CD6AD_29:
            ; //_AB97CD6AD_30:;					
            _AB97CD6AD_30:
            ; //	_dtxCheckSongEnd870A9712();		
00145:      	pch	= _dtxCheckSongEnd870A9712
00146:      	lcall	_dtxCheckSongEnd870A9712
            ; //	sfx_CHECKZERO();			
00147:      	AR	= AX
            ; //	if(__jnz__)	goto LC9A47239_12;	
00148:      	if NZ	jmp LC9A47239_12
            ; //	goto	LC9A47239_11;			
00149:      	jmp	LC9A47239_11
            ; //LC9A47239_12:;					
            LC9A47239_12:
            ; //	
            ; //_AB97CD6AD_31:;					
            _AB97CD6AD_31:
            ; //_AB97CD6AD_32:;					
            _AB97CD6AD_32:
            ; //	asm I1 = _songidx8C42F7DA+0;		
0014A:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
0014B:      	AX	= rm[I1]
            ; //	_dtxPlaySong5B7DBDA5(STACK[sSP + 0]);	
0014C:      	pch	= _dtxPlaySong5B7DBDA5
0014D:      	lcall	_dtxPlaySong5B7DBDA5
            ; //	goto LC9A47239_13;			
0014E:      	jmp	LC9A47239_13
            ; //LC9A47239_11:;					
            LC9A47239_11:
            ; //	
            ; //_AB97CD6AD_33:;					
            _AB97CD6AD_33:
            ; //_AB97CD6AD_34:;					
            _AB97CD6AD_34:
            ; //	dtxStopSong();				
0014F:      	pch	= dtxStopSong
00150:      	lcall	dtxStopSong
            ; //LC9A47239_13:;					
            LC9A47239_13:
            ; //_AB97CD6AD_35:;					
            _AB97CD6AD_35:
            ; //LC9A47239_10:;					
            LC9A47239_10:
            ; //_AB97CD6AD_36:;					
            _AB97CD6AD_36:
            ; //	return;					
00151:      	rets
            ; //_KeyPlaySongC44FFB6D_end:;			
            _KeyPlaySongC44FFB6D_end:
            ; //_AB97CD6AD_37:;					
            _AB97CD6AD_37:
            ; //}
            ; //
            ; //rjmp void _KeyPlayStop0C3B8DB1()		
            _KeyPlayStop0C3B8DB1:
            ; //{
            ; //_AB97CD6AD_38:;					
            _AB97CD6AD_38:
            ; //	
            ; //_AB97CD6AD_39:;					
            _AB97CD6AD_39:
            ; //_AB97CD6AD_40:;					
            _AB97CD6AD_40:
            ; //	dtxStopSong();				
00152:      	pch	= dtxStopSong
00153:      	lcall	dtxStopSong
            ; //LC9A47239_14:;					
            LC9A47239_14:
            ; //_AB97CD6AD_41:;					
            _AB97CD6AD_41:
            ; //	return;					
00154:      	rets
            ; //_KeyPlayStop0C3B8DB1_end:;			
            _KeyPlayStop0C3B8DB1_end:
            ; //_AB97CD6AD_42:;					
            _AB97CD6AD_42:
            ; //}
            ; //
            ; //rjmp void _KeyPlayNextAFBA8CED()		
            _KeyPlayNextAFBA8CED:
            ; //{
            ; //_AB97CD6AD_43:;					
            _AB97CD6AD_43:
            ; //	
            ; //_AB97CD6AD_44:;					
            _AB97CD6AD_44:
            ; //_AB97CD6AD_45:;					
            _AB97CD6AD_45:
            ; //	dtxStopSong();				
00155:      	pch	= dtxStopSong
00156:      	lcall	dtxStopSong
            ; //_AB97CD6AD_46:;					
            _AB97CD6AD_46:
            ; //	asm I1 = _songidx8C42F7DA+0;		
00157:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
00158:      	AX	= rm[I1]
            ; //	sSI	= (int)&_songidx8C42F7DA;	
00159:      	I1	= _songidx8C42F7DA
            ; //	sCX	= *(__int16*)sSI;		
0015A:      	CX	= rm[I1]
            ; //	sCX++;					
0015B:      	CX++
            ; //	*(__int16*)sSI	= sCX;			
0015C:      	rm[I1]	= CX
            ; //_AB97CD6AD_47:;					
            _AB97CD6AD_47:
            ; //_AB97CD6AD_48:;					
            _AB97CD6AD_48:
            ; //	_CheckSongLimit402181B4();		
0015D:      	pch	= _CheckSongLimit402181B4
0015E:      	lcall	_CheckSongLimit402181B4
            ; //_AB97CD6AD_49:;					
            _AB97CD6AD_49:
            ; //_AB97CD6AD_50:;					
            _AB97CD6AD_50:
            ; //	asm I1 = _songidx8C42F7DA+0;		
0015F:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
00160:      	AX	= rm[I1]
            ; //	_dtxPlaySong5B7DBDA5(STACK[sSP + 0]);	
00161:      	pch	= _dtxPlaySong5B7DBDA5
00162:      	lcall	_dtxPlaySong5B7DBDA5
            ; //LC9A47239_15:;					
            LC9A47239_15:
            ; //_AB97CD6AD_51:;					
            _AB97CD6AD_51:
            ; //	return;					
00163:      	rets
            ; //_KeyPlayNextAFBA8CED_end:;			
            _KeyPlayNextAFBA8CED_end:
            ; //_AB97CD6AD_52:;					
            _AB97CD6AD_52:
            ; //}
            ; //
            ; //rjmp void _KeyPlayPrev8E98A35A()		
            _KeyPlayPrev8E98A35A:
            ; //{
            ; //_AB97CD6AD_53:;					
            _AB97CD6AD_53:
            ; //	
            ; //_AB97CD6AD_54:;					
            _AB97CD6AD_54:
            ; //_AB97CD6AD_55:;					
            _AB97CD6AD_55:
            ; //	dtxStopSong();				
00164:      	pch	= dtxStopSong
00165:      	lcall	dtxStopSong
            ; //_AB97CD6AD_56:;					
            _AB97CD6AD_56:
            ; //	asm I1 = _songidx8C42F7DA+0;		
00166:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
00167:      	AX	= rm[I1]
            ; //	sSI	= (int)&_songidx8C42F7DA;	
00168:      	I1	= _songidx8C42F7DA
            ; //	sCX	= *(__int16*)sSI;		
00169:      	CX	= rm[I1]
            ; //	sCX--;					
0016A:      	CX--
            ; //	*(__int16*)sSI	= sCX;			
0016B:      	rm[I1]	= CX
            ; //_AB97CD6AD_57:;					
            _AB97CD6AD_57:
            ; //_AB97CD6AD_58:;					
            _AB97CD6AD_58:
            ; //	_CheckSongLimit402181B4();		
0016C:      	pch	= _CheckSongLimit402181B4
0016D:      	lcall	_CheckSongLimit402181B4
            ; //_AB97CD6AD_59:;					
            _AB97CD6AD_59:
            ; //_AB97CD6AD_60:;					
            _AB97CD6AD_60:
            ; //	asm I1 = _songidx8C42F7DA+0;		
0016E:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
0016F:      	AX	= rm[I1]
            ; //	_dtxPlaySong5B7DBDA5(STACK[sSP + 0]);	
00170:      	pch	= _dtxPlaySong5B7DBDA5
00171:      	lcall	_dtxPlaySong5B7DBDA5
            ; //LC9A47239_16:;					
            LC9A47239_16:
            ; //_AB97CD6AD_61:;					
            _AB97CD6AD_61:
            ; //	return;					
00172:      	rets
            ; //_KeyPlayPrev8E98A35A_end:;			
            _KeyPlayPrev8E98A35A_end:
            ; //_AB97CD6AD_62:;					
            _AB97CD6AD_62:
            ; //}
            ; //
            ; //rjmp void _KeyModEEAB4D5A()			
            _KeyModEEAB4D5A:
            ; //{
            ; //_AB97CD6AD_63:;					
            _AB97CD6AD_63:
            ; //	
            ; //_AB97CD6AD_64:;					
            _AB97CD6AD_64:
            ; //	asm AX = dtxtonech+7;			
00173:      	AX = dtxtonech+7//
            ; //	PUSH(sAX);				
00175:      	push	AX
            ; //	sAX	= 0x0001;			
00176:      	AX	= 0x01
            ; //	asm I1 = dtxtonech+7;			
00177:      	I1 = dtxtonech+7//
            ; //	sCX	= *(__int16*)sSI;		
00179:      	CX	= rm[I1]
            ; //	sAX	= sAX + sCX;			
0017A:      	AR	= CX
0017B:      	AX	+= AR
            ; //	asm AR = 0x0003;			
0017C:      	AR = 0x0003//
            ; //	asm AX = AX & AR;			
0017D:      	AX = AX & AR//
            ; //	sSI	= POP();			
0017E:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
0017F:      	rm[I1]	= AX
            ; //_AB97CD6AD_65:;					
            _AB97CD6AD_65:
            ; //	asm AX = dtxtonech+15;			
00180:      	AX = dtxtonech+15//
            ; //	PUSH(sAX);				
00182:      	push	AX
            ; //	sAX	= 0x0001;			
00183:      	AX	= 0x01
            ; //	asm I1 = dtxtonech+15;			
00184:      	I1 = dtxtonech+15//
            ; //	sCX	= *(__int16*)sSI;		
00186:      	CX	= rm[I1]
            ; //	sAX	= sAX + sCX;			
00187:      	AR	= CX
00188:      	AX	+= AR
            ; //	asm AR = 0x0003;			
00189:      	AR = 0x0003//
            ; //	asm AX = AX & AR;			
0018A:      	AX = AX & AR//
            ; //	sSI	= POP();			
0018B:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
0018C:      	rm[I1]	= AX
            ; //LC9A47239_17:;					
            LC9A47239_17:
            ; //_AB97CD6AD_66:;					
            _AB97CD6AD_66:
            ; //	return;					
0018D:      	rets
            ; //_KeyModEEAB4D5A_end:;				
            _KeyModEEAB4D5A_end:
            ; //_AB97CD6AD_67:;					
            _AB97CD6AD_67:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_F_467EBAA5_s(void)	
            ginit_code_F_467EBAA5_s:
            ; //{
            ; //	return;					
0018E:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //__int16 _keyfuncF06F3D55[15] = {		
            _keyfuncF06F3D55:
            ; //	(int)&_KeyPlayNextAFBA8CED, 0x0000, 0x0000, (int)&_KeyPlayPrev8E98A35A, 0x0000, 0x0000, (int)&_KeyModEEAB4D5A, 0x0000, 
0018F:      DW #_KeyPlayNextAFBA8CED,0x0000,0x0000,#_KeyPlayPrev8E98A35A,0x0000,0x0000,#_KeyModEEAB4D5A,0x0000,
            ; //	0x0000, (int)&_KeyPlayStop0C3B8DB1, 0x0000, 0x0000, (int)&_KeyPlaySongC44FFB6D, 0x0000, 0x0000
00197:      DW 0x0000,#_KeyPlayStop0C3B8DB1,0x0000,0x0000,#_KeyPlaySongC44FFB6D,0x0000,0x0000,
            ; //};
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\F_467EBAA5.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\GLOBAL_6037E6D5.S.CODE.ASM> Start=========================
            ; global.c Code Start!!;
            VarRM[0:4095]={
             _flags026116D5,_songidx8C42F7DA 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _InitialDA4A7CC4();
            ; //rjmp void _CheckSongLimit402181B4();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void L0E8FA404_19()			
            L0E8FA404_19:
            ; //{
            ; //_AB97CD6AD_68:;					
            _AB97CD6AD_68:
            ; //	
            ; //_AB97CD6AD_69:;					
            _AB97CD6AD_69:
            ; //	io[0x16]	= 0x0000;		
0019E:      	AR	= 0x00
0019F:      	io[0x16]	= AR
            ; //_AB97CD6AD_70:;					
            _AB97CD6AD_70:
            ; //	io[0x16]	= 0x0000;		
001A0:      	AR	= 0x00
001A1:      	io[0x16]	= AR
            ; //_AB97CD6AD_71:;					
            _AB97CD6AD_71:
            ; //	io[0x16]	= 0x0000;		
001A2:      	AR	= 0x00
001A3:      	io[0x16]	= AR
            ; //_AB97CD6AD_72:;					
            _AB97CD6AD_72:
            ; //	io[0x16]	= 0x0000;		
001A4:      	AR	= 0x00
001A5:      	io[0x16]	= AR
            ; //_AB97CD6AD_73:;					
            _AB97CD6AD_73:
            ; //	io[0x36]	= 0x0000;		
001A6:      	AR	= 0x00
001A7:      	io[0x36]	= AR
            ; //_AB97CD6AD_74:;					
            _AB97CD6AD_74:
            ; //	io[0x36]	= 0x0000;		
001A8:      	AR	= 0x00
001A9:      	io[0x36]	= AR
            ; //_AB97CD6AD_75:;					
            _AB97CD6AD_75:
            ; //	io[0x36]	= 0x0000;		
001AA:      	AR	= 0x00
001AB:      	io[0x36]	= AR
            ; //_AB97CD6AD_76:;					
            _AB97CD6AD_76:
            ; //	io[0x36]	= 0x0000;		
001AC:      	AR	= 0x00
001AD:      	io[0x36]	= AR
            ; //_AB97CD6AD_77:;					
            _AB97CD6AD_77:
            ; //	io[0x36]	= 0x0000;		
001AE:      	AR	= 0x00
001AF:      	io[0x36]	= AR
            ; //_AB97CD6AD_78:;					
            _AB97CD6AD_78:
            ; //	io[0x36]	= 0x0000;		
001B0:      	AR	= 0x00
001B1:      	io[0x36]	= AR
            ; //_AB97CD6AD_79:;					
            _AB97CD6AD_79:
            ; //	io[0x36]	= 0x0000;		
001B2:      	AR	= 0x00
001B3:      	io[0x36]	= AR
            ; //_AB97CD6AD_80:;					
            _AB97CD6AD_80:
            ; //	io[0x36]	= 0x0000;		
001B4:      	AR	= 0x00
001B5:      	io[0x36]	= AR
            ; //_AB97CD6AD_81:;					
            _AB97CD6AD_81:
            ; //	io[0x3C]	= 0x003F;		
001B6:      	AR	= 0x3F
001B7:      	io[0x3C]	= AR
            ; //_AB97CD6AD_82:;					
            _AB97CD6AD_82:
            ; //	sAX	= io[0x3C];			
001B8:      	AR	= io[0x3C]
001B9:      	AX	= AR
            ; //_AB97CD6AD_83:;					
            _AB97CD6AD_83:
            ; //	asm	set io[MISC].b9			
001BA:      	set io[MISC].b9
            ; //_AB97CD6AD_84:;					
            _AB97CD6AD_84:
            ; //	asm	set io[MISC].b8			
001BB:      	set io[MISC].b8
            ; //_AB97CD6AD_85:;					
            _AB97CD6AD_85:
            ; //	asm	set io[MISC].b4			
001BC:      	set io[MISC].b4
            ; //L0E8FA404_21:;					
            L0E8FA404_21:
            ; //_AB97CD6AD_86:;					
            _AB97CD6AD_86:
            ; //	return;					
001BD:      	rets
            ; //L0E8FA404_19_end:;				
            L0E8FA404_19_end:
            ; //_AB97CD6AD_87:;					
            _AB97CD6AD_87:
            ; //}
            ; //
            ; //rjmp void L0E8FA404_22()			
            L0E8FA404_22:
            ; //{
            ; //_AB97CD6AD_88:;					
            _AB97CD6AD_88:
            ; //	
            ; //_AB97CD6AD_89:;					
            _AB97CD6AD_89:
            ; //	io[0x04]	= 0x000F;		
001BE:      	AR	= 0x0F
001BF:      	io[0x04]	= AR
            ; //_AB97CD6AD_90:;					
            _AB97CD6AD_90:
            ; //	io[0x05]	= 0xFFFF;		
001C0:      	AR	= 0xFFFF
001C2:      	io[0x05]	= AR
            ; //_AB97CD6AD_91:;					
            _AB97CD6AD_91:
            ; //	io[0x07]	= 0x0000;		
001C3:      	AR	= 0x00
001C4:      	io[0x07]	= AR
            ; //_AB97CD6AD_92:;					
            _AB97CD6AD_92:
            ; //	io[0x08]	= 0xFFFF;		
001C5:      	AR	= 0xFFFF
001C7:      	io[0x08]	= AR
            ; //L0E8FA404_24:;					
            L0E8FA404_24:
            ; //_AB97CD6AD_93:;					
            _AB97CD6AD_93:
            ; //	return;					
001C8:      	rets
            ; //L0E8FA404_22_end:;				
            L0E8FA404_22_end:
            ; //_AB97CD6AD_94:;					
            _AB97CD6AD_94:
            ; //}
            ; //
            ; //rjmp void _InitialDA4A7CC4()			
            _InitialDA4A7CC4:
            ; //{
            ; //_AB97CD6AD_95:;					
            _AB97CD6AD_95:
            ; //	
            ; //_AB97CD6AD_96:;					
            _AB97CD6AD_96:
            ; //	sAX	= 0x0000;			
001C9:      	AX	= 0x00
            ; //	asm I1 = _songidx8C42F7DA+0;		
001CA:      	I1 = _songidx8C42F7DA+0//
            ; //	*(__int16*)sSI	= sAX			
001CB:      	rm[I1]	= AX
            ; //_AB97CD6AD_97:;					
            _AB97CD6AD_97:
            ; //_AB97CD6AD_98:;					
            _AB97CD6AD_98:
            ; //	NEARCALL(L0E8FA404_19);			
001CC:      	call	L0E8FA404_19
            ; //_AB97CD6AD_99:;					
            _AB97CD6AD_99:
            ; //_AB97CD6AD_100:;				
            _AB97CD6AD_100:
            ; //	NEARCALL(L0E8FA404_22);			
001CD:      	call	L0E8FA404_22
            ; //_AB97CD6AD_101:;				
            _AB97CD6AD_101:
            ; //	sAX	= 0x0000;			
001CE:      	AX	= 0x00
            ; //	asm I1 = _flags026116D5+0;		
001CF:      	I1 = _flags026116D5+0//
            ; //	*(__int16*)sSI	= sAX			
001D0:      	rm[I1]	= AX
            ; //L0E8FA404_25:;					
            L0E8FA404_25:
            ; //_AB97CD6AD_102:;				
            _AB97CD6AD_102:
            ; //	return;					
001D1:      	rets
            ; //_InitialDA4A7CC4_end:;				
            _InitialDA4A7CC4_end:
            ; //_AB97CD6AD_103:;				
            _AB97CD6AD_103:
            ; //}
            ; //
            ; //rjmp void _CheckSongLimit402181B4()		
            _CheckSongLimit402181B4:
            ; //{
            ; //_AB97CD6AD_104:;				
            _AB97CD6AD_104:
            ; //	
            ; //_AB97CD6AD_105:;				
            _AB97CD6AD_105:
            ; //	asm I1 = _songidx8C42F7DA+0;		
001D2:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
001D3:      	AX	= rm[I1]
            ; //	sCX	= 0x0000;			
001D4:      	CX	= 0x00
            ; //	sfx_CMP_AX_CX_JL();			
001D5:      	pch	= sfx_CMP_AX_CX_JL
001D6:      	lcall	sfx_CMP_AX_CX_JL
            ; //	if(__je__)	goto L0E8FA404_28;	
001D7:      	if ZR	jmp L0E8FA404_28
            ; //	goto	L0E8FA404_27;			
001D8:      	jmp	L0E8FA404_27
            ; //L0E8FA404_28:;					
            L0E8FA404_28:
            ; //	
            ; //_AB97CD6AD_106:;				
            _AB97CD6AD_106:
            ; //	asm I1 = dtxsongcnt+0;			
001D9:      	I1 = dtxsongcnt+0//
            ; //	sAX	= *(__int16*)sSI;		
001DB:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
001DC:      	CX	= 0x01
            ; //	sAX	= sAX - sCX;			
001DD:      	AR	= CX
001DE:      	AX	-= AR
            ; //	asm I1 = _songidx8C42F7DA+0;		
001DF:      	I1 = _songidx8C42F7DA+0//
            ; //	*(__int16*)sSI	= sAX			
001E0:      	rm[I1]	= AX
            ; //	goto L0E8FA404_29;			
001E1:      	jmp	L0E8FA404_29
            ; //L0E8FA404_27:;					
            L0E8FA404_27:
            ; //	
            ; //_AB97CD6AD_107:;				
            _AB97CD6AD_107:
            ; //	asm I1 = _songidx8C42F7DA+0;		
001E2:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
001E3:      	AX	= rm[I1]
            ; //	asm I1 = dtxsongcnt+0;			
001E4:      	I1 = dtxsongcnt+0//
            ; //	asm CX = rm[I1];			
001E6:      	CX = rm[I1]//
            ; //	sfx_CMP_AX_CX_JGE();			
001E7:      	pch	= sfx_CMP_AX_CX_JGE
001E8:      	lcall	sfx_CMP_AX_CX_JGE
            ; //	if(__je__)	goto L0E8FA404_31;	
001E9:      	if ZR	jmp L0E8FA404_31
            ; //	goto	L0E8FA404_30;			
001EA:      	jmp	L0E8FA404_30
            ; //L0E8FA404_31:;					
            L0E8FA404_31:
            ; //	
            ; //_AB97CD6AD_108:;				
            _AB97CD6AD_108:
            ; //	sAX	= 0x0000;			
001EB:      	AX	= 0x00
            ; //	asm I1 = _songidx8C42F7DA+0;		
001EC:      	I1 = _songidx8C42F7DA+0//
            ; //	*(__int16*)sSI	= sAX			
001ED:      	rm[I1]	= AX
            ; //L0E8FA404_30:;					
            L0E8FA404_30:
            ; //_AB97CD6AD_109:;				
            _AB97CD6AD_109:
            ; //L0E8FA404_29:;					
            L0E8FA404_29:
            ; //_AB97CD6AD_110:;				
            _AB97CD6AD_110:
            ; //L0E8FA404_26:;					
            L0E8FA404_26:
            ; //_AB97CD6AD_111:;				
            _AB97CD6AD_111:
            ; //	return;					
001EE:      	rets
            ; //_CheckSongLimit402181B4_end:;			
            _CheckSongLimit402181B4_end:
            ; //_AB97CD6AD_112:;				
            _AB97CD6AD_112:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_global_6037E6D5_s(void)	
            ginit_code_global_6037E6D5_s:
            ; //{
            ; //	return;					
001EF:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\GLOBAL_6037E6D5.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\KEYPAD_0E0216C1.S.CODE.ASM> Start=========================
            ; keypad.c Code Start!!;
            VarRM[0:4095]={
             L5589D4CE_33,L5589D4CE_34,L5589D4CE_35 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _InitKey3C587B6D();
            ; //rjmp void _PollingKey3B90E3B1();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _InitKey3C587B6D()			
            _InitKey3C587B6D:
            ; //{
            ; //_AB97CD6AD_113:;				
            _AB97CD6AD_113:
            ; //	
            ; //_AB97CD6AD_114:;				
            _AB97CD6AD_114:
            ; //	asm clr io[0x04].b0;			
001F0:      	clr io[0x04].b0//
            ; //_AB97CD6AD_115:;				
            _AB97CD6AD_115:
            ; //	asm clr io[0x04].b1;			
001F1:      	clr io[0x04].b1//
            ; //_AB97CD6AD_116:;				
            _AB97CD6AD_116:
            ; //	asm clr io[0x04].b2;			
001F2:      	clr io[0x04].b2//
            ; //_AB97CD6AD_117:;				
            _AB97CD6AD_117:
            ; //	asm clr io[0x04].b3;			
001F3:      	clr io[0x04].b3//
            ; //_AB97CD6AD_118:;				
            _AB97CD6AD_118:
            ; //	io[0x1E]	= 0x0005;		
001F4:      	AR	= 0x05
001F5:      	io[0x1E]	= AR
            ; //_AB97CD6AD_119:;				
            _AB97CD6AD_119:
            ; //	sAX	= 0x000F;			
001F6:      	AX	= 0x0F
            ; //	sAX	= sAX | io[0x1F];		
001F7:      	AR	= io[0x1F]
001F8:      	AX	|= AR
            ; //	io[0x1F]	= sAX;			
001F9:      	AR	= AX
001FA:      	io[0x1F]	= AR
            ; //_AB97CD6AD_120:;				
            _AB97CD6AD_120:
            ; //	sAX	= 0x0000;			
001FB:      	AX	= 0x00
            ; //	sSI	= (int)&L5589D4CE_33;		
001FC:      	I1	= L5589D4CE_33
            ; //	*(__int16*)sSI	= sAX			
001FD:      	rm[I1]	= AX
            ; //_AB97CD6AD_121:;				
            _AB97CD6AD_121:
            ; //	sAX	= 0x0000;			
001FE:      	AX	= 0x00
            ; //	sSI	= (int)&L5589D4CE_34;		
001FF:      	I1	= L5589D4CE_34
            ; //	*(__int16*)sSI	= sAX			
00200:      	rm[I1]	= AX
            ; //_AB97CD6AD_122:;				
            _AB97CD6AD_122:
            ; //	sAX	= 0x0200;			
00201:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_35;		
00203:      	I1	= L5589D4CE_35
            ; //	*(__int16*)sSI	= sAX			
00204:      	rm[I1]	= AX
            ; //L5589D4CE_36:;					
            L5589D4CE_36:
            ; //_AB97CD6AD_123:;				
            _AB97CD6AD_123:
            ; //	return;					
00205:      	rets
            ; //_InitKey3C587B6D_end:;				
            _InitKey3C587B6D_end:
            ; //_AB97CD6AD_124:;				
            _AB97CD6AD_124:
            ; //}
            ; //
            ; //rjmp void L5589D4CE_37()			
            L5589D4CE_37:
            ; //{
            ; //	__int16 _btn_1_2;
            ; //						
00206:      	AR	= rm[BP_SAVE]
00207:      	push	AR
00208:      	AR	= BP
00209:      	rm[BP_SAVE]	= AR
0020A:      	AR	 = -1
0020B:      	BP	+= AR
            ; //_AB97CD6AD_125:;				
            _AB97CD6AD_125:
            ; //_AB97CD6AD_126:;				
            _AB97CD6AD_126:
            ; //	sAX	= 0x000F;			
0020C:      	AX	= 0x0F
            ; //	sAX	= sAX & io[0x07];		
0020D:      	AR	= io[0x07]
0020E:      	AX	&= AR
            ; //	sSI	= (int)&_btn_1_2;		
0020F:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
00210:      	rm[I1]	= AX
            ; //_AB97CD6AD_127:;				
            _AB97CD6AD_127:
            ; //	sSI	= (int)&_btn_1_2;		
00211:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00212:      	AX	= rm[I1]
            ; //	goto L5589D4CE_39;			
00213:      	jmp	L5589D4CE_39
            ; //L5589D4CE_39:;					
            L5589D4CE_39:
            ; //_AB97CD6AD_128:;				
            _AB97CD6AD_128:
            ; //	return;					
00214:      	AR	= 1
00215:      	BP	+= AR
00216:      	pop	AR
00217:      	rm[BP_SAVE]	= AR
00218:      	rets
            ; //L5589D4CE_37_end:;				
            L5589D4CE_37_end:
            ; //_AB97CD6AD_129:;				
            _AB97CD6AD_129:
            ; //}
            ; //
            ; //rjmp void _PollingKey3B90E3B1()			
            _PollingKey3B90E3B1:
            ; //{
            ; //	__int16 _keynow_1_2;
            ; //	__int16 _i_1_4;
            ; //	__int16 _bits_1_6;
            ; //	__int16 _bitp_1_8;
            ; //	__int16 _pkey_1_10;
            ; //						
00219:      	AR	= rm[BP_SAVE]
0021A:      	push	AR
0021B:      	AR	= BP
0021C:      	rm[BP_SAVE]	= AR
0021D:      	AR	 = -5
0021E:      	BP	+= AR
            ; //_AB97CD6AD_130:;				
            _AB97CD6AD_130:
            ; //_AB97CD6AD_131:;				
            _AB97CD6AD_131:
            ; //_AB97CD6AD_132:;				
            _AB97CD6AD_132:
            ; //	NEARCALL(L5589D4CE_37);			
0021F:      	call	L5589D4CE_37
            ; //	sSI	= (int)&_keynow_1_2;		
00220:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
00221:      	rm[I1]	= AX
            ; //_AB97CD6AD_133:;				
            _AB97CD6AD_133:
            ; //	asm I1 = L5589D4CE_33+0;		
00222:      	I1 = L5589D4CE_33+0//
            ; //	sAX	= *(__int16*)sSI;		
00223:      	AX	= rm[I1]
            ; //	sSI	= (int)&_keynow_1_2;		
00224:      	I1	= rm[BP_SAVE]
            ; //	sCX	= *(__int16*)sSI;		
00225:      	CX	= rm[I1]
            ; //	sfx_CMP_AX_CX_JNE();			
00226:      	pch	= sfx_CMP_AX_CX_JNE
00227:      	lcall	sfx_CMP_AX_CX_JNE
            ; //	if(__je__)	goto L5589D4CE_42;	
00228:      	if ZR	jmp L5589D4CE_42
            ; //	goto	L5589D4CE_41;			
00229:      	jmp	L5589D4CE_41
            ; //L5589D4CE_42:;					
            L5589D4CE_42:
            ; //	
            ; //_AB97CD6AD_134:;				
            _AB97CD6AD_134:
            ; //	sSI	= (int)&_keynow_1_2;		
0022A:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0022B:      	AX	= rm[I1]
            ; //	sSI	= (int)&L5589D4CE_33;		
0022C:      	I1	= L5589D4CE_33
            ; //	*(__int16*)sSI	= sAX			
0022D:      	rm[I1]	= AX
            ; //_AB97CD6AD_135:;				
            _AB97CD6AD_135:
            ; //	sAX	= 0x0200;			
0022E:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_35;		
00230:      	I1	= L5589D4CE_35
            ; //	*(__int16*)sSI	= sAX			
00231:      	rm[I1]	= AX
            ; //_AB97CD6AD_136:;				
            _AB97CD6AD_136:
            ; //	goto L5589D4CE_40;			
00232:      	jmp	L5589D4CE_40
            ; //L5589D4CE_41:;					
            L5589D4CE_41:
            ; //_AB97CD6AD_137:;				
            _AB97CD6AD_137:
            ; //_AB97CD6AD_138:;				
            _AB97CD6AD_138:
            ; //	asm I1 = L5589D4CE_35+0;		
00233:      	I1 = L5589D4CE_35+0//
            ; //	sAX	= *(__int16*)sSI;		
00234:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
00235:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_44;	
00236:      	if NZ	jmp L5589D4CE_44
            ; //	goto	L5589D4CE_43;			
00237:      	jmp	L5589D4CE_43
            ; //L5589D4CE_44:;					
            L5589D4CE_44:
            ; //	
            ; //_AB97CD6AD_139:;				
            _AB97CD6AD_139:
            ; //	asm I1 = L5589D4CE_35+0;		
00238:      	I1 = L5589D4CE_35+0//
            ; //	sAX	= *(__int16*)sSI;		
00239:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
0023A:      	CX	= 0x01
            ; //	sAX	= sAX - sCX;			
0023B:      	AR	= CX
0023C:      	AX	-= AR
            ; //	sSI	= (int)&L5589D4CE_35;		
0023D:      	I1	= L5589D4CE_35
            ; //	*(__int16*)sSI	= sAX			
0023E:      	rm[I1]	= AX
            ; //_AB97CD6AD_140:;				
            _AB97CD6AD_140:
            ; //	goto L5589D4CE_40;			
0023F:      	jmp	L5589D4CE_40
            ; //L5589D4CE_43:;					
            L5589D4CE_43:
            ; //_AB97CD6AD_141:;				
            _AB97CD6AD_141:
            ; //_AB97CD6AD_142:;				
            _AB97CD6AD_142:
            ; //	asm AX = #_keyfuncF06F3D55+0;		
00240:      	AX = #_keyfuncF06F3D55+0//
            ; //	sSI	= (int)&_pkey_1_10;		
00242:      	AR	= -4
00243:      	I1	= rm[BP_SAVE]
00244:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00245:      	rm[I1]	= AX
            ; //_AB97CD6AD_143:;				
            _AB97CD6AD_143:
            ; //	sAX	= 0x0200;			
00246:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_35;		
00248:      	I1	= L5589D4CE_35
            ; //	*(__int16*)sSI	= sAX			
00249:      	rm[I1]	= AX
            ; //_AB97CD6AD_144:;				
            _AB97CD6AD_144:
            ; //	asm I1 = L5589D4CE_34+0;		
0024A:      	I1 = L5589D4CE_34+0//
            ; //	sAX	= *(__int16*)sSI;		
0024B:      	AX	= rm[I1]
            ; //	asm I1 = L5589D4CE_33+0;		
0024C:      	I1 = L5589D4CE_33+0//
            ; //	asm AR = rm[I1];			
0024D:      	AR = rm[I1]//
            ; //	asm AX = AX ^ AR;			
0024E:      	AX = AX ^ AR//
            ; //	sSI	= (int)&_bits_1_6;		
0024F:      	AR	= -2
00250:      	I1	= rm[BP_SAVE]
00251:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00252:      	rm[I1]	= AX
            ; //_AB97CD6AD_145:;				
            _AB97CD6AD_145:
            ; //	asm I1 = L5589D4CE_34+0;		
00253:      	I1 = L5589D4CE_34+0//
            ; //	sAX	= *(__int16*)sSI;		
00254:      	AX	= rm[I1]
            ; //	sSI	= (int)&_bitp_1_8;		
00255:      	AR	= -3
00256:      	I1	= rm[BP_SAVE]
00257:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00258:      	rm[I1]	= AX
            ; //_AB97CD6AD_146:;				
            _AB97CD6AD_146:
            ; //	asm I1 = L5589D4CE_33+0;		
00259:      	I1 = L5589D4CE_33+0//
            ; //	sAX	= *(__int16*)sSI;		
0025A:      	AX	= rm[I1]
            ; //	sSI	= (int)&L5589D4CE_34;		
0025B:      	I1	= L5589D4CE_34
            ; //	*(__int16*)sSI	= sAX			
0025C:      	rm[I1]	= AX
            ; //_AB97CD6AD_147:;				
            _AB97CD6AD_147:
            ; //	_i_1_4+0	= 0x05;			
0025D:      	AR	= -1
0025E:      	I1	= rm[BP_SAVE]
0025F:      	I1	+= AR
00260:      	AR	= 0x05
00261:      	rm[I1]	= AR
            ; //L5589D4CE_46:;					
            L5589D4CE_46:
            ; //_AB97CD6AD_148:;				
            _AB97CD6AD_148:
            ; //	sSI	= (int)&_i_1_4;			
00262:      	AR	= -1
00263:      	I1	= rm[BP_SAVE]
00264:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00265:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_4;			
00266:      	AR	= -1
00267:      	I1	= rm[BP_SAVE]
00268:      	I1	+= AR
            ; //	asm AR = 0x0001;			
00269:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
0026A:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
0026B:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
0026C:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_47;	
0026D:      	if NZ	jmp L5589D4CE_47
            ; //	goto	L5589D4CE_45;			
0026E:      	jmp	L5589D4CE_45
            ; //L5589D4CE_47:;					
            L5589D4CE_47:
            ; //	
            ; //_AB97CD6AD_149:;				
            _AB97CD6AD_149:
            ; //	sAX	= 0;				
0026F:      	AX	= 0x00
            ; //	sSI	= (int)&_bits_1_6+0;		
00270:      	AR	= -2
00271:      	I1	= rm[BP_SAVE]
00272:      	I1	+= AR
            ; //	asm AR = rm[I1];			
00273:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
00274:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_49;		
00275:      	if ZR	jmp L5589D4CE_49
            ; //	sAX	= 1;				
00276:      	AX	= 0x01
            ; //L5589D4CE_49:;					
            L5589D4CE_49:
            ; //	sfx_CHECKZERO();			
00277:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_50;	
00278:      	if NZ	jmp L5589D4CE_50
            ; //	goto	L5589D4CE_48;			
00279:      	jmp	L5589D4CE_48
            ; //L5589D4CE_50:;					
            L5589D4CE_50:
            ; //	
            ; //_AB97CD6AD_150:;				
            _AB97CD6AD_150:
            ; //	sAX	= 0;				
0027A:      	AX	= 0x00
            ; //	sSI	= (int)&_bitp_1_8+0;		
0027B:      	AR	= -3
0027C:      	I1	= rm[BP_SAVE]
0027D:      	I1	+= AR
            ; //	asm AR = rm[I1];			
0027E:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
0027F:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_52;		
00280:      	if ZR	jmp L5589D4CE_52
            ; //	sAX	= 1;				
00281:      	AX	= 0x01
            ; //L5589D4CE_52:;					
            L5589D4CE_52:
            ; //	sfx_CHECKZERO();			
00282:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_53;	
00283:      	if NZ	jmp L5589D4CE_53
            ; //	goto	L5589D4CE_51;			
00284:      	jmp	L5589D4CE_51
            ; //L5589D4CE_53:;					
            L5589D4CE_53:
            ; //	
            ; //_AB97CD6AD_151:;				
            _AB97CD6AD_151:
            ; //	sSI	= (int)&_pkey_1_10;		
00285:      	AR	= -4
00286:      	I1	= rm[BP_SAVE]
00287:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00288:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
00289:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
0028A:      	AR	= CX
0028B:      	AX	+= AR
            ; //	sDI	= sAX;				
0028C:      	AR	= AX
0028D:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
0028E:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
0028F:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_55;	
00290:      	if NZ	jmp L5589D4CE_55
            ; //	goto	L5589D4CE_54;			
00291:      	jmp	L5589D4CE_54
            ; //L5589D4CE_55:;					
            L5589D4CE_55:
            ; //_AB97CD6AD_152:;				
            _AB97CD6AD_152:
            ; //	sSI	= (int)&_pkey_1_10;		
00292:      	AR	= -4
00293:      	I1	= rm[BP_SAVE]
00294:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00295:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
00296:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
00297:      	AR	= CX
00298:      	AX	+= AR
            ; //	sDI	= sAX;				
00299:      	AR	= AX
0029A:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
0029B:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
0029C:      	AR	= AX
0029D:      	P1	= AR
0029E:      	P1.hh	= 0
0029F:      	fcall	pm[P1]
            ; //L5589D4CE_54:;					
            L5589D4CE_54:
            ; //_AB97CD6AD_153:;				
            _AB97CD6AD_153:
            ; //	goto L5589D4CE_56;			
002A0:      	jmp	L5589D4CE_56
            ; //L5589D4CE_51:;					
            L5589D4CE_51:
            ; //	
            ; //_AB97CD6AD_154:;				
            _AB97CD6AD_154:
            ; //	sSI	= (int)&_pkey_1_10;		
002A1:      	AR	= -4
002A2:      	I1	= rm[BP_SAVE]
002A3:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
002A4:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
002A5:      	AR	= AX
002A6:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
002A7:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
002A8:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_58;	
002A9:      	if NZ	jmp L5589D4CE_58
            ; //	goto	L5589D4CE_57;			
002AA:      	jmp	L5589D4CE_57
            ; //L5589D4CE_58:;					
            L5589D4CE_58:
            ; //_AB97CD6AD_155:;				
            _AB97CD6AD_155:
            ; //	sSI	= (int)&_pkey_1_10;		
002AB:      	AR	= -4
002AC:      	I1	= rm[BP_SAVE]
002AD:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
002AE:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
002AF:      	AR	= AX
002B0:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
002B1:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
002B2:      	AR	= AX
002B3:      	P1	= AR
002B4:      	P1.hh	= 0
002B5:      	fcall	pm[P1]
            ; //L5589D4CE_57:;					
            L5589D4CE_57:
            ; //_AB97CD6AD_156:;				
            _AB97CD6AD_156:
            ; //L5589D4CE_56:;					
            L5589D4CE_56:
            ; //_AB97CD6AD_157:;				
            _AB97CD6AD_157:
            ; //	goto L5589D4CE_59;			
002B6:      	jmp	L5589D4CE_59
            ; //L5589D4CE_48:;					
            L5589D4CE_48:
            ; //	
            ; //_AB97CD6AD_158:;				
            _AB97CD6AD_158:
            ; //	sAX	= 0;				
002B7:      	AX	= 0x00
            ; //	sSI	= (int)&_bitp_1_8+0;		
002B8:      	AR	= -3
002B9:      	I1	= rm[BP_SAVE]
002BA:      	I1	+= AR
            ; //	asm AR = rm[I1];			
002BB:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
002BC:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_61;		
002BD:      	if ZR	jmp L5589D4CE_61
            ; //	sAX	= 1;				
002BE:      	AX	= 0x01
            ; //L5589D4CE_61:;					
            L5589D4CE_61:
            ; //	sfx_CHECKZERO();			
002BF:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_62;	
002C0:      	if NZ	jmp L5589D4CE_62
            ; //	goto	L5589D4CE_60;			
002C1:      	jmp	L5589D4CE_60
            ; //L5589D4CE_62:;					
            L5589D4CE_62:
            ; //	
            ; //_AB97CD6AD_159:;				
            _AB97CD6AD_159:
            ; //	sSI	= (int)&_pkey_1_10;		
002C2:      	AR	= -4
002C3:      	I1	= rm[BP_SAVE]
002C4:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
002C5:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
002C6:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
002C7:      	AR	= CX
002C8:      	AX	+= AR
            ; //	sDI	= sAX;				
002C9:      	AR	= AX
002CA:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
002CB:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
002CC:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_64;	
002CD:      	if NZ	jmp L5589D4CE_64
            ; //	goto	L5589D4CE_63;			
002CE:      	jmp	L5589D4CE_63
            ; //L5589D4CE_64:;					
            L5589D4CE_64:
            ; //_AB97CD6AD_160:;				
            _AB97CD6AD_160:
            ; //	sSI	= (int)&_pkey_1_10;		
002CF:      	AR	= -4
002D0:      	I1	= rm[BP_SAVE]
002D1:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
002D2:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
002D3:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
002D4:      	AR	= CX
002D5:      	AX	+= AR
            ; //	sDI	= sAX;				
002D6:      	AR	= AX
002D7:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
002D8:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
002D9:      	AR	= AX
002DA:      	P1	= AR
002DB:      	P1.hh	= 0
002DC:      	fcall	pm[P1]
            ; //L5589D4CE_63:;					
            L5589D4CE_63:
            ; //_AB97CD6AD_161:;				
            _AB97CD6AD_161:
            ; //L5589D4CE_60:;					
            L5589D4CE_60:
            ; //_AB97CD6AD_162:;				
            _AB97CD6AD_162:
            ; //L5589D4CE_59:;					
            L5589D4CE_59:
            ; //_AB97CD6AD_163:;				
            _AB97CD6AD_163:
            ; //_AB97CD6AD_164:;				
            _AB97CD6AD_164:
            ; //	sSI	= (int)&_bits_1_6;		
002DD:      	AR	= -2
002DE:      	I1	= rm[BP_SAVE]
002DF:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
002E0:      	AX	= rm[I1]
            ; //	asm sra AX, 1;				
002E1:      	sra AX, 1//
            ; //	sSI	= (int)&_bits_1_6;		
002E2:      	AR	= -2
002E3:      	I1	= rm[BP_SAVE]
002E4:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
002E5:      	rm[I1]	= AX
            ; //_AB97CD6AD_165:;				
            _AB97CD6AD_165:
            ; //	sSI	= (int)&_bitp_1_8;		
002E6:      	AR	= -3
002E7:      	I1	= rm[BP_SAVE]
002E8:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
002E9:      	AX	= rm[I1]
            ; //	asm sra AX, 1;				
002EA:      	sra AX, 1//
            ; //	sSI	= (int)&_bitp_1_8;		
002EB:      	AR	= -3
002EC:      	I1	= rm[BP_SAVE]
002ED:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
002EE:      	rm[I1]	= AX
            ; //_AB97CD6AD_166:;				
            _AB97CD6AD_166:
            ; //	sSI	= (int)&_pkey_1_10;		
002EF:      	AR	= -4
002F0:      	I1	= rm[BP_SAVE]
002F1:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
002F2:      	AX	= rm[I1]
            ; //	sSI	= (int)&_pkey_1_10;		
002F3:      	AR	= -4
002F4:      	I1	= rm[BP_SAVE]
002F5:      	I1	+= AR
            ; //	asm AR = 0x0003;			
002F6:      	AR = 0x0003//
            ; //	sCX	= *(__int16*)sSI;		
002F7:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
002F8:      	rm[I1] = CX + AR//
            ; //	goto L5589D4CE_46;			
002F9:      	jmp	L5589D4CE_46
            ; //L5589D4CE_45:;					
            L5589D4CE_45:
            ; //L5589D4CE_40:;					
            L5589D4CE_40:
            ; //_AB97CD6AD_167:;				
            _AB97CD6AD_167:
            ; //	return;					
002FA:      	AR	= 5
002FB:      	BP	+= AR
002FC:      	pop	AR
002FD:      	rm[BP_SAVE]	= AR
002FE:      	rets
            ; //_PollingKey3B90E3B1_end:;			
            _PollingKey3B90E3B1_end:
            ; //_AB97CD6AD_168:;				
            _AB97CD6AD_168:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_keypad_0E0216C1_s(void)	
            ginit_code_keypad_0E0216C1_s:
            ; //{
            ; //	return;					
002FF:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\KEYPAD_0E0216C1.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\LED_376AFC9D.S.CODE.ASM> Start=========================
            ; led.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _KeyShowLEDA84888EC();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _KeyShowLEDA84888EC()			
            _KeyShowLEDA84888EC:
            ; //{
            ; //_AB97CD6AD_169:;				
            _AB97CD6AD_169:
            ; //	
            ; //_AB97CD6AD_170:;				
            _AB97CD6AD_170:
            ; //	sAX	= 0x0001;			
00300:      	AX	= 0x01
            ; //	asm I1 = dtxtonech+7;			
00301:      	I1 = dtxtonech+7//
            ; //	asm AR = rm[I1];			
00303:      	AR = rm[I1]//
            ; //	asm AX = AX & AR;			
00304:      	AX = AX & AR//
            ; //	sfx_CHECKZERO();			
00305:      	AR	= AX
            ; //	if(__jz__) goto L7573600E_67;		
00306:      	if ZR	jmp L7573600E_67
            ; //	asm set io[0x09].b0;			
00307:      	set io[0x09].b0//
            ; //	goto	L7573600E_68;			
00308:      	jmp	L7573600E_68
            ; //L7573600E_67:;					
            L7573600E_67:
            ; //	asm clr io[0x09].b0;			
00309:      	clr io[0x09].b0//
            ; //L7573600E_68:;					
            L7573600E_68:
            ; //_AB97CD6AD_171:;				
            _AB97CD6AD_171:
            ; //	sAX	= 0x0002;			
0030A:      	AX	= 0x02
            ; //	asm I1 = dtxtonech+7;			
0030B:      	I1 = dtxtonech+7//
            ; //	asm AR = rm[I1];			
0030D:      	AR = rm[I1]//
            ; //	asm AX = AX & AR;			
0030E:      	AX = AX & AR//
            ; //	sfx_CHECKZERO();			
0030F:      	AR	= AX
            ; //	if(__jz__) goto L7573600E_69;		
00310:      	if ZR	jmp L7573600E_69
            ; //	asm set io[0x09].b1;			
00311:      	set io[0x09].b1//
            ; //	goto	L7573600E_70;			
00312:      	jmp	L7573600E_70
            ; //L7573600E_69:;					
            L7573600E_69:
            ; //	asm clr io[0x09].b1;			
00313:      	clr io[0x09].b1//
            ; //L7573600E_70:;					
            L7573600E_70:
            ; //L7573600E_66:;					
            L7573600E_66:
            ; //_AB97CD6AD_172:;				
            _AB97CD6AD_172:
            ; //	return;					
00314:      	rets
            ; //_KeyShowLEDA84888EC_end:;			
            _KeyShowLEDA84888EC_end:
            ; //_AB97CD6AD_173:;				
            _AB97CD6AD_173:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_led_376AFC9D_s(void)	
            ginit_code_led_376AFC9D_s:
            ; //{
            ; //	return;					
00315:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\LED_376AFC9D.S.CODE.ASM> End=========================
            
            ;=========================Include <ASMFUNC\INTERRUPT.ASM> Start=========================
            
            ; ~.~------------------------------------------
            ; void PWM_ENTRY(void) interrupt 0
            ; ---------------------------------------------
            PWM_ENTRY:
            ; {
00316:      	clr 		io[INTREQ].b0	; Clear Int0 Request!!
            
00317:      	push		AX
00318:      	push		BX
00319:      	push		CX
0031A:      	push		DX
0031B:      	push		I0
0031C:      	push		I1
0031D:      	push		P1
0031E:      	AR=		P1.hh
0031F:      	push		AR
00320:      	push		MX
00321:      	push		MR0
00322:      	push		MR1
00323:      	push		MR2
00324:      	push		CBL
            #ifdef _MSPEECHDSP_
            
            #else
00325:      	AR=		MACOP
00326:      	push		AR
00327:      	MACOP=		0
            #endif
            
00328:      	I1=		dtxRender
0032A:      	io[DACL]=	rm[I1++2]
0032B:      	io[DACL]=	rm[I1++2]
0032C:      	io[DACL]=	rm[I1++2]
0032D:      	io[DACL]=	rm[I1++2]
            
            	; dtxDoChannel();
0032E:      		PCH=		dtxDoChannel
0032F:      		lcall		dtxDoChannel
            
            	; if(dtxnote)
00330:      		I1=		dtxnote
00332:      		AX=		rm[I1++]
00333:      		AR=		rm[I1]
00334:      		AR=		AR | AX
00335:      		if ZR jmp	@pwm_label_1615
            	; {
            
            		; dtxDoEvent();
00336:      			call		dtxDoEvent
            	; }
            	@pwm_label_1615:
            	
00337:      	I1=		dtxRender
00339:      	AR=		SATV
0033A:      	CX=		3
            @pwmentry_loop_1443:
0033B:      	AR=		rm[I1++]
0033C:      	SATV=		AR
0033D:      	AR=		rm[I1--]
0033E:      	SATV=		AR
0033F:      	AR=		SATV
00340:      	rm[I1++2]=	AR
00341:      	loop		@pwmentry_loop_1443
            
            
            #ifdef _MSPEECHDSP_
            
            #else
00342:      	pop		AR
00343:      	MACOP=		AR
            #endif
00344:      	pop		CBL
00345:      	pop		MR2
00346:      	pop		MR1
00347:      	pop		MR0
00348:      	pop		MX
00349:      	pop		AR
0034A:      	P1.hh=		AR
0034B:      	pop		P1
0034C:      	pop		I1
0034D:      	pop		I0
0034E:      	pop		DX
0034F:      	pop		CX
00350:      	pop		BX
00351:      	pop		AX
00352:      	reti
            PWM_ENTRY_END:	
            ; }
            
            
            ;=========================Include <ASMFUNC\INTERRUPT.ASM> End=========================
            
            ;=========================Include <DEPS\DATA_0EBCA7F9.S.CODE.ASM> Start=========================
            ; data.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //naked void melody();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_data_0EBCA7F9_s(void)	
            ginit_code_data_0EBCA7F9_s:
            ; //{
            ; //	return;					
00353:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //naked void melody()				
            melody:
            ; //{
            ; //	asm	DW "dtx\gamedtx_32K_4CH_mp.dtx"	
00B88:      DW "dtx\gamedtx_32K_4CH_mp.dtx"
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\DATA_0EBCA7F9.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\DTX_3359D009.S.CODE.ASM> Start=========================
            ; C:\TRITAN\FDSP-IDE\tools\CC\lib\libdtx\dtx.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_dtx_3359D009_s(void)	
            ginit_code_dtx_3359D009_s:
            ; //{
            ; //	return;					
00354:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //	nop
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\DTX_3359D009.S.CODE.ASM> End=========================
            
            ;
            #LINKOBJ "C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\DTXDOCHANNEL.OBJ"
            ;
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\DTXPLAYER.ASM> Start=========================
            
            
            
            
            
            
            
            #define MAX_DTX_CHANNEL		4
            
            ; -----------------------------------------------------
            
            
            #define DTX_SET_CH1_INS		0
            #define DTX_SET_CH2_INS		1
            #define DTX_SET_CH4_INS		2
            #define DTX_RESERVE3		3
            #define DTX_CHANGE_CH1_VOL	4
            #define DTX_CHANGE_CH2_VOL	5
            #define DTX_CHANGE_CH3_VOL	6
            #define DTX_CHANGE_CH4_VOL	7
            #define DTX_USER_CMD		8
            #define DTX_REST		9
            #define DTX_SET_NOTEOFF		10
            #define DTX_END_SONG		11
            
            
            ; -----------------------------------------------------
            
            
            #define DTX_TONE_ENVADR		0
            #define DTX_TONE_ENVSTA		2
            #define DTX_TONE_TONE		4
            #define DTX_TONE_TONECNT	5
            #define DTX_TONE_FLTG		6
            #define DTX_TONE_MOD		7
            
            #define DTX_TONE_SIZEOF		8
            
            #define DTX_TONE_CH		(DTX_TONE_SIZEOF*3)
            
            ; -----------------------------------------------------
            
            #define DTX_PERC_INSADR		0
            #define DTX_PERC_INSADR_H	1
            #define DTX_PERC_FLTG		2
            #define DTX_PERC_FLTI		3
            #define DTX_PERC_FLTA		7
            #define DTX_PERC_FLTP		8
            #define DTX_PERC_ADPCM_HD	9
            #define DTX_PERC_ADPCM_S0	10
            #define DTX_PERC_ADPCM_S1	11
            #define DTX_PERC_ADPCM_CNT	12
            #define DTX_PERC_ADPCM_BUF	13
            
            #define DTX_PERC_SIZEOF		14
            
            ; -----------------------------------------------------
            
            
            VarRM[0:127] = {
            
            	dtxfltg,
            
            
            }
            
            
            
            VarRM[512:4095] = {
            
            	dtxbaseadr[2]
            	dtxinsbase[2]
            	dtxpercbase[2]
            	dtxsonghdr[2]
            	dtxnote[2]
            	dtxsongcnt
            	dtxtonech[DTX_TONE_CH]			; 3 channel tone
            	dtxperc[DTX_PERC_SIZEOF]
            
            	dtxPlayInfo
            	dtxPlayChannel
            	dtxReleaseCh
            	dtxBaseTimer
            	dtxEventTimer
            
            	dtxRender[8]
            }
            
            
            #define dtxbaseadr_l		dtxbaseadr
            #define dtxbaseadr_h		dtxbaseadr+1
            #define dtxinsbase_l		dtxinsbase
            #define dtxinsbase_h		dtxinsbase+1
            #define dtxpercbase_l		dtxpercbase
            #define dtxpercbase_h		dtxpercbase+1
            #define dtxsonghdr_l		dtxsonghdr
            #define dtxsonghdr_h		dtxsonghdr+1
            #define dtxnote_h		dtxnote+1
            
            
            
            ShareVar = {
            
            
            }
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            DTX_TONE_FREQ:
00483:      	DW 0x7A01, 0x7302, 0x6D00, 0x6603, 0x6100, 0x5B02, 0x5602, 0x5102,
0048B:      	DW 0x4D00, 0x4803, 0x4403, 0x4003, 0x3D01, 0x3903, 0x3602, 0x3302,
00493:      	DW 0x3002, 0x2D03, 0x2B01, 0x2803, 0x2602, 0x2401, 0x2201, 0x2002,
0049B:      	DW 0x1E02, 0x1C03, 0x1B01, 0x1903, 0x1801, 0x1700, 0x1502, 0x1402,
004A3:      	DW 0x1301, 0x1201, 0x1101, 0x1001, 0x0F01, 0x0E02, 0x0D02, 0x0C03,
004AB:      	DW 0x0C01, 0x0B02, 0x0A03, 0x0A01, 0x0902, 0x0900, 0x0802, 0x0800,
004B3:      	DW 0x0702, 0x0701, 0x0603, 0x0602, 0x0600, 0x0503, 0x0502, 0x0500,
004BB:      	DW 0x0403, 0x0402, 0x0401, 0x0400,
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            dtxInitialize:
            ; {
            	; dtxbaseadr = 0;
004BF:      		AR=		0
004C0:      		I1=		dtxbaseadr
004C2:      		rm[I1++]=	AR
004C3:      		rm[I1]=		AR
            
            	; dtxinsbase = 0;
004C4:      		I1=		dtxinsbase
004C6:      		rm[I1++]=	AR
004C7:      		rm[I1]=		AR
            
            	; dtxpercbase = 0;
004C8:      		I1=		dtxpercbase
004CA:      		rm[I1++]=	AR
004CB:      		rm[I1]=		AR
            
            
004CC:      	jmp		dtxInitParameters
            ; }
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            dtxInitParameters:
            ; {
            	; dtxPlayInfo = 0;
004CD:      		I1=		dtxPlayInfo
004CF:      		rm[I1]=		AR
            
            	; dtxPlayChannel = 0;
004D0:      		I1=		dtxPlayChannel
004D2:      		rm[I1]=		AR
            
            	; dtxReleaseCh = 0;
004D3:      		I1=		dtxReleaseCh
004D5:      		rm[I1]=		AR
            
            	; dtxEventTimer = 0;
004D6:      		I1=		dtxEventTimer
004D8:      		rm[I1]=		AR
            
            	; memset(dtxtonech, 0, sizeof(dtxtonech));
004D9:      		CX=		DTX_TONE_CH - 1
004DA:      		I1=		dtxtonech
            	@dtxinit_loop_0932:
004DC:      		rm[I1++]=	AR
004DD:      		loop		@dtxinit_loop_0932
            
            	; memset(&dtxperc, 0, sizeof(dtxperc));
004DE:      		CX=		DTX_PERC_SIZEOF - 1
004DF:      		I1=		dtxperc
            	@dtxinit_loop_1804:
004E1:      		rm[I1++]=	AR
004E2:      		loop		@dtxinit_loop_1804
            
            	; dtxBaseTimer = 0x001F;
004E3:      		AR=		0x001F
004E4:      		I1=		dtxBaseTimer
004E6:      		rm[I1]=		AR
            
            	#ifdef DTX_PRAM_START
            		CX=		#DTXPLAYER_PRAM_LARGE_END - 1
            		AR=		#DTXPLAYER_PRAM_LARGE_START
            		CX=		CX - AR
            		P1=		#DTXPLAYER_PRAM_LARGE_START
            		P0=		DTX_PRAM_START
            		P0.hh=		DTX_PRAM_BANK
            	@dtxinit_loop_0913:
            		AR=		pm[P1++]
            		pm[P0++]=	AR
            		loop		@dtxinit_loop_0913
            		P0.hh=		0
            	#endif
            
004E7:      	rets
            ; }
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            dtxReadTune:
            ; {
            	; ~~ read tone modtune
            
            	; spiContReadStart(dtxbaseadr + 12, &dtx);
004E8:      		I1=		dtxbaseadr
004EA:      		AR=		rm[I1++]
004EB:      		AR=		AR + 12
004EC:      		AX=		AR
004ED:      		AR=		rm[I1]
004EE:      		AR=		AR + 0 + C
004EF:      		push		AR
004F0:      		push		AX
004F1:      		AR=		BP
004F2:      		AR=		AR + 2
004F3:      		I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,5161,5165,,,,,,,,,,,,,,,,  strat ======
004F4:      AR= rm[I1 -- ] 
004F5:      P1 = rm[I1] 
004F6:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
004F7:      		pop		AR
004F8:      		pop		AR
            
            	; dtxtonech[0].Mod = spiContReadByte();
004F9:      		I1=		dtxtonech + DTX_TONE_MOD
            ;;<<System message ======  Macro. mSfContReadByte,5174,5177,,,,,,,,,,,,,,,,  strat ======
004FB:      PCH = SfContReadByte 
004FC:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
004FD:      		rm[I1]=		AR
            
            	; dtxtonech[1].Mod = spiContReadByte();
004FE:      		I1=		dtxtonech + DTX_TONE_SIZEOF + DTX_TONE_MOD
            ;;<<System message ======  Macro. mSfContReadByte,5174,5177,,,,,,,,,,,,,,,,  strat ======
00500:      PCH = SfContReadByte 
00501:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
00502:      		rm[I1]=		AR
            
            	; dtxtonech[2].Mod = spiContReadWord() >> 8;
00503:      		I1=		dtxtonech + DTX_TONE_SIZEOF + DTX_TONE_SIZEOF + DTX_TONE_MOD
            ;;<<System message ======  Macro. mSfContReadWord,5168,5171,,,,,,,,,,,,,,,,  strat ======
00505:      PCH = SfContReadWord 
00506:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00507:      		AL=		0
00508:      		xchg		AR
00509:      		rm[I1]=		AR
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,5180,5182,,,,,,,,,,,,,,,,  strat ======
0050A:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
0050B:      	rets
            ; }
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            ; bool dtxDoEvent(void)
            dtxDoEvent:
            ; {
            	; DSP16 AX;
            	; int i, mask, cmd;
            
            	; BaseTimer = (BaseTimer + 1) & 0x003F;
0050C:      		I1=		dtxBaseTimer
0050E:      		AR=		rm[I1]
0050F:      		AR++
00510:      		AR=		AR & 0x3F
00511:      		rm[I1]=		AR
            
            
            	; switch(BaseTimer)
00512:      		SF=		AR - 0
00513:      		if EQ jmp	@dtxdoe_case0_label_1906
00514:      		SF=		AR - 0x20
00515:      		if EQ jmp	@dtxdoe_case20_label_1906
00516:      		jmp		@dtxdoe_case_default_1909
            	; {
            		; case 0:
            		@dtxdoe_case0_label_1906:
            		; {
            			; mask = 0x01;
00517:      				I1=		dtxPlayChannel
00519:      				AX=		rm[I1]
            
            			; for(i = 0; i < MAX_DTX_CHANNEL; i++)
0051A:      				CX=		MAX_DTX_CHANNEL - 1
0051B:      				BX=		dtxtonech
0051D:      				DX=		1
            			@dtxdoe_loop_0911:
            			; {
            				; if(PlayChannel & mask)
0051E:      					sra		AX, 1
0051F:      					if NC jmp	@dtxdoe_label_0913
            				; {
            					; if(i != 2)		// perc
00520:      						test		DX.b2
00521:      						if NZ jmp	@dtxdoe_label_0916
            					; {
            						; ch[i].tone.envadr++;
00522:      							AR=		BX
00523:      							I1=		AR	; DTX_TONE_ENVADR
00524:      							AR=		rm[I1]
00525:      							AR++
00526:      							rm[I1++]=	AR
00527:      							AR=		rm[I1]
00528:      							AR=		AR + 0 + C
00529:      							rm[I1]=		AR
            					; }
            					@dtxdoe_label_0916:
            				; }
            				@dtxdoe_label_0913:
            
            				; mask <<= 1;
0052A:      					test		DX.b2
0052B:      					if NZ jmp	@dtxdoe_label_1614
0052C:      						AR=		DTX_TONE_SIZEOF
0052D:      						BX=		BX + AR
            					@dtxdoe_label_1614:
0052E:      					slz		DX, 1
            
0052F:      				loop		@dtxdoe_loop_0911
            			; }
            		; }
            
            		; case 0x0020:
            		@dtxdoe_case20_label_1906:
            		; {
            			; dtxEventTimer--;
00530:      				I1=		dtxEventTimer
00532:      				AR=		rm[I1]
00533:      				AR--
00534:      				rm[I1]=		AR
            
            			; if(EventTimer != 0xFFFF)
00535:      				SF=		AR - 0xFF
00536:      				if EQ jmp	@dtxdoe_label_0919
            			; {
            				; return true;
            			; }
            
            			; break;
            		; }
            
            		; default:
            		@dtxdoe_case_default_1909:
            		; {
            			; return true;
00537:      				set		Z
00538:      				rets
            		; }
            	; }
            	@dtxdoe_label_0919:
            
            
            	; spiContReadStart(dtxnote, &dtx);
00539:      		I1=		dtxnote_h
            ;;<<System message ======  Macro. mSfContReadStart,5161,5165,,,,,,,,,,,,,,,,  strat ======
0053B:      AR= rm[I1 -- ] 
0053C:      P1 = rm[I1] 
0053D:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            	; ~~            byte 0                         byte 1
            	; ~~ +-----------------------------+-----------------------------+
            	; ~~ |      H             L        |      H              L       |
            	; ~~ +--------------+--------------+--------------+--------------+
            	; ~~ | Note Timer H | Note Timer M | Note Timer L |   PlayInfo   |
            	; ~~ +--------------+--------------+--------------+--------------+
            
            	; AX = spiContReadByte();
            ;;<<System message ======  Macro. mSfContReadByte,5174,5177,,,,,,,,,,,,,,,,  strat ======
0053E:      PCH = SfContReadByte 
0053F:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
            
            	; dtxEventTimer = (AX.U << 4);
00540:      		I1=		dtxEventTimer
00542:      		AX=		AR
00543:      		slz		AX, 2
00544:      		slz		AX, 2
            
            	; AX = spiContReadByte();
            ;;<<System message ======  Macro. mSfContReadByte,5174,5177,,,,,,,,,,,,,,,,  strat ======
00545:      PCH = SfContReadByte 
00546:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
            
            	; dtxEventTimer |= (AX.U >> 4);
00547:      		push		AR
00548:      		sra		AR, 2
00549:      		sra		AR, 2
0054A:      		rm[I1]=		AR | AX
0054B:      		AX=		rm[I1]
            
            	; dtxPlayInfo = (unsigned long)(AX.U & 0x000F);
0054C:      		pop		AR
0054D:      		I1=		dtxPlayInfo
0054F:      		AR=		AR & 0x0F
00550:      		rm[I1]=		AR
            
            	; dtxnote += 2;
00551:      		I1=		dtxnote
00553:      		AR=		rm[I1]
00554:      		AR=		AR + 2
00555:      		rm[I1++]=	AR
00556:      		AR=		rm[I1]
00557:      		AR=		AR + 0 + C
00558:      		rm[I1]=		AR
            
            	; if(!dtxPlayInfo)
00559:      		I1=		dtxPlayInfo
0055B:      		AR=		rm[I1]
0055C:      		if NZ jmp	@dtxdoe_label_0933
            	; {
            		; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,5180,5182,,,,,,,,,,,,,,,,  strat ======
0055D:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            		; return false;
0055E:      			clr		Z
0055F:      			rets
            	; }
            	@dtxdoe_label_0933:
            
            	; // ---
            
            	; while(PlayInfo)
            	@dtxdoe_loop_1400:
00560:      		io[ClrWDT]=	AR
00561:      		I1=		dtxPlayInfo
00563:      		AR=		rm[I1]
00564:      		if ZR jmp	@dtxdoe_label_0935
            	; {
            		; AX = spiContReadByte();
            ;;<<System message ======  Macro. mSfContReadByte,5174,5177,,,,,,,,,,,,,,,,  strat ======
00565:      PCH = SfContReadByte 
00566:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
00567:      			AX=		AR
            
            		; note++;
00568:      			I1=		dtxnote
0056A:      			AR=		rm[I1]
0056B:      			AR++
0056C:      			rm[I1++]=	AR
0056D:      			AR=		rm[I1]
0056E:      			AR=		AR + 0 + C
0056F:      			rm[I1]=		AR
            
            		; //          byte 3
            		; // +---------------------+
            		; //      H           L
            		; // +---+-------+---------+
            		; // | 1 | 0 0 0 | x x x x |   command
            		; // +---+-------+---------+
            		; //           or
            		; // +---+-------+---------+
            		; // | y | y y y | x x x x |   data
            		; // +---+-------+---------+
            
            
            		; if(AX.N1 == 0x08)
00570:      			AR=		0x00F0
00572:      			AR=		AR & AX
00573:      			AH=		0xFF
00574:      			SF=		AR - 0x80
00575:      			if NE jmp	@dtxdoe_label_0939
            		; {
            			; // command prc
            
            			; note++;
00576:      				I1=		dtxnote
00578:      				AR=		rm[I1]
00579:      				AR++
0057A:      				rm[I1++]=	AR
0057B:      				AR=		rm[I1]
0057C:      				AR=		AR + 0 + C
0057D:      				rm[I1]=		AR
            
            			; cmd = AX.N0;
0057E:      				AR=		0x0F
0057F:      				AR=		AX & AR
00580:      				push		AR
            
            			; AX = spiContReadByte();
            ;;<<System message ======  Macro. mSfContReadByte,5174,5177,,,,,,,,,,,,,,,,  strat ======
00581:      PCH = SfContReadByte 
00582:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
00583:      				AX=		AR
            
            			; switch(cmd)
00584:      				pop		AR
00585:      				SF=		AR - DTX_SET_CH1_INS
00586:      				if EQ jmp	@dtxdoe_case_DTX_SET_CH1_INS_label_0948
00587:      				SF=		AR - DTX_SET_CH2_INS
00588:      				if EQ jmp	@dtxdoe_case_DTX_SET_CH2_INS_label_0948
00589:      				SF=		AR - DTX_SET_CH4_INS
0058A:      				if EQ jmp	@dtxdoe_case_DTX_SET_CH4_INS_label_0948
0058B:      				SF=		AR - DTX_CHANGE_CH1_VOL
0058C:      				if EQ jmp	@dtxdoe_case_DTX_CHANGE_CH1_VOL_label_0948
0058D:      				SF=		AR - DTX_CHANGE_CH2_VOL
0058E:      				if EQ jmp	@dtxdoe_case_DTX_CHANGE_CH2_VOL_label_0948
0058F:      				SF=		AR - DTX_CHANGE_CH3_VOL
00590:      				if EQ jmp	@dtxdoe_case_DTX_CHANGE_CH3_VOL_label_0948
00591:      				SF=		AR - DTX_CHANGE_CH4_VOL
00592:      				if EQ jmp	@dtxdoe_case_DTX_CHANGE_CH4_VOL_label_0948
00593:      				SF=		AR - DTX_REST
00594:      				if EQ jmp	@dtxdoe_case_DTX_REST_label_0948
00595:      				SF=		AR - DTX_SET_NOTEOFF
00596:      				if EQ jmp	@dtxdoe_case_DTX_SET_NOTEOFF_label_0948
00597:      				SF=		AR - DTX_END_SONG
00598:      				if GE jmp	@dtxdoe_case_DTX_END_SONG_label_0948
00599:      				jmp		@dtxdoe_label_0955
            			; {
            				; case DTX_SET_CH1_INS:
            				@dtxdoe_case_DTX_SET_CH1_INS_label_0948:
            				; {
            					; SetTone(&ch[0].tone, (int)AX.U);
0059A:      						BX=		dtxtonech
0059C:      						call		dtxSetTone
            					; break;
0059D:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_SET_CH2_INS:
            				@dtxdoe_case_DTX_SET_CH2_INS_label_0948:
            				; {
            					; SetTone(&ch[1].tone, (int)AX.U);
0059E:      						BX=		dtxtonech + DTX_TONE_SIZEOF
005A0:      						call		dtxSetTone
            					; break;
005A1:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_SET_CH4_INS:
            				@dtxdoe_case_DTX_SET_CH4_INS_label_0948:
            				; {
            					; SetTone(&ch[3].tone, (int)AX.U);
005A2:      						BX=		dtxtonech + DTX_TONE_SIZEOF + DTX_TONE_SIZEOF
005A4:      						call		dtxSetTone
            					; break;
005A5:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_RESERVE3:
            					; break;
            
            				; case DTX_CHANGE_CH1_VOL:
            				@dtxdoe_case_DTX_CHANGE_CH1_VOL_label_0948:
            				; {
            					; SetChFLTG(&ch[0], (int)AX.U);
005A6:      						BX=		dtxtonech
005A8:      						call		dtxSetToneFLTG
            					; break;
005A9:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_CHANGE_CH2_VOL:
            				@dtxdoe_case_DTX_CHANGE_CH2_VOL_label_0948:
            				; {
            					; SetChFLTG(&ch[1], (int)AX.U);
005AA:      						BX=		dtxtonech + DTX_TONE_SIZEOF
005AC:      						call		dtxSetToneFLTG
            					; break;
005AD:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_CHANGE_CH3_VOL:
            				@dtxdoe_case_DTX_CHANGE_CH3_VOL_label_0948:
            				; {
            					; SetChFLTG(&ch[2], (int)AX.U);
005AE:      						BX=		dtxperc
005B0:      						call		dtxSetPercFLTG
            					; break;
005B1:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_CHANGE_CH4_VOL:
            				@dtxdoe_case_DTX_CHANGE_CH4_VOL_label_0948:
            				; {
            					; SetChFLTG(&ch[3], (int)AX.U);
005B2:      						BX=		dtxtonech + DTX_TONE_SIZEOF + DTX_TONE_SIZEOF
005B4:      						call		dtxSetToneFLTG
            					; break;
005B5:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_USER_CMD:
            					; break;
            
            				; case DTX_REST:
            				@dtxdoe_case_DTX_REST_label_0948:
            				; {
            					; //       H           L
            					; // +---------+--------------------------------+
            					; // | 0 0 0 0 | active bit for tone ctrl / flag|
            					; // +---------+--------------------------------+
            
            					; // TONE_FLAG as PlayChannel
            
            					; dtxPlayChannel &= (unsigned long)~AX.U;
005B6:      						AR=		-1
005B7:      						AX=		AX ^ AR
005B8:      						I1=		dtxPlayChannel
005BA:      						AR=		rm[I1]
005BB:      						rm[I1]=		AR & AX
            
            					; dtxPlayInfo &= (unsigned long)~AX.U;
005BC:      						I1=		dtxPlayInfo
005BE:      						AR=		rm[I1]
005BF:      						rm[I1]=		AR & AX
            
            					; break;
005C0:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_SET_NOTEOFF:
            				@dtxdoe_case_DTX_SET_NOTEOFF_label_0948:
            				; {
            					; //       H           L
            					; // +---------+-----------------------------+
            					; // | 0 0 0 0 | active bit for CH_RAMP_FLAG |
            					; // +---------+-----------------------------+
            
            					; // CH_RAMP_FLAG as ReleaseChannel
            
            					; dtxReleaseCh |= (unsigned long)AX.U;
005C1:      						I1=		dtxReleaseCh
005C3:      						AR=		rm[I1]
005C4:      						rm[I1]=		AR | AX
            
            					; PlayInfo &= (unsigned long)~AX.U;
005C5:      						AR=		-1
005C6:      						AX=		AX ^ AR
005C7:      						I1=		dtxPlayInfo
005C9:      						AR=		rm[I1]
005CA:      						rm[I1]=		AR & AX
            
            					; break;
005CB:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_END_SONG:
            				@dtxdoe_case_DTX_END_SONG_label_0948:
            				; default:
            				; {
            					; dtxnote = 0;
005CC:      						I1=		dtxnote
005CE:      						AR=		0
005CF:      						rm[I1++]=	AR
005D0:      						rm[I1]=		AR
            
            					; dtxPlayChannel = 0;
005D1:      						I1=		dtxPlayChannel
005D3:      						rm[I1]=		AR
            
            					; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,5180,5182,,,,,,,,,,,,,,,,  strat ======
005D4:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            					; return false;
005D5:      						clr		Z
005D6:      						rets
            				; }
            			; }
            			@dtxdoe_label_0955:
            
005D7:      			jmp		@dtxdoe_label_0939_1
            		; }
            		; else
            		@dtxdoe_label_0939:
            		; {
            			; // data prc
            
            			; SetChannelData(AX);
005D8:      				call		dtxSetChannelData
            		; }
            		@dtxdoe_label_0939_1:
            
005D9:      		jmp		@dtxdoe_loop_1400
            	; }
            	@dtxdoe_label_0935:
            
            	; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,5180,5182,,,,,,,,,,,,,,,,  strat ======
005DA:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; return true;
005DB:      		set		Z
005DC:      		rets
            ; }
            
            
            ; --------------------------------------------
            ; void SetTone(toneChannel *tonech, int ins)
            ;
            ; in:
            ;    tonech 	: BX
            ;    ins	: AX
            ;
            ; out:
            ;
            ;
            ; --------------------------------------------
            dtxSetTone:
            ; {
            	; unsigned long adr;
            	; DSP16 AX, BX;
            
            	; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,5180,5182,,,,,,,,,,,,,,,,  strat ======
005DD:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; // read tone index map
            
            	; adr = dtxbaseadr + 16 + ins;
005DE:      		AR=		16
005DF:      		AX=		AX + AR
005E0:      		I1=		dtxbaseadr
005E2:      		AR=		rm[I1++]
005E3:      		AX=		AX + AR
005E4:      		AR=		rm[I1]
005E5:      		AR=		AR + 0 + C
            
            	; spiContReadStart(adr & ~1, &dtx);
005E6:      		push		AR
005E7:      		AR=		AX
005E8:      		clr		AR.b0
005E9:      		push		AR
005EA:      		AR=		BP
005EB:      		AR=		AR + 2
005EC:      		I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,5161,5165,,,,,,,,,,,,,,,,  strat ======
005ED:      AR= rm[I1 -- ] 
005EE:      P1 = rm[I1] 
005EF:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
005F0:      		pop		AR
005F1:      		pop		AR
            
            	; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,5168,5171,,,,,,,,,,,,,,,,  strat ======
005F2:      PCH = SfContReadWord 
005F3:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            	; // high byte
            
            	; if(adr & 0x01)
005F4:      		test		AX.b0
005F5:      		if ZR jmp	@dtxst_label_1018
            	; {
            		; AX.U >>= 8;
005F6:      			xchg		AR
005F7:      		jmp		@dtxst_label_1018_1
            	; }
            	; else
            	@dtxst_label_1018:
            	; {
            		; AX.H = 0x00;
            	; }
            	@dtxst_label_1018_1:
005F8:      		AH=		0
005F9:      		AX=		AR
            
            	; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,5180,5182,,,,,,,,,,,,,,,,  strat ======
005FA:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; AX.U <<= 2;
005FB:      		slz		AX, 2
            
            	; adr = dtxinsbase + AX.U;
005FC:      		I1=		dtxinsbase
005FE:      		AR=		rm[I1++]
005FF:      		AX=		AX + AR
00600:      		AR=		rm[I1]
00601:      		AR=		AR + 0 + C
            
            	; spiContReadStart(adr, &dtx);
00602:      		push		AR
00603:      		push		AX
00604:      		AR=		BP
00605:      		AR=		AR + 2
00606:      		I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,5161,5165,,,,,,,,,,,,,,,,  strat ======
00607:      AR= rm[I1 -- ] 
00608:      P1 = rm[I1] 
00609:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
0060A:      		pop		AR
0060B:      		pop		AR
            
            	; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,5168,5171,,,,,,,,,,,,,,,,  strat ======
0060C:      PCH = SfContReadWord 
0060D:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
0060E:      		AX=		AR
            
            	; BX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,5168,5171,,,,,,,,,,,,,,,,  strat ======
0060F:      PCH = SfContReadWord 
00610:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00611:      		push		AR
            
            	; tonech->envsta = baseadr + ((unsigned long)BX.U << 16) + (unsigned long)AX.U;
00612:      		I1=		dtxbaseadr + 1
00614:      		AR=		rm[I1--]
00615:      		push		AR
00616:      		AR=		rm[I1]
00617:      		push		AR
00618:      		AR=		DTX_TONE_ENVSTA
00619:      		AR=		AR + BX
0061A:      		I1=		AR
0061B:      		pop		AR
0061C:      		rm[I1++]=	AR + AX
0061D:      		pop		AX
0061E:      		pop		AR
0061F:      		rm[I1--]=	AR + AX + C
            
            	; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,5180,5182,,,,,,,,,,,,,,,,  strat ======
00620:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; // restore note pointer
            
            	; spiContReadStart(note, &dtx);
00621:      		I1=		dtxnote_h
            ;;<<System message ======  Macro. mSfContReadStart,5161,5165,,,,,,,,,,,,,,,,  strat ======
00623:      AR= rm[I1 -- ] 
00624:      P1 = rm[I1] 
00625:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
00626:      	rets
            ; }
            
            ; --------------------------------------------
            ; void dtxSetToneFLTG(dtxChannel *chp, int FLTG)
            ;
            ; in:
            ;    BX		: chp
            ;    AX		: FLTG
            ;
            ;
            ;
            ;
            ; --------------------------------------------
            dtxSetToneFLTG:
            ; {
            	; chp->tone.FLTG = 0x0888 * FLTG;
00627:      		MX=		0x0888
00629:      		AR=		AX
            	#ifdef _MSPEECHDSP_
            		MULSS
            	#else
0062A:      		MR=		MX * AR
            	#endif
0062B:      		AR=		DTX_TONE_FLTG
0062C:      		AR=		AR + BX
0062D:      		I1=		AR
            
            	; AR = 0
            	; MR0 = AR
            
0062E:      		rm[I1]=		MR0
            
0062F:      	rets
            ; }
            
            
            ; --------------------------------------------
            ; void dtxSetPercFLTG(dtxChannel *chp, int FLTG)
            ;
            ; in:
            ;    BX		: chp
            ;    AX		: FLTG
            ;
            ;
            ;
            ;
            ; --------------------------------------------
            dtxSetPercFLTG:
            ; {
            	; chp->tone.FLTG = 0x0888 * FLTG;
            		; MX=		0x0888
            		; AR=		AX
            	; #ifdef _MSPEECHDSP_
            		; MULSS
            	; #else
            		; MR=		MX * AR
            	; #endif
            		; AR=		DTX_PERC_FLTG
            		; AR=		AR + BX
            		; I1=		AR
            		; rm[I1]=		MR0
            
00630:      		slz		AX, 2
00631:      		set		AX.b0
00632:      		set		AX.b1
00633:      		AR=		DTX_PERC_FLTG
00634:      		AR=		AR + BX
00635:      		I1=		AR
            
            	; AX = 0
            
00636:      		rm[I1]=		AX
            
00637:      	rets
            ; }
            
            
            ; --------------------------------------------
            ; void dtxSetChannelData(DSP16 AX)
            ;
            ; in:
            ;    AX		: AX
            ;
            ;
            ;
            ;
            ; --------------------------------------------
            dtxSetChannelData:
            ; {
            	; int i, adr;
            	; int mask;
            	; DSP16 BX;
            
            	; mask = 0x01;
00638:      		DX=		1
            
            	; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,5180,5182,,,,,,,,,,,,,,,,  strat ======
00639:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; for(i = 0; i < MAX_DTX_CHANNEL; i++)
0063A:      		CX=		MAX_DTX_CHANNEL - 1
0063B:      		I1=		dtxPlayInfo
0063D:      		BX=		rm[I1]
0063E:      		MX=		dtxtonech
            	@dtxscd_loop_1128:
            	; {
            		; if(PlayInfo & mask)
00640:      			src		BX, 1
00641:      			if NC jmp	@dtxscd_label_1129
            		; {
            			; if(ch[i].type == dtxChannel::TONE_CHANNEL)
00642:      				test		DX.b2
00643:      				if NZ jmp	@dtxscd_label_1130
            			; {
            				; // read FREQ table in real chip
            
            				; ch[i].tone.envadr = ch[i].tone.envsta;
00644:      					push		BX
00645:      					push		DX
00646:      					AR=		DTX_TONE_ENVSTA
00647:      					AR=		MX + AR
00648:      					I1=		AR
00649:      					BX=		rm[I1++]
0064A:      					DX=		rm[I1]
0064B:      					AR=		MX		; DTX_TONE_ENVADR
0064C:      					I1=		AR
0064D:      					rm[I1++]=	BX
0064E:      					rm[I1]=		DX
0064F:      					pop		DX
00650:      					pop		BX
            
            				; ch[i].tone.TONE.FREQ = DTX_TONE_FREQ[AX.U];
00651:      					AR=		DTX_TONE_TONE
00652:      					AR=		AR + MX
00653:      					I1=		AR
00654:      					P1=		#DTX_TONE_FREQ	; ~~ read stop !!
00657:      					AR=		AX
00658:      					P1=		P1 + AR
00659:      					rm[I1++]=	pm[P1]
            
            				; ch[i].tone.TONECNT.FREQ = 0;
0065A:      					AR=		0
0065B:      					rm[I1]=		AR
            
            
0065C:      				jmp		@dtxscd_label_1130_1
            			; }
            			; else
            			@dtxscd_label_1130:
            			; {
            				; memset(&dtxperc, 0, sizeof(dtxperc));
0065D:      					push		CX
0065E:      					I1=		dtxperc
00660:      					AR=		DTX_PERC_FLTI
00661:      					I1=		I1 + AR
00662:      					CX=		DTX_PERC_SIZEOF - 4
00663:      					AR=		0
            				@dtxscd_loop_1337:
00664:      					rm[I1++]=	AR
00665:      					loop		@dtxscd_loop_1337
00666:      					pop		CX
            
            				; // perc + 128
            
            				; adr = dtxbaseadr + 16 + ((AX.U & 0x3F) | 0x80);
00667:      					AR=		0x3F
00668:      					AX=		AX & AR
00669:      					AR=		0x0090
0066B:      					AX=		AX + AR
0066C:      					I1=		dtxbaseadr
0066E:      					AR=		rm[I1++]
0066F:      					AX=		AX + AR
00670:      					AR=		rm[I1]
00671:      					AR=		AR + 0 + C
            
            				; spiContReadStart(adr, &dtx);
00672:      					push		AR
00673:      					push		AX
00674:      					AR=		BP
00675:      					AR=		AR + 2
00676:      					I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,5161,5165,,,,,,,,,,,,,,,,  strat ======
00677:      AR= rm[I1 -- ] 
00678:      P1 = rm[I1] 
00679:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
0067A:      					pop		AR
0067B:      					pop		AR
            
            				; AX = spiContReadByte();
            ;;<<System message ======  Macro. mSfContReadByte,5174,5177,,,,,,,,,,,,,,,,  strat ======
0067C:      PCH = SfContReadByte 
0067D:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
0067E:      					AX=		AR
            
            				; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,5180,5182,,,,,,,,,,,,,,,,  strat ======
0067F:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            				; // 4 bytes
            
            				; AX.U <<= 2;
00680:      					slz		AX, 2
            
            				; adr = dtxpercbase + AX.U;
00681:      					I1=		dtxpercbase
00683:      					AR=		rm[I1++]
00684:      					AX=		AX + AR
00685:      					AR=		rm[I1]
00686:      					AR=		AR + 0 + C
            
            				; spiContReadStart(adr, &dtx);
00687:      					push		AR
00688:      					push		AX
00689:      					AR=		BP
0068A:      					AR=		AR + 2
0068B:      					I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,5161,5165,,,,,,,,,,,,,,,,  strat ======
0068C:      AR= rm[I1 -- ] 
0068D:      P1 = rm[I1] 
0068E:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
0068F:      					pop		AR
00690:      					pop		AR
            
            				; AX = spiContReadWord();
00691:      					push		BX
00692:      					push		DX
            ;;<<System message ======  Macro. mSfContReadWord,5168,5171,,,,,,,,,,,,,,,,  strat ======
00693:      PCH = SfContReadWord 
00694:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00695:      					BX=		AR
            
            				; BX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,5168,5171,,,,,,,,,,,,,,,,  strat ======
00696:      PCH = SfContReadWord 
00697:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00698:      					DX=		AR
            
            				; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,5180,5182,,,,,,,,,,,,,,,,  strat ======
00699:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            				; ch[i].perc.insadr = baseadr + (((unsigned long)BX.U & 0x00FF) << 16) + (unsigned long)AX.U;
0069A:      					push		DX
0069B:      					I1=		dtxbaseadr
0069D:      					DX.h=		0
0069E:      					AR=		rm[I1++]
0069F:      					BX=		BX + AR
006A0:      					AR=		rm[I1]
006A1:      					AR=		AR + DX + C
006A2:      					I1=		dtxperc
006A4:      					rm[I1++]=	BX
006A5:      					rm[I1++]=	AR
            
            				; // FLTP
            
            				; ch[i].perc.FLTP = (BX.U << 3) & 0xFF00;
006A6:      					pop		AR
006A7:      					slz		AR, 2
006A8:      					slz		AR, 1
006A9:      					AL=		0
006AA:      					I1=		dtxperc + DTX_PERC_FLTP
006AC:      					rm[I1]=		AR
006AD:      					pop		DX
006AE:      					pop		BX
            
            				; // pre-cache
            
            				; spiContReadStart(ch[i].perc.insadr, &dtx);
006AF:      					I1=		dtxperc + 1
            ;;<<System message ======  Macro. mSfContReadStart,5161,5165,,,,,,,,,,,,,,,,  strat ======
006B1:      AR= rm[I1 -- ] 
006B2:      P1 = rm[I1] 
006B3:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            				; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,5168,5171,,,,,,,,,,,,,,,,  strat ======
006B4:      PCH = SfContReadWord 
006B5:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            				; ch[i].perc.TASPAD.BUF = AX.S;
006B6:      					I1=		dtxperc + DTX_PERC_ADPCM_BUF
006B8:      					rm[I1]=		AR
            
            				; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,5180,5182,,,,,,,,,,,,,,,,  strat ======
006B9:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            				; ch[i].perc.insadr += 2;
006BA:      					I1=		dtxperc
006BC:      					AR=		rm[I1]
006BD:      					AR=		AR + 2
006BE:      					rm[I1++]=	AR
006BF:      					AR=		rm[I1]
006C0:      					AR=		AR + 0 + C
006C1:      					rm[I1]=		AR
            			; }
            			@dtxscd_label_1130_1:
            
            			; dtxPlayChannel |= mask;
006C2:      				I1=		dtxPlayChannel
006C4:      				AR=		rm[I1]
006C5:      				rm[I1]=		AR | DX
            
            			; dtxReleaseCh &= ~mask;
006C6:      				I1=		dtxReleaseCh
006C8:      				push		DX
006C9:      				AR=		-1
006CA:      				DX=		DX ^ AR
006CB:      				AR=		rm[I1]
006CC:      				rm[I1]=		AR & DX
            
            			; dtxPlayInfo &= ~mask;
006CD:      				I1=		dtxPlayInfo
006CF:      				AR=		rm[I1]
006D0:      				rm[I1]=		AR & DX
006D1:      				pop		DX
            
            			; if(PlayInfo)
006D2:      				AR=		rm[I1]
006D3:      				if ZR jmp	@dtxscd_label_1358
            			; {
            				; spiContReadStart(note, &dtx);
006D4:      					I1=		dtxnote_h
            ;;<<System message ======  Macro. mSfContReadStart,5161,5165,,,,,,,,,,,,,,,,  strat ======
006D6:      AR= rm[I1 -- ] 
006D7:      P1 = rm[I1] 
006D8:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            				; AX = spiContReadByte();
            ;;<<System message ======  Macro. mSfContReadByte,5174,5177,,,,,,,,,,,,,,,,  strat ======
006D9:      PCH = SfContReadByte 
006DA:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
006DB:      					AX=		AR
            
            				; note++;
006DC:      					I1=		dtxnote
006DE:      					AR=		rm[I1]
006DF:      					AR++
006E0:      					rm[I1++]=	AR
006E1:      					AR=		rm[I1]
006E2:      					AR=		AR + 0 + C
006E3:      					rm[I1]=		AR
            
            				; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,5180,5182,,,,,,,,,,,,,,,,  strat ======
006E4:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            			; }
            			@dtxscd_label_1358:
            		; }
            		@dtxscd_label_1129:
            
            		; mask <<= 1;
006E5:      			test		DX.b2
006E6:      			if NZ jmp	@dtxscd_label_1911
006E7:      				AR=		DTX_TONE_SIZEOF
006E8:      				MX=		MX + AR
            		@dtxscd_label_1911:
006E9:      			slz		DX, 1
            
006EA:      		loop		@dtxscd_loop_1128
            	; }
            
            	; spiContReadStart(note, &dtx);
006EB:      		I1=		dtxnote_h
            ;;<<System message ======  Macro. mSfContReadStart,5161,5165,,,,,,,,,,,,,,,,  strat ======
006ED:      AR= rm[I1 -- ] 
006EE:      P1 = rm[I1] 
006EF:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
006F0:      	rets
            ; }
            
            
            
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            ; ~.~---------------------------------------------------
            ; bool dtxFindToneEntry(unsigned long flashadr)
            ;
            ; in:
            ;    AX:BX		- flashadr
            ;
            ; out:
            ;
            ;
            ; affect registers:
            ;
            ;
            ; meaning registers:
            ;
            ;
            ; special request:
            ;
            ;
            ; -------------------------------------------------------------
            dtxFindToneEntry:
            ; {
            	; dtxbaseadr = flashadr;
006F1:      		I1=		dtxbaseadr
            	#ifdef DTX_WORD_ADR
006F3:      		slz		BX, 1
006F4:      		slc		AX, 1
            	#endif
006F5:      		rm[I1++]=	BX
006F6:      		rm[I1]=		AX
            
            	; dtxsonghdr = flashadr;
006F7:      		I1=		dtxsonghdr
006F9:      		rm[I1++]=	BX
006FA:      		rm[I1]=		AX
            
            	; sfContReadStart(HIADR(&dtxbaseadr));
            ;;<<System message ======  Macro. mSfContReadStart,5161,5165,,,,,,,,,,,,,,,,  strat ======
006FB:      AR= rm[I1 -- ] 
006FC:      P1 = rm[I1] 
006FD:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            	; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,5168,5171,,,,,,,,,,,,,,,,  strat ======
006FE:      PCH = SfContReadWord 
006FF:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00700:      		AX=		AR
            
            	; BX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,5168,5171,,,,,,,,,,,,,,,,  strat ======
00701:      PCH = SfContReadWord 
00702:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            	; ~~ check "DTX " mark
            
            	; if((AX != 0x5444) || (BX != 0x2058))
00703:      		BX=		0x2058
00705:      		SF=		AR - BX
00706:      		if NZ jmp	@dtxfte_label_1821
00707:      		AR=		0x5444
00709:      		SF=		AR - AX
0070A:      		if NZ jmp	@dtxfte_label_1821
0070B:      		jmp		@dtxfte_label_1823
            	@dtxfte_label_1821:
            	; {
            		; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,5180,5182,,,,,,,,,,,,,,,,  strat ======
0070C:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            		; return false;
0070D:      			clr		Z
0070E:      			rets
            	; }
            	@dtxfte_label_1823:
            
            
            	; dtxinsbase = dtxbaseadr + (unsigned long)head->InsAddrEntry;
0070F:      		I1=		dtxbaseadr_l
00711:      		AX=		rm[I1++]
00712:      		BX=		rm[I1]
            ;;<<System message ======  Macro. mSfContReadWord,5168,5171,,,,,,,,,,,,,,,,  strat ======
00713:      PCH = SfContReadWord 
00714:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00715:      		AX=		AX + AR
00716:      		AR=		0
00717:      		BX=		BX + AR + C
00718:      		I1=		dtxinsbase
0071A:      		rm[I1++]=	AX
0071B:      		rm[I1]=		BX
            
            	; dtxpercbase = dtxbaseadr + (unsigned long)head->PercAddrEntry;
0071C:      		I1=		dtxbaseadr_l
0071E:      		AX=		rm[I1++]
0071F:      		BX=		rm[I1]
            ;;<<System message ======  Macro. mSfContReadWord,5168,5171,,,,,,,,,,,,,,,,  strat ======
00720:      PCH = SfContReadWord 
00721:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00722:      		AX=		AX + AR
00723:      		AR=		0
00724:      		BX=		BX + AR + C
00725:      		I1=		dtxpercbase
00727:      		rm[I1++]=	AX
00728:      		rm[I1]=		BX
            
            	; dtxsonghdr = dtxbaseadr + (unsigned long)head->SongListEntry;
            ;;<<System message ======  Macro. mSfContReadWord,5168,5171,,,,,,,,,,,,,,,,  strat ======
00729:      PCH = SfContReadWord 
0072A:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
0072B:      		AX=		AR
            ;;<<System message ======  Macro. mSfContReadWord,5168,5171,,,,,,,,,,,,,,,,  strat ======
0072C:      PCH = SfContReadWord 
0072D:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
0072E:      		BX=		AR
0072F:      		I1=		dtxbaseadr_l
00731:      		AR=		rm[I1++]
00732:      		AX=		AX + AR
00733:      		AR=		rm[I1]
00734:      		BX=		BX + AR + C
00735:      		I1=		dtxsonghdr
00737:      		rm[I1++]=	AX
00738:      		rm[I1]=		BX
            
            	; ~~
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,5180,5182,,,,,,,,,,,,,,,,  strat ======
00739:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; sfContReadStart(HIADR(&dtxsonghdr));
0073A:      		I1=		dtxsonghdr_h
            ;;<<System message ======  Macro. mSfContReadStart,5161,5165,,,,,,,,,,,,,,,,  strat ======
0073C:      AR= rm[I1 -- ] 
0073D:      P1 = rm[I1] 
0073E:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            	; dtxsongcnt = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,5168,5171,,,,,,,,,,,,,,,,  strat ======
0073F:      PCH = SfContReadWord 
00740:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00741:      		I1=		dtxsongcnt
00743:      		rm[I1]=		AR
            
            	; dtxsonghdr += 2;
00744:      		I1=		dtxsonghdr_l
00746:      		AR=		rm[I1]
00747:      		AR=		AR + 2
00748:      		rm[I1++]=	AR
00749:      		AR=		rm[I1]
0074A:      		AR=		AR + 0 + C
0074B:      		rm[I1]=		AR
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,5180,5182,,,,,,,,,,,,,,,,  strat ======
0074C:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            
            	; return true;
0074D:      		set		Z
0074E:      		rets
            ; }
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~.~------------------------------------------------------------
            ; bool dtxPlaySong(short index)
            ;
            ; in:
            ;    AX			- index
            ;
            ; out:
            ;    none
            ;
            ; affect registers:
            ;    All
            ;
            ; meaning registers:
            ;
            ;
            ; special request:
            ;   none
            ;
            ; -------------------------------------------------------------
            dtxPlaySong:
            ; {
            	; if(index >= mp.songcnt)
0074F:      		I1=		dtxsongcnt
00751:      		AR=		rm[I1]
00752:      		SF=		AR - AX
00753:      		if LE jmp	@dtxplaysong_label_1541
00754:      		jmp		@dtxplaysong_label_1541_1
            	@dtxplaysong_label_1541:
            	; {
            		; return false;
00755:      			clr		Z
00756:      			rets
            	; }
            	@dtxplaysong_label_1541_1:
            
            
            	; dtxnote = dtxsonghdr + (index * sizeof(long));
00757:      		I1=		dtxsonghdr
00759:      		BX=		rm[I1++]
0075A:      		DX=		rm[I1]
0075B:      		I1=		dtxnote
0075D:      		AR=		AX
0075E:      		slz		AR, 2
0075F:      		rm[I1++]=	BX + AR
00760:      		AR=		0
00761:      		rm[I1]=		DX + AR + C
            
            	; sfContReadStart(HIADR(&dtxnote));
00762:      		I1=		dtxnote_h
            ;;<<System message ======  Macro. mSfContReadStart,5161,5165,,,,,,,,,,,,,,,,  strat ======
00764:      AR= rm[I1 -- ] 
00765:      P1 = rm[I1] 
00766:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            	; lo = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,5168,5171,,,,,,,,,,,,,,,,  strat ======
00767:      PCH = SfContReadWord 
00768:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00769:      		BX=		AR
            
            	; hi = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,5168,5171,,,,,,,,,,,,,,,,  strat ======
0076A:      PCH = SfContReadWord 
0076B:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
0076C:      		DX=		AR
            
            	; dtxnote = dtxbaseadr + (hi << 16) + lo;
0076D:      		I1=		dtxbaseadr
0076F:      		AR=		rm[I1++]
00770:      		BX=		BX + AR
00771:      		AR=		rm[I1]
00772:      		DX=		DX + AR + C
00773:      		I1=		dtxnote
00775:      		rm[I1++]=	BX
00776:      		rm[I1]=		DX
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,5180,5182,,,,,,,,,,,,,,,,  strat ======
00777:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; dtxBaseTimer = 0x001F;
00778:      		AR=		0x001F
00779:      		I1=		dtxBaseTimer
0077B:      		rm[I1]=		AR
            
            	; dtxEventTimer = 0;
0077C:      		I1=		dtxEventTimer
0077E:      		rm[I1]=		AR
            
            	; dtxStartBGServe();
0077F:      		PCH=		dtxStartBGServe
00780:      		lcall		dtxStartBGServe
            
            	; return true;
00781:      		set		Z
00782:      		rets
            ; }
            
            ; -----------------------------------------------
            
            
            dtxStopSong:
            ; {
00783:      	I1=		dtxnote
00785:      	AR=		0
00786:      	rm[I1++]=	AR
00787:      	rm[I1++]=	AR
            
00788:      	I1=		dtxPlayChannel
0078A:      	rm[I1]=		AR
            
0078B:      	rets
            ; }
            
            
            ; -----------------------------------------------
            
            
            dtxCheckSongEnd:
            ; {
0078C:      	I1=		dtxnote
0078E:      	AR=		rm[I1++]
0078F:      	AX=		rm[I1]
00790:      	AR=		AR | AX
00791:      	rets
            ; }
            
            
            
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            dtxStartBGServe:
            ; {
            	; ClearIntReq(INT0);
00792:      		clr		io[INTREQ].b0
            
            	; EnableInterrupt(INT0);
00793:      		ena		INT0
            
            	; EnableInterrupts();
00794:      		eni
            
00795:      	rets
            ; }
            
            
            
            dtxStopBGServe:
            ; {
            	; DisableInterrupt(INT0);
00796:      		dsi		INT0
            
            	; ClearIntReq(INT0);
00797:      		clr		io[INTREQ].b0
            
00798:      	rets
            ; }
            
            
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\DTXPLAYER.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\SPROM.ASM> Start=========================
            
            sfContReadByte:
            ; {
00799:      	AR=		P1.hh
0079A:      	sra		AR, 1
0079B:      	P1.hh=		AR
0079C:      	src		P1, 1
0079D:      	AR=		pm[P1]
0079E:      	if NC jmp	@sfcrw_label_1736
0079F:      	push		AR
007A0:      	AR=		P1.hh
007A1:      	slc		P1, 1
007A2:      	slc		AR, 1
007A3:      	P1.hh=		AR
007A4:      	AR=		pm[P1++]
007A5:      	pop		AR
007A6:      	xchg		AR
007A7:      	jmp		@sfcrw_label_1813
            @sfcrw_label_1736:
007A8:      	push		AR
007A9:      	AR=		P1.hh
007AA:      	slc		P1, 1
007AB:      	slc		AR, 1
007AC:      	P1.hh=		AR
007AD:      	AR=		pm[P1++]
007AE:      	pop		AR
            @sfcrw_label_1813:
007AF:      	AH=		0
007B0:      	rets
            ; }
            
            
            ; ~~~~~~ no word align !!
            
            SfContReadWord:
            ; {
007B1:      	AR=		P1.hh
007B2:      	sra		AR, 1
007B3:      	P1.hh=		AR
007B4:      	src		P1, 1
007B5:      	AR=		pm[P1++]
            	
007B6:      	push		AR
007B7:      	AR=		P1.hh
007B8:      	slc		P1, 1
007B9:      	slc		AR, 1
007BA:      	P1.hh=		AR
007BB:      	pop		AR
007BC:      	rets
            ; }
            
            
            ; --------------------------------------------
            
            macro	mSfContReadStart
            	AR=		rm[I1--]
            	P1=		rm[I1]
            	P1.hh=		AR
            endm
            
            
            macro	mSfContReadWord
            	PCH=		SfContReadWord
            	lcall		SfContReadWord
            endm
            
            
            macro	mSfContReadByte
            	PCH=		SfContReadByte
            	lcall		SfContReadByte
            endm
            
            
            macro mSfContReadStop
            	P1.hh=		0
            endm
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\SPROM.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\DTX_CSHELL-E.ASM> Start=========================
            
            
            _dtxDoEvent05EA2C8C:
007BD:      	PCH=		dtxDoEvent
007BE:      	lcall		dtxDoEvent
            L3F7E7BE2_0:
007BF:      	AX=		0
007C0:      	if NZ jmp	L3F7E7BE2_1
007C1:      	AX=		1
            L3F7E7BE2_1:
007C2:      	rets
            
            
            
            _dtxFindToneEntry12F3B4ED:
            ; DX:AX just right "flashadr"
007C3:      	AR=		AX
007C4:      	BX=		AR
007C5:      	AR=		DX
007C6:      	AX=		AR
007C7:      	PCH=		dtxFindToneEntry
007C8:      	lcall		dtxFindToneEntry
007C9:      	jmp		L3F7E7BE2_0
            
            
            _dtxPlaySong5B7DBDA5:
            ; AX - just right "index"
007CA:      	PCH=		dtxPlaySong
007CB:      	lcall		dtxPlaySong
007CC:      	jmp		L3F7E7BE2_0
            
            
            _dtxCheckSongEnd870A9712:
007CD:      	PCH=		dtxCheckSongEnd
007CE:      	lcall		dtxCheckSongEnd
007CF:      	jmp		L3F7E7BE2_0
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\DTX_CSHELL-E.ASM> End=========================
            
            ;=========================Include <DEPS\2E003DC5_GINIT.S.CODE.ASM> Start=========================
            ; 2E003DC5_ginit.s.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code(void)			
            ginit_code:
            ; //{
            ; //	ginit_code_F_467EBAA5_s();		
007D0:      	pch	= ginit_code_F_467EBAA5_s
007D1:      	lcall	ginit_code_F_467EBAA5_s
            ; //	ginit_code_global_6037E6D5_s();		
007D2:      	pch	= ginit_code_global_6037E6D5_s
007D3:      	lcall	ginit_code_global_6037E6D5_s
            ; //	ginit_code_keypad_0E0216C1_s();		
007D4:      	pch	= ginit_code_keypad_0E0216C1_s
007D5:      	lcall	ginit_code_keypad_0E0216C1_s
            ; //	ginit_code_led_376AFC9D_s();		
007D6:      	pch	= ginit_code_led_376AFC9D_s
007D7:      	lcall	ginit_code_led_376AFC9D_s
            ; //	ginit_code_data_0EBCA7F9_s();		
007D8:      	pch	= ginit_code_data_0EBCA7F9_s
007D9:      	lcall	ginit_code_data_0EBCA7F9_s
            ; //	ginit_code_dtx_3359D009_s();		
007DA:      	pch	= ginit_code_dtx_3359D009_s
007DB:      	lcall	ginit_code_dtx_3359D009_s
            ; //	return;					
007DC:      	rets
            ; //}
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\2E003DC5_GINIT.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> Start=========================
            
            
            ; ~~ CRT0 support functions
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GLOBALINIT(void)
            ; void sfx_LOCALINIT(void)
            ;
            ; in:
            ;     I1	- pointer to SRAM initial value
            ;     P1	- pointer to PROM initial data
            ;     CX	- total count (word)
            ;
            ; out:
            ;     none
            ;
            ; --------------------------------------------
            sfx_GLOBALINIT:
            sfx_LOCALINIT:
007DD:      	P1.hh=		0
007DE:      	jmp		@glinit_label_1409
            @glinit_loop_1409:
007DF:      	AR=		pm[P1++]
007E0:      	rm[I1++]=	AR
            @glinit_label_1409:
007E1:      	loop		@glinit_loop_1409
007E2:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MUL_AX_CX(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MUL_AX_CX:
            
007E3:      	AR=		AX
007E4:      	MX=		AR
007E5:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
007E6:      	MACOP=		3
007E7:      	MR=		MX * AR
            #endif
            
007E8:      	AR=		MR0
007E9:      	AX=		AR
007EA:      	AR=		MR1
007EB:      	DX=		AR
007EC:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMUL_AX_CX(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMUL_AX_CX:
            
007ED:      	AR=		AX
007EE:      	MX=		AR
007EF:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
007F0:      	MACOP=		0
007F1:      	MR=		MX * AR
            #endif
            
007F2:      	AR=		MR0
007F3:      	AX=		AR
007F4:      	AR=		MR1
007F5:      	DX=		AR
007F6:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMULLONG(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMULLONG:
007F7:      	AR=		rm[BP_SAVE]
007F8:      	push		AR
007F9:      	AR=		BP
007FA:      	rm[BP_SAVE]=	AR
007FB:      	AR=		AR - 3
007FC:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
007FD:      	AR=		CX
007FE:      	MX=		AR
007FF:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00800:      	MACOP=		3		; unsigned
00801:      	MR=		MX * AR
            #endif
            
00802:      	I1=		rm[BP_SAVE]
00803:      	AR=		2
00804:      	I1=		I1 - AR
00805:      	rm[I1++]=	MR0
00806:      	rm[I1++]=	MR1
00807:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
00808:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUS
            #else
00809:      	MACOP=		1		; mx:unsigned / my:signed
0080A:      	MR=		MX * AR
            #endif
            
0080B:      	AR=		rm[I1]
0080C:      	AR=		AR + MR0
0080D:      	rm[I1++]=	AR
0080E:      	AR=		rm[I1]
0080F:      	AR=		AR + MR1 + C
00810:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
00811:      	AR=		BX
00812:      	MX=		AR
00813:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULSU
            #else
00814:      	MACOP=		2		; mx:signed / my:unsigned
00815:      	MR=		MX * AR
            #endif
            
00816:      	AR=		rm[I1]
00817:      	AR=		AR + MR0
00818:      	rm[I1++]=	AR
00819:      	AR=		rm[I1]
0081A:      	AR=		AR + MR1 + C
0081B:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
0081C:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
0081D:      	MACOP=		0		; mx:signed / my:signed
0081E:      	MR=		MX * AR
            #endif
            
0081F:      	AR=		rm[I1]
00820:      	AR=		AR + MR0
00821:      	rm[I1]=		AR
            
00822:      	I1=		rm[BP_SAVE]
00823:      	CX=		rm[I1--]
00824:      	DX=		rm[I1--]
00825:      	AX=		rm[I1]
            
00826:      	AR=		3
00827:      	BP=		BP + AR
00828:      	pop		AR
00829:      	rm[BP_SAVE]=	AR
            
0082A:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MULLONG(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MULLONG:
0082B:      	AR=		rm[BP_SAVE]
0082C:      	push		AR
0082D:      	AR=		BP
0082E:      	rm[BP_SAVE]=	AR
0082F:      	AR=		AR - 3
00830:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
00831:      	AR=		CX
00832:      	MX=		AR
00833:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00834:      	MACOP=		3		; unsigned
00835:      	MR=		MX * AR
            #endif
            
00836:      	I1=		rm[BP_SAVE]
00837:      	AR=		2
00838:      	I1=		I1 - AR
00839:      	rm[I1++]=	MR0
0083A:      	rm[I1++]=	MR1
0083B:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
0083C:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
0083D:      	MR=		MX * AR
            #endif
            
0083E:      	AR=		rm[I1]
0083F:      	AR=		AR + MR0
00840:      	rm[I1++]=	AR
00841:      	AR=		rm[I1]
00842:      	AR=		AR + MR1 + C
00843:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
00844:      	AR=		BX
00845:      	MX=		AR
00846:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
00847:      	MR=		MX * AR
            #endif
            
00848:      	AR=		rm[I1]
00849:      	AR=		AR + MR0
0084A:      	rm[I1++]=	AR
0084B:      	AR=		rm[I1]
0084C:      	AR=		AR + MR1 + C
0084D:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
0084E:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
0084F:      	MR=		MX * AR
            #endif
            
00850:      	AR=		rm[I1]
00851:      	AR=		AR + MR0
00852:      	rm[I1]=		AR
            
00853:      	I1=		rm[BP_SAVE]
00854:      	CX=		rm[I1--]
00855:      	DX=		rm[I1--]
00856:      	AX=		rm[I1]
            
00857:      	AR=		3
00858:      	BP=		BP + AR
00859:      	pop		AR
0085A:      	rm[BP_SAVE]=	AR
            
0085B:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIV_AX_CX(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIV_AX_CX:
            	; unsigned int reste = 0;
0085C:      		DX=		0
            	; unsigned char count = 16;
0085D:      		R0=		16
            	; BOOL c;
            
            	; do
            	@divword_loop_1824:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
0085E:      			slz		AX, 1
            		; reste <<= 1;
0085F:      			slc		DX, 1
            
            		; if (c)
            		; {
            			; reste |= 1;
            		; }
            		@divword_label_1822:
            
            		; if (reste >= y)
00860:      			AR=		DX
00861:      			AR-=		CX
00862:      			AR=		0
00863:      			AR=		AR - 0 + C - 1
00864:      			if AN jmp	@divword_label_1823
            		; {
            			; reste -= y;
00865:      				AR=		CX
00866:      				DX=		DX - AR
            			; ~~ x <- (result = 1)
            			; x |= 1;
00867:      				set		AX.b0
            		; }
            		@divword_label_1823:
            
00868:      		R0--
00869:      		if NZ jmp	@divword_loop_1824
            	; }while (--count);
            
            	; return x;
0086A:      		rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIV_AX_CX(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIV_AX_CX:
            
            	; register int r;
            
            	; r = sfx_DIV_AX_CX((x < 0 ? -x : x), (y < 0 ? -y : y));
0086B:      		R1=		0
0086C:      		AR=		0
0086D:      		test		AX.b15
0086E:      		if ZR jmp	@divsword_label_1833
0086F:      			AX=		AR - AX
00870:      			set		R1.b0
            		@divsword_label_1833:
00871:      		test		CX.b15
00872:      		if ZR jmp	@divsword_label_1834
00873:      			CX=		AR - CX
00874:      			set		R1.b1
            		@divsword_label_1834:
00875:      		call		sfx_DIV_AX_CX
            
            	; if ((x < 0) ^ (y < 0))
00876:      		AR=		R1
00877:      		slz		AR, 1
00878:      		AR^=		R1
00879:      		test		AR.b1
0087A:      		if ZR jmp	@divsword_label_1835
            	; {
            		; return (0 - r);
0087B:      			AR=		0
0087C:      			AX=		AR - AX
0087D:      			DX=		AR - DX
            
            	; }
            	@divsword_label_1835:
            
            	; return r;
0087E:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIVLONG(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIVLONG:
            	; unsigned long reste = 0L;
0087F:      		R0=		0	; L
00880:      		R1=		0	; H
            	; unsigned char count = 32;
00881:      		R2=		32
            	; BOOL c;
            
            	; do
            	@divulong_loop_1723:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
00882:      			slz		AX, 1
00883:      			slc		DX, 1
            		; reste <<= 1;
00884:      			slc		R0, 1
00885:      			slc		R1, 1
            
            		; if (c)
            		; {
            			; reste |= 1L;
            		; }
            		@divulong_label_1726:
            
            		; if (reste >= y)
00886:      			AR=		R0
00887:      			AR-=		CX
00888:      			AR=		R1
00889:      			AR=		AR - BX + C - 1
0088A:      			if AN jmp	@divulong_label_1734
            		; {
            			; reste -= y;
0088B:      				AR=		CX
0088C:      				R0=		R0 - AR
0088D:      				AR=		BX
0088E:      				R1=		R1 - AR + C - 1
            			; ~~ x <- (result = 1)
            			; x |= 1L;
0088F:      				set		AX.b0
            		; }
            		@divulong_label_1734:
            
00890:      		R2--
00891:      		if NZ jmp	@divulong_loop_1723
            	; }while (--count);
            
            	; return x;
00892:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIVLONG(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     BX:DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIVLONG:
            	; long r;
            
            	; r = divulong((x < 0 ? -x : x), (y < 0 ? -y : y));
00893:      		R3=		0
00894:      		AR=		0
00895:      		test		DX.b15
00896:      		if ZR jmp	@divslong_label_1759
00897:      			AX=		AR - AX
00898:      			DX=		AR - DX + C - 1
00899:      			set		R3.b0
            		@divslong_label_1759:
0089A:      		test		BX.b15
0089B:      		if ZR jmp	@divslong_label_1800
0089C:      			CX=		AR - CX
0089D:      			BX=		AR - BX + C - 1
0089E:      			set		R3.b1
            		@divslong_label_1800:
0089F:      		call		sfx_DIVLONG
            
            	; if ((x < 0) ^ (y < 0))
008A0:      		AR=		R3
008A1:      		slz		AR, 1
008A2:      		AR^=		R3
008A3:      		test		AR.b1
008A4:      		if ZR jmp	@divslong_label_1807
            	; {
            		; return -r;
008A5:      			AR=		0
008A6:      			AX=		AR - AX
008A7:      			DX=		AR - DX + C - 1
008A8:      			R0=		AR - R0
008A9:      			R1=		AR - R1 + C - 1
            
            	; }
            	@divslong_label_1807:
            
            	; return r;
008AA:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MOD_AX_CX(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_MOD_AX_CX:
008AB:      	call		sfx_DIV_AX_CX
008AC:      	AR=		DX
008AD:      	AX=		AR
008AE:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMOD_AX_CX(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMOD_AX_CX:
008AF:      	call		sfx_IDIV_AX_CX
008B0:      	AR=		DX
008B1:      	AX=		AR
008B2:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MODLONG(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_MODLONG:
008B3:      	call		sfx_DIVLONG
008B4:      	AR=		R0
008B5:      	AX=		AR
008B6:      	AR=		R1
008B7:      	DX=		AR
008B8:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMODLONG(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMODLONG:
008B9:      	call		sfx_IDIVLONG
008BA:      	AR=		R0
008BB:      	AX=		AR
008BC:      	AR=		R1
008BD:      	DX=		AR
008BE:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG:
            	; AR=		CX
            	; AX=		AX + AR
            	; AR=		BX
            	; DX=		DX + AR + C
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG_BXCX_DXAX(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG_BXCX_DXAX:
            	; AR=		AX
            	; CX=		CX + AR
            	; AR=		DX
            	; BX=		BX + AR + C
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBLONG(void)
            ;
            ; note:
            ;     signed sub
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SUBLONG:
            	; AR=		CX
            	; AX=		AX - AR
            	; AR=		BX
            	; DX=		DX - AR + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDDIOFS(void)
            ;
            ; note:
            ;     add P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDDIOFS:
008BF:      	AR=		AX
008C0:      	P1=		P1 + AR
008C1:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDSIOFS(void)
            ;
            ; note:
            ;     add I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDSIOFS:
008C2:      	AR=		AX
008C3:      	I1=		I1 + AR
008C4:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDAXOFS(void)
            ;
            ; note:
            ;     add AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_ADDAXOFS:
008C5:      	AR=		CX
008C6:      	AX=		AX + AR
008C7:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBDIOFS(void)
            ;
            ; note:
            ;     sub P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBDIOFS:
008C8:      	AR=		AX
008C9:      	P1=		P1 - AR
008CA:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBSIOFS(void)
            ;
            ; note:
            ;     sub I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBSIOFS:
008CB:      	AR=		AX
008CC:      	I1=		I1 - AR
008CD:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBAXOFS(void)
            ;
            ; note:
            ;     sub AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_SUBAXOFS:
008CE:      	AR=		CX
008CF:      	AX=		AX + AR
008D0:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_DXAX(void)
            ;
            ; note:
            ;     load long data from PROM to DX:AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG:
            ; sfx_GETDILONG_DXAX:
            	; AX=		pm[P1++]
            	; DX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_BXCX(void)
            ;
            ; note:
            ;     load long data from PROM to BX:CX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG_BXCX:
            	; CX=		pm[P1++]
            	; BX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_DXAX(void)
            ; void sfx_GETSILONG_DXAX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to DX:AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG:
            ; sfx_GETSILONG_D:
            ; sfx_GETSILONG_DXAX:
            ; sfx_GETSILONG_DXAX_D:
            	; AX=		rm[I1++]
            	; DX=		rm[I1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_BXCX(void)
            ; void sfx_GETSILONG_BXCX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to BX:CX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG_BXCX:
            ; sfx_GETSILONG_BXCX_D:
            	; CX=		rm[I1++]
            	; BX=		rm[I1--]
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ANDLONG(void)
            ;
            ; note:
            ;     AND two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ANDLONG:
            	; AR=		CX
            	; AX=		AX & AR
            	; AR=		BX
            	; DX=		DX & AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ORLONG(void)
            ;
            ; note:
            ;     OR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ORLONG:
            	; AR=		CX
            	; AX=		AX | AR
            	; AR=		BX
            	; DX=		DX | AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XORLONG(void)
            ;
            ; note:
            ;     XOR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_XORLONG:
            	; AR=		CX
            	; AX=		AX ^ AR
            	; AR=		BX
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHL_AX_CX(void)
            ;
            ; note:
            ;     left shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHL_AX_CX:
            	; jmp		@shlac_label_1653
            ; @shlac_loop_1653:
            	; slz		AX, 1
            ; @shlac_label_1653:
            	; loop		@shlac_loop_1653
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SHLLONG(void)
            ;
            ; note:
            ;     left shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHLLONG:
            	; jmp		@shllong_label_1653
            ; @shllong_loop_1653:
            	; slz		AX, 1
            	; slc		DX, 1
            ; @shllong_label_1653:
            	; loop		@shllong_loop_1653
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX_CX(void)
            ;
            ; note:
            ;     unsigned right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX_CX:
            	; jmp		@shrac_label_1657
            ; @shrac_loop_1657:
            	; clr		C
            	; src		AX, 1
            ; @shrac_label_1657:
            	; loop		@shrac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX_CX(void)
            ;
            ; note:
            ;     signed right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX_CX:
            	; jmp		@sarac_label_1657
            ; @sarac_loop_1657:
            	; sra		AX, 1
            ; @sarac_label_1657:
            	; loop		@sarac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SARLONG(void)
            ;
            ; note:
            ;     signed right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SARLONG:
            	; jmp		@sarlong_label_1657
            ; @sarlong_loop_1657:
            	; sra		DX, 1
            	; src		AX, 1
            ; @sarlong_label_1657:
            	; loop		@sarlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHRLONG(void)
            ;
            ; note:
            ;     unsigned right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- ulong data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHRLONG:
            	; jmp		@shrlong_label_1657
            ; @shrlong_loop_1657:
            	; clr		C
            	; src		DX, 1
            	; src		AX, 1
            ; @shrlong_label_1657:
            	; loop		@shrlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX(void)
            ;
            ; note:
            ;     unsigned right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX:
            	; clr		C
            	; src		AX, 1
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX(void)
            ;
            ; note:
            ;     signed right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX:
            	; sra		AX, 1
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG(void)
            ; void sfx_STORSILONG_D(void)		; for function's parameter
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG:
            ; sfx_STORSILONG_D:
            	; rm[I1++]=	AX
            	; rm[I1--]=	DX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG_BXCX(void)
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG_BXCX:
            	; rm[I1++]=	CX
            	; rm[I1--]=	BX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG:
008D1:      	pm[P1++]=	AX
008D2:      	pm[P1--]=	DX
008D3:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG_BXCX:
008D4:      	pm[P1++]=	CX
008D5:      	pm[P1--]=	BX
008D6:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CX to BX
            ;
            ; in:
            ;     CX	- signed short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_CX:
            ; sfx_INT2ULONG_CX:
            	; BX=		0
            	; test		CX.b15
            	; if ZR jmp	@i2lcx_label_1756
            	; BX=		-1
            ; @i2lcx_label_1756:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_CX(void)
            ;
            ; note:
            ;     convert short unsigned value CX to long (BX:CX)
            ;
            ; in:
            ;     CX	- unsigned short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_CX:
            ; sfx_UINT2ULONG_CX:
            	; BX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CL to BX:CH
            ;
            ; in:
            ;     CX	- signed char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_CX:
008D7:      	BX=		0
008D8:      	CX.h=		0
008D9:      	test		CX.b7
008DA:      	if ZR jmp	@c2lcx_label_1800
008DB:      	CX.h=		0xFF
008DC:      	BX=		-1
            @c2lcx_label_1800:
008DD:      	rets
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_CX(void)
            ;
            ; note:
            ;     convert unsigned char value CL to long (BX:CX)
            ;
            ; in:
            ;     CL	- unsigned char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_CX:
            	; CX.h=		0
            	; BX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AX to DX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_AX:
            ; sfx_INT2ULONG_AX:
            	; DX=		0
            	; test		AX.b15
            	; if ZR jmp	@i2lax_label_1756
            	; DX=		-1
            ; @i2lax_label_1756:
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_AX(void)
            ;
            ; note:
            ;     convert short unsigned value AX to long (DX:AX)
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_AX:
            ; sfx_UINT2ULONG_AX:
            	; DX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AL to DX:AH
            ;
            ; in:
            ;     AX	- signed char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_AX:
008DE:      	DX=		0
008DF:      	AX.h=		0
008E0:      	test		AX.b7
008E1:      	if ZR jmp	@c2lax_label_1800
008E2:      	AX.h=		0xFF
008E3:      	DX=		-1
            @c2lax_label_1800:
008E4:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_AX(void)
            ;
            ; note:
            ;     convert unsigned char value AL to long (DX:AX)
            ;
            ; in:
            ;     AL	- unsigned char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_AX:
            	; AX.h=		0
            	; DX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CALL_BY_AX(void)
            ;
            ; note:
            ;     call sub routine in AX (address)
            ;
            ; in:
            ;     AX	- sub routine address
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_CALL_BY_AX:
            	; AR=		AX
            	; P1=		AR
            	; P1.hh=		0
            	; fjmp		pm[P1]
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHG_AX_CX(void)
            ;
            ; note:
            ;     exchange AX CX value
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; result:
            ;     AX <-> CX
            ;
            ; --------------------------------------------
            ; sfx_XCHG_AX_CX:
            	; push		AX
            	; push		CX
            	; pop		AX
            	; pop		CX
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHGLONG(void)
            ;
            ; note:
            ;     exchange DX:AX BX:CX value
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; result:
            ;     DX:AX <-> BX:CX
            ;
            ; --------------------------------------------
            sfx_XCHGLONG:
008E5:      	push		AX
008E6:      	push		CX
008E7:      	pop		AX
008E8:      	pop		CX
008E9:      	push		DX
008EA:      	push		BX
008EB:      	pop		DX
008EC:      	pop		BX
008ED:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEG_AX(void)
            ;
            ; note:
            ;     negative AX
            ;
            ; in:
            ;     AX	- operator 1
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEG_AX:
            	; AR=		0
            	; AX=		AR - AX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEGLONG(void)
            ;
            ; note:
            ;     negative DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEGLONG:
            	; AR=		0
            	; AX=		AR - AX
            	; DX=		AR - DX + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOT_AX(void)
            ;
            ; note:
            ;     not AX
            ;
            ; in:
            ;     AX	- operator
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOT_AX:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOTLONG(void)
            ;
            ; note:
            ;     not DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOTLONG:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOT_AX(void)
            ;
            ; note:
            ;     logical NOT
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_LOGNOT_AX:
            	;; x86 code
            	;;   neg AX
            	;;   sbb AX,AX
            	;;   inc AX
            	; AR=		0
            	; AR=		AR - AX
            	; AX=		AR
            	; AX=		AR - AX + C - 1
            	; AX++
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOTLONG(void)
            ;
            ; note:
            ;     logical NOT (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            sfx_LOGNOTLONG:
            	; x86 code
            	;   neg AX
            	;   sbb AX,AX
            	;   inc AX
008EE:      	AR=		DX
008EF:      	DX=		0
008F0:      	AR=		AR | AX
008F1:      	AX=		1
008F2:      	if ZR jmp	@longnotl_label_1120
008F3:      	AX=		0
            @longnotl_label_1120:
008F4:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOL_AX(void)
            ;
            ; note:
            ;     logical BOOL
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOL_AX:
            	;; x86 code
            	;;   neg ax
            	;;   sbb ax,ax
            	;;   neg ax
            	; AR=		AX
            	; AX=		0
            	; if ZR jmp	@boolax_label_1758
            	; AX=		1
            ; @boolax_label_1758:
            	; rets
            	
            	; AR=		-1
            	; AR=		AR + AX
            	; AX=		0
            	; AX += C
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOLLONG(void)
            ;
            ; note:
            ;     logical BOOL (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOLLONG:
            	; AR=		DX
            	; DX=		0
            	; AR=		AR | AX
            	; AX=		0
            	; if ZR jmp	@boollong_label_1801
            	; AX=		1
            ; @boollong_label_1801:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INITSISTOR(void)
            ;
            ; note:
            ;     for used in global/local variable initial
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     I1 + 1
            ;
            ; --------------------------------------------
            ; sfx_INITSISTOR:
            	; rm[I1++]=	AX
            	; rets
            
            ; --------------------------------------------
            
            ; sfx_INITSISTORLONG:
            	; rm[I1++]=	AX
            	; rm[I1++]=	DX
            	; rets
            
            
            ; ~~ condition assistant functions ~~
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; JNE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            sfx_CMP_AX_CX_U_JNE:
008F5:      	DX=		0
008F6:      	BX=		0
            sfx_CMPLONG_JNE:
008F7:      	AR=		CX
008F8:      	AX=		AX - AR
008F9:      	AR=		BX
008FA:      	AR=		DX - AR + C - 1
008FB:      	AR=		AR | AX
008FC:      	if EQ jmp	@sfx_cl_jne_f
008FD:      	set		Z		; true
008FE:      	rets
            @sfx_cl_jne_f:
008FF:      	clr		Z		; false
00900:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JNE:
00901:      	DX=		0
00902:      	BX=		0
            sfx_CMPLONG_BCDA_JNE:
00903:      	AR=		AX
00904:      	CX=		CX - AR
00905:      	AR=		DX
00906:      	AR=		BX - AR + C - 1
00907:      	AR=		AR | CX
00908:      	if EQ jmp	@sfx_clbcda_jne_f
00909:      	set		Z		; true
0090A:      	rets
            @sfx_clbcda_jne_f:
0090B:      	clr		Z		; false
0090C:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JNE:
0090D:      	AR=		CX
0090E:      	SF=		AX - AR
0090F:      	if EQ jmp	@sfx_ac_jne_f
00910:      	set		Z
00911:      	rets
            @sfx_ac_jne_f:
00912:      	clr		Z
00913:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JNE:
00914:      	AR=		AX
00915:      	SF=		CX - AR
00916:      	if EQ jmp	@sfx_ca_jne_f
00917:      	set		Z
00918:      	rets
            @sfx_ca_jne_f:
00919:      	clr		Z
0091A:      	rets
            
            
            
            ; JE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            
            
            sfx_CMP_AX_CX_U_JE:
0091B:      	DX=		0
0091C:      	BX=		0
            sfx_CMPLONG_JE:
0091D:      	AR=		CX
0091E:      	AX=		AX - AR
0091F:      	AR=		BX
00920:      	AR=		DX - AR + C - 1
00921:      	AR=		AR | AX
00922:      	if NE jmp	@sfx_cl_jz_f
00923:      	set		Z		; true
00924:      	rets
            @sfx_cl_jz_f:
00925:      	clr		Z		; false
00926:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JE:
00927:      	DX=		0
00928:      	BX=		0
            sfx_CMPLONG_BCDA_JE:
00929:      	AR=		AX
0092A:      	CX=		CX - AR
0092B:      	AR=		DX
0092C:      	AR=		BX - AR + C - 1
0092D:      	AR=		AR | CX
0092E:      	if NE jmp	@sfx_clbcda_jz_f
0092F:      	set		Z		; true
00930:      	rets
            @sfx_clbcda_jz_f:
00931:      	clr		Z		; false
00932:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JE:
00933:      	AR=		CX
00934:      	SF=		AX - AR
00935:      	if NE jmp	@sfx_ac_je_f
00936:      	set		Z
00937:      	rets
            @sfx_ac_je_f:
00938:      	clr		Z
00939:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JE:
0093A:      	AR=		AX
0093B:      	SF=		CX - AR
0093C:      	if NE jmp	@sfx_ca_je_f
0093D:      	set		Z
0093E:      	rets
            @sfx_ca_je_f:
0093F:      	clr		Z
00940:      	rets
            
            
            
            ; JG group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; A - above (unsigned)
            ; G - greater (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JA:
            sfx_CMP_AX_CX_JA:
00941:      	DX=		0
00942:      	BX=		0
            sfx_CMPLONG_JG:
00943:      	AR=		CX
00944:      	AX=		AX - AR
00945:      	AR=		BX
00946:      	AR=		DX - AR + C - 1
00947:      	if AN jmp	@sfx_cl_jg_f
            
            	; exclude EQU condition
00948:      	AR=		AR | AX
00949:      	if ZR jmp	@sfx_cl_jg_f
            
0094A:      	set		Z		; true
0094B:      	rets
            @sfx_cl_jg_f:
0094C:      	clr		Z		; false
0094D:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JA:
0094E:      	AR=		CX
0094F:      	AX=		AX - AR
00950:      	AR=		BX
00951:      	DX=		DX - AR + C - 1
00952:      	AR=		0
00953:      	AR=		AR - 0 + C - 1
00954:      	if AN jmp	@sfx_cl_jg_f
            
00955:      	AR=		AR | DX		; exclude EQU condition
00956:      	AR=		AR | AX
00957:      	if ZR jmp	@sfx_cl_jg_f
            
00958:      	set		Z		; true
00959:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JA:
            sfx_CMP_CX_AX_JA:
0095A:      	DX=		0
0095B:      	BX=		0
            sfx_CMPLONG_BCDA_JG:
0095C:      	AR=		AX
0095D:      	CX=		CX - AR
0095E:      	AR=		DX
0095F:      	AR=		BX - AR + C - 1
00960:      	if AN jmp	@sfx_clbcda_jg_f
            
00961:      	AR=		AR | CX		; exclude EQU condition
00962:      	if ZR jmp	@sfx_clbcda_jg_f
            
00963:      	set		Z		; true
00964:      	rets
            @sfx_clbcda_jg_f:
00965:      	clr		Z		; false
00966:      	rets
            
            ; ~~---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JA:
00967:      	AR=		AX
00968:      	CX=		CX - AR
00969:      	AR=		DX
0096A:      	BX=		BX - AR + C - 1
0096B:      	AR=		0
0096C:      	AR=		AR - 0 + C - 1
0096D:      	if AN jmp	@sfx_clbcda_jg_f
            
0096E:      	AR=		AR | BX		; exclude EQU condition
0096F:      	AR=		AR | CX
00970:      	if ZR jmp	@sfx_clbcda_jg_f
            
00971:      	set		Z		; true
00972:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JG:
00973:      	AR=		CX
00974:      	SF=		AX - AR
00975:      	if LE jmp	@sfx_cmp_ac_jg_f
00976:      	set		Z
00977:      	rets
            @sfx_cmp_ac_jg_f:
00978:      	clr		Z
00979:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JG:
0097A:      	AR=		AX
0097B:      	SF=		CX - AR
0097C:      	if LE jmp	@sfx_cmp_ca_jg_f
0097D:      	set		Z
0097E:      	rets
            @sfx_cmp_ca_jg_f:
0097F:      	clr		Z
00980:      	rets
            
            
            ; JGE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JAE:
            sfx_CMP_AX_CX_JAE:
00981:      	DX=		0
00982:      	BX=		0
            sfx_CMPLONG_JGE:
00983:      	AR=		CX
00984:      	AX=		AX - AR
00985:      	AR=		BX
00986:      	DX=		DX - AR + C - 1
00987:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
            
00988:      	set		Z		; true
00989:      	rets
            @sfx_cl_jge_f:
0098A:      	clr		Z		; false
0098B:      	rets
            
            ; ~~-----------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JAE:
0098C:      	AR=		CX
0098D:      	AX=		AX - AR
0098E:      	AR=		BX
0098F:      	DX=		DX - AR + C - 1
00990:      	AR=		0
00991:      	AR=		AR - 0 + C - 1
00992:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
00993:      	set		Z		; true
00994:      	rets
            
            ; ---------
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JAE:
            sfx_CMP_CX_AX_JAE:
00995:      	DX=		0
00996:      	BX=		0
            sfx_CMPLONG_BCDA_JGE:
00997:      	AR=		AX
00998:      	CX=		CX - AR
00999:      	AR=		DX
0099A:      	BX=		BX - AR + C - 1
0099B:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
            
0099C:      	set		Z		; true
0099D:      	rets
            @sfx_clbcda_jge_f:
0099E:      	clr		Z		; false
0099F:      	rets
            
            ; ---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JAE:
009A0:      	AR=		AX
009A1:      	CX=		CX - AR
009A2:      	AR=		DX
009A3:      	BX=		BX - AR + C - 1
009A4:      	AR=		0
009A5:      	AR=		AR - 0 + C - 1
009A6:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
009A7:      	set		Z		; true
009A8:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JGE:
009A9:      	AR=		CX
009AA:      	SF=		AX - AR
009AB:      	if AN jmp	@sfx_cmp_ac_jge_f
009AC:      	set		Z
009AD:      	rets
            @sfx_cmp_ac_jge_f:
009AE:      	clr		Z
009AF:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JGE:
009B0:      	AR=		AX
009B1:      	SF=		CX - AR
009B2:      	if AN jmp	@sfx_cmp_ca_jge_f
009B3:      	set		Z
009B4:      	rets
            @sfx_cmp_ca_jge_f:
009B5:      	clr		Z
009B6:      	rets
            
            
            ; JL group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; B - below (unsigned)
            ; L - less (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JB:
            sfx_CMP_AX_CX_JB:
009B7:      	DX=		0
009B8:      	BX=		0
            sfx_CMPLONG_JL:
009B9:      	AR=		CX
009BA:      	AX=		AX - AR
009BB:      	AR=		BX
009BC:      	AR=		DX - AR + C - 1
009BD:      	if AN jmp	@sfx_cl_jl_chk
            
            @sfx_cl_jl_f:
009BE:      	clr		Z		; false
009BF:      	rets
            
            @sfx_cl_jl_chk:
009C0:      	AR=		AR | AX		; exclude EQU condition
009C1:      	if ZR jmp	@sfx_cl_jl_f
009C2:      	set		Z
009C3:      	rets
            
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JB:
009C4:      	AR=		CX
009C5:      	AX=		AX - AR
009C6:      	AR=		BX
009C7:      	DX=		DX - AR + C - 1
009C8:      	AR=		0
009C9:      	AR=		AR - 0 + C - 1
009CA:      	if AN jmp	@sfx_cl_jb_chk
            
            @sfx_cl_jb_f:
009CB:      	clr		Z		; false
009CC:      	rets
            
            @sfx_cl_jb_chk:
009CD:      	AR=		AR | DX
009CE:      	AR=		AR | AX		; exclude EQU condition
009CF:      	if ZR jmp	@sfx_cl_jb_f
009D0:      	set		Z
009D1:      	rets
            
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JB:
            sfx_CMP_CX_AX_JB:
009D2:      	DX=		0
009D3:      	BX=		0
            sfx_CMPLONG_BCDA_JL:
009D4:      	AR=		AX
009D5:      	CX=		CX - AR
009D6:      	AR=		DX
009D7:      	AR=		BX - AR + C - 1
009D8:      	if AN jmp	@sfx_clbcda_jl_chk
            
            @sfx_clbcda_jl_f:
009D9:      	clr		Z		; false
009DA:      	rets
            
            @sfx_clbcda_jl_chk:
009DB:      	AR=		AR | CX		; exclude EQU condition
009DC:      	if ZR jmp	@sfx_clbcda_jl_f
009DD:      	set		Z		; true
009DE:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JB:
009DF:      	AR=		AX
009E0:      	CX=		CX - AR
009E1:      	AR=		DX
009E2:      	BX=		BX - AR + C - 1
009E3:      	AR=		0
009E4:      	AR=		AR - 0 + C - 1
009E5:      	if AN jmp	@sfx_clbcda_jb_chk
            
            @sfx_clbcda_jb_f:
009E6:      	clr		Z		; false
009E7:      	rets
            
            @sfx_clbcda_jb_chk:
009E8:      	AR=		AR | CX
009E9:      	AR=		AR | BX
009EA:      	if ZR jmp	@sfx_clbcda_jb_f
009EB:      	set		Z		; true
009EC:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JL:
009ED:      	AR=		CX
009EE:      	SF=		AX - AR
009EF:      	if GE jmp	@sfx_cmp_ac_jl_f
009F0:      	set		Z
009F1:      	rets
            @sfx_cmp_ac_jl_f:
009F2:      	clr		Z
009F3:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JL:
009F4:      	AR=		AX
009F5:      	SF=		CX - AR
009F6:      	if GE jmp	@sfx_cmp_ca_jl_f
009F7:      	set		Z
009F8:      	rets
            @sfx_cmp_ca_jl_f:
009F9:      	clr		Z
009FA:      	rets
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JBE:
            sfx_CMP_AX_CX_JBE:
009FB:      	DX=		0
009FC:      	BX=		0
            sfx_CMPLONG_JLE:
009FD:      	AR=		CX
009FE:      	AX=		AX - AR
009FF:      	AR=		BX
00A00:      	AR=		DX - AR + C - 1
00A01:      	if AN jmp	@sfx_cl_jle_t
            
00A02:      	AR=		AR | AX		; include EQU condition
00A03:      	if ZR jmp	@sfx_cl_jle_t
            
00A04:      	clr		Z		; false
00A05:      	rets
            @sfx_cl_jle_t:
00A06:      	set		Z		; true
00A07:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JBE:
00A08:      	AR=		CX
00A09:      	AX=		AX - AR
00A0A:      	AR=		BX
00A0B:      	DX=		DX - AR + C - 1
00A0C:      	AR=		0
00A0D:      	AR=		AR - 0 + C - 1
00A0E:      	if AN jmp	@sfx_cl_jle_t
            
00A0F:      	AR=		AR | DX
00A10:      	AR=		AR | AX
00A11:      	if ZR jmp	@sfx_cl_jle_t
            
00A12:      	clr		Z		; false
00A13:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JBE:
            sfx_CMP_CX_AX_JBE:
00A14:      	DX=		0
00A15:      	BX=		0
            sfx_CMPLONG_BCDA_JLE:
00A16:      	AR=		AX
00A17:      	CX=		CX - AR
00A18:      	AR=		DX
00A19:      	AR=		BX - AR + C - 1
00A1A:      	if AN jmp	@sfx_clbcda_jle_t
            
00A1B:      	AR=		AR | CX		; include EQU condition
00A1C:      	if ZR jmp	@sfx_clbcda_jle_t
            
00A1D:      	clr		Z		; false
00A1E:      	rets
            @sfx_clbcda_jle_t:
00A1F:      	set		Z		; true
00A20:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JBE:
00A21:      	AR=		AX
00A22:      	CX=		CX - AR
00A23:      	AR=		DX
00A24:      	BX=		BX - AR + C - 1
00A25:      	AR=		0
00A26:      	AR=		AR - 0 + C - 1
00A27:      	if AN jmp	@sfx_clbcda_jle_t
            
00A28:      	AR=		AR | BX
00A29:      	AR=		AR | CX
00A2A:      	if ZR jmp	@sfx_clbcda_jle_t
            
00A2B:      	clr		Z		; false
00A2C:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JLE:
00A2D:      	AR=		CX
00A2E:      	SF=		AX - AR
00A2F:      	if LE jmp	@sfx_cmp_ac_jl_t
00A30:      	clr		Z
00A31:      	rets
            @sfx_cmp_ac_jl_t:
00A32:      	set		Z
00A33:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JLE:
00A34:      	AR=		AX
00A35:      	SF=		CX - AR
00A36:      	if LE jmp	@sfx_cmp_ca_jl_t
00A37:      	clr		Z
00A38:      	rets
            @sfx_cmp_ca_jl_t:
00A39:      	set		Z
00A3A:      	rets
            
            
            ; ~!~ bit-field support
            
            @sfx_ortable_0:
00A3B:      	DW 0xFFFE
            @sfx_ortable_1:
00A3C:      	DW 0xFFFC
            @sfx_ortable_2:
00A3D:      	DW 0xFFF8
            @sfx_ortable_3:
00A3E:      	DW 0xFFF0
            @sfx_ortable_4:
00A3F:      	DW 0xFFE0
            @sfx_ortable_5:
00A40:      	DW 0xFFC0
            @sfx_ortable_6:
00A41:      	DW 0xFF80
            @sfx_ortable_7:
00A42:      	DW 0xFF00
            @sfx_ortable_8:
00A43:      	DW 0xFE00
            @sfx_ortable_9:
00A44:      	DW 0xFC00
            @sfx_ortable_10:
00A45:      	DW 0xF800
            @sfx_ortable_11:
00A46:      	DW 0xF000
            @sfx_ortable_12:
00A47:      	DW 0xE000
            @sfx_ortable_13:
00A48:      	DW 0xC000
            @sfx_ortable_14:
00A49:      	DW 0x8000
            
            ; ~!~
            
            @sfx_orhigh:
00A4A:      	AR=		pm[P1]
00A4B:      	DX=		DX | AR
00A4C:      	rets
            
            @sfx_orhigh_dx:
00A4D:      	DX=		-1
            @sfx_orlow:
00A4E:      	AR=		pm[P1]
00A4F:      	AX=		AX | AR
            @sfx_sextw_rets:
00A50:      	rets
            
            ; ~!~ signed short
            
            sfx_SignExtW0:
00A51:      	P1=		#@sfx_ortable_0
00A54:      	test		AX.b0
00A55:      	if ZR jmp	@sfx_sextw_rets
00A56:      	jmp		@sfx_orlow
            
            sfx_SignExtW1:
00A57:      	P1=		#@sfx_ortable_1
00A5A:      	test		AX.b1
00A5B:      	if ZR jmp	@sfx_sextw_rets
00A5C:      	jmp		@sfx_orlow
            
            sfx_SignExtW2:
00A5D:      	P1=		#@sfx_ortable_2
00A60:      	test		AX.b2
00A61:      	if ZR jmp	@sfx_sextw_rets
00A62:      	jmp		@sfx_orlow
            
            sfx_SignExtW3:
00A63:      	P1=		#@sfx_ortable_3
00A66:      	test		AX.b3
00A67:      	if ZR jmp	@sfx_sextw_rets
00A68:      	jmp		@sfx_orlow
            
            sfx_SignExtW4:
00A69:      	P1=		#@sfx_ortable_4
00A6C:      	test		AX.b4
00A6D:      	if ZR jmp	@sfx_sextw_rets
00A6E:      	jmp		@sfx_orlow
            
            sfx_SignExtW5:
00A6F:      	P1=		#@sfx_ortable_5
00A72:      	test		AX.b5
00A73:      	if ZR jmp	@sfx_sextw_rets
00A74:      	jmp		@sfx_orlow
            
            sfx_SignExtW6:
00A75:      	P1=		#@sfx_ortable_6
00A78:      	test		AX.b6
00A79:      	if ZR jmp	@sfx_sextw_rets
00A7A:      	jmp		@sfx_orlow
            
            sfx_SignExtW7:
00A7B:      	P1=		#@sfx_ortable_7
00A7E:      	test		AX.b7
00A7F:      	if ZR jmp	@sfx_sextw_rets
00A80:      	jmp		@sfx_orlow
            
            sfx_SignExtW8:
00A81:      	P1=		#@sfx_ortable_8
00A84:      	test		AX.b8
00A85:      	if ZR jmp	@sfx_sextw_rets
00A86:      	jmp		@sfx_orlow
            
            sfx_SignExtW9:
00A87:      	P1=		#@sfx_ortable_9
00A8A:      	test		AX.b9
00A8B:      	if ZR jmp	@sfx_sextw_rets
00A8C:      	jmp		@sfx_orlow
            
            sfx_SignExtW10:
00A8D:      	P1=		#@sfx_ortable_10
00A90:      	test		AX.b10
00A91:      	if ZR jmp	@sfx_sextw_rets
00A92:      	jmp		@sfx_orlow
            
            sfx_SignExtW11:
00A93:      	P1=		#@sfx_ortable_11
00A96:      	test		AX.b11
00A97:      	if ZR jmp	@sfx_sextw_rets
00A98:      	jmp		@sfx_orlow
            
            sfx_SignExtW12:
00A99:      	P1=		#@sfx_ortable_12
00A9C:      	test		AX.b12
00A9D:      	if ZR jmp	@sfx_sextw_rets
00A9E:      	jmp		@sfx_orlow
            
            sfx_SignExtW13:
00A9F:      	P1=		#@sfx_ortable_13
00AA2:      	test		AX.b13
00AA3:      	if ZR jmp	@sfx_sextw_rets
00AA4:      	jmp		@sfx_orlow
            
            sfx_SignExtW14:
00AA5:      	P1=		#@sfx_ortable_14
00AA8:      	test		AX.b14
00AA9:      	if ZR jmp	@sfx_sextw_rets
00AAA:      	jmp		@sfx_orlow
            
            ; ~!~ signed long
            
            sfx_SignExtL0:
00AAB:      	P1=		#@sfx_ortable_0
00AAE:      	test		AX.b0
00AAF:      	if ZR jmp	@sfx_sextw_rets
00AB0:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL1:
00AB1:      	P1=		#@sfx_ortable_1
00AB4:      	test		AX.b1
00AB5:      	if ZR jmp	@sfx_sextw_rets
00AB6:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL2:
00AB7:      	P1=		#@sfx_ortable_2
00ABA:      	test		AX.b2
00ABB:      	if ZR jmp	@sfx_sextw_rets
00ABC:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL3:
00ABD:      	P1=		#@sfx_ortable_3
00AC0:      	test		AX.b3
00AC1:      	if ZR jmp	@sfx_sextw_rets
00AC2:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL4:
00AC3:      	P1=		#@sfx_ortable_4
00AC6:      	test		AX.b4
00AC7:      	if ZR jmp	@sfx_sextw_rets
00AC8:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL5:
00AC9:      	P1=		#@sfx_ortable_5
00ACC:      	test		AX.b5
00ACD:      	if ZR jmp	@sfx_sextw_rets
00ACE:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL6:
00ACF:      	P1=		#@sfx_ortable_6
00AD2:      	test		AX.b6
00AD3:      	if ZR jmp	@sfx_sextw_rets
00AD4:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL7:
00AD5:      	P1=		#@sfx_ortable_7
00AD8:      	test		AX.b7
00AD9:      	if ZR jmp	@sfx_sextw_rets
00ADA:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL8:
00ADB:      	P1=		#@sfx_ortable_8
00ADE:      	test		AX.b8
00ADF:      	if ZR jmp	@sfx_sextw_rets
00AE0:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL9:
00AE1:      	P1=		#@sfx_ortable_9
00AE4:      	test		AX.b9
00AE5:      	if ZR jmp	@sfx_sextw_rets
00AE6:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL10:
00AE7:      	P1=		#@sfx_ortable_10
00AEA:      	test		AX.b10
00AEB:      	if ZR jmp	@sfx_sextw_rets
00AEC:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL11:
00AED:      	P1=		#@sfx_ortable_11
00AF0:      	test		AX.b11
00AF1:      	if ZR jmp	@sfx_sextw_rets
00AF2:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL12:
00AF3:      	P1=		#@sfx_ortable_12
00AF6:      	test		AX.b12
00AF7:      	if ZR jmp	@sfx_sextw_rets
00AF8:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL13:
00AF9:      	P1=		#@sfx_ortable_13
00AFC:      	test		AX.b13
00AFD:      	if ZR jmp	@sfx_sextw_rets
00AFE:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL14:
00AFF:      	P1=		#@sfx_ortable_14
00B02:      	test		AX.b14
00B03:      	if ZR jmp	@sfx_sextw_rets
00B04:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL15:
00B05:      	test		AX.b15
00B06:      	if ZR jmp	@sfx_sextw_rets
00B07:      	DX=		-1
00B08:      	rets
            
            sfx_SignExtL16:
00B09:      	P1=		#@sfx_ortable_0
00B0C:      	test		DX.b0
00B0D:      	if ZR jmp	@sfx_sextw_rets
00B0E:      	jmp		@sfx_orhigh
            
            sfx_SignExtL17:
00B0F:      	P1=		#@sfx_ortable_1
00B12:      	test		DX.b1
00B13:      	if ZR jmp	@sfx_sextw_rets
00B14:      	jmp		@sfx_orhigh
            
            sfx_SignExtL18:
00B15:      	P1=		#@sfx_ortable_2
00B18:      	test		DX.b2
00B19:      	if ZR jmp	@sfx_sextw_rets
00B1A:      	jmp		@sfx_orhigh
            
            sfx_SignExtL19:
00B1B:      	P1=		#@sfx_ortable_3
00B1E:      	test		DX.b3
00B1F:      	if ZR jmp	@sfx_sextw_rets
00B20:      	jmp		@sfx_orhigh
            
            sfx_SignExtL20:
00B21:      	P1=		#@sfx_ortable_4
00B24:      	test		DX.b4
00B25:      	if ZR jmp	@sfx_sextw_rets
00B26:      	jmp		@sfx_orhigh
            
            sfx_SignExtL21:
00B27:      	P1=		#@sfx_ortable_5
00B2A:      	test		DX.b5
00B2B:      	if ZR jmp	@sfx_sextw_rets
00B2C:      	jmp		@sfx_orhigh
            
            sfx_SignExtL22:
00B2D:      	P1=		#@sfx_ortable_6
00B30:      	test		DX.b6
00B31:      	if ZR jmp	@sfx_sextw_rets
00B32:      	jmp		@sfx_orhigh
            
            sfx_SignExtL23:
00B33:      	P1=		#@sfx_ortable_7
00B36:      	test		DX.b7
00B37:      	if ZR jmp	@sfx_sextw_rets
00B38:      	jmp		@sfx_orhigh
            
            sfx_SignExtL24:
00B39:      	P1=		#@sfx_ortable_8
00B3C:      	test		DX.b8
00B3D:      	if ZR jmp	@sfx_sextw_rets
00B3E:      	jmp		@sfx_orhigh
            
            sfx_SignExtL25:
00B3F:      	P1=		#@sfx_ortable_9
00B42:      	test		DX.b9
00B43:      	if ZR jmp	@sfx_sextw_rets
00B44:      	jmp		@sfx_orhigh
            
            sfx_SignExtL26:
00B45:      	P1=		#@sfx_ortable_10
00B48:      	test		DX.b10
00B49:      	if ZR jmp	@sfx_sextw_rets
00B4A:      	jmp		@sfx_orhigh
            
            sfx_SignExtL27:
00B4B:      	P1=		#@sfx_ortable_11
00B4E:      	test		DX.b11
00B4F:      	if ZR jmp	@sfx_sextw_rets
00B50:      	jmp		@sfx_orhigh
            
            sfx_SignExtL28:
00B51:      	P1=		#@sfx_ortable_12
00B54:      	test		DX.b12
00B55:      	if ZR jmp	@sfx_sextw_rets
00B56:      	jmp		@sfx_orhigh
            
            sfx_SignExtL29:
00B57:      	P1=		#@sfx_ortable_13
00B5A:      	test		DX.b13
00B5B:      	if ZR jmp	@sfx_sextw_rets
00B5C:      	jmp		@sfx_orhigh
            
            sfx_SignExtL30:
00B5D:      	P1=		#@sfx_ortable_14
00B60:      	test		DX.b14
00B61:      	if ZR jmp	@sfx_sextw_rets
00B62:      	jmp		@sfx_orhigh
            
            
            ; ~.~--------------------
            ; I1, AX
            
            sfx_REPMOV_SS:
            @sfx_repmov_ss_loop_1804:
00B63:      	push		I1
00B64:      	AR=		AX
00B65:      	I1=		AR
00B66:      	AR=		rm[I1]
00B67:      	pop		I1
00B68:      	rm[I1++]=	AR
00B69:      	AX++
00B6A:      	loop		@sfx_repmov_ss_loop_1804
00B6B:      	rets
            
            ; ~~
            
            sfx_REPMOV_SR:
00B6C:      	AR=		AX
00B6D:      	P1=		AR
            @sfx_repmov_sr_loop_1804:
00B6E:      	rm[I1++]=	pm[P1++]
00B6F:      	loop		@sfx_repmov_sr_loop_1804
00B70:      	rets
            
            
            ; ~~
            
            sfx_REPMOV_RS:
00B71:      	AR=		AX
00B72:      	I1=		AR
            @sfx_repmov_rs_loop_1804:
00B73:      	AR=		rm[I1++]
00B74:      	pm[P1++]=	AR
00B75:      	loop		@sfx_repmov_rs_loop_1804
00B76:      	rets
            
            ; ~~
            
            sfx_REPMOV_RR:
            @sfx_repmov_rr_loop_1804:
00B77:      	push		P1
00B78:      	AR=		AX
00B79:      	P1=		AR
00B7A:      	AR=		pm[P1]
00B7B:      	pop		P1
00B7C:      	pm[P1++]=	AR
00B7D:      	AX++
00B7E:      	loop		@sfx_repmov_rr_loop_1804
00B7F:      	rets
            
            ; ~~
            
            ; sfx_CHECKZERO:
            	; AR=		AX
            	; rets
            
            ; ~~
            
            ; sfx_CHECKZEROLONG:
            	; AR=		AX
            	; AR=		AR | DX
            	; rets
            
            ; ~~
            
            
            #ifdef PRAM_BANK
            
            ;  ~~ simple link list for PRAM allocate
            
            ;  +---------+---------+
            ;  | field 0 | field 1 |
            ;  +---------+---------+
            ;  |   PROM  |  next   |
            ;  +---------+---------+
            
            sfx_DynFastCallInit:
            ; {
            	P1.hh=		PRAM_BANK
            	P1=		PRAM_OFFSET
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	rets
            ; }
            
            
            ; ~~ for C / ASM progam compatible used
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            ; bool sfx_DynFindPrg(PRGADR)
            ;
            ; in:
            ;    P1		- function start address
            ;
            ; out:
            ;     Z		- found, P0 = program entry address at PRAM
            ;     NZ	- not found, P0 = free space (list) start at PRAM
            ; ----------------------------------------------------------------
            
            sfx_DynFindPrg:
            ; {
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfp_loop_1320:
            	AR=		pm[P0++]	; program address
            	if ZR jmp	@sfxdfp_label_1321
            	SF=		AR - P1
            	if NE jmp	@sfxdfp_label_1323
            	
            	P0++
            	set		Z
            	rets
            
            @sfxdfp_label_1323:
            	AR=		pm[P0]		; next
            	P0=		0xFC00
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfp_label_1655
            	P0=		AR
            	jmp		@sfxdfp_loop_1320
            
            @sfxdfp_label_1321:
            	P0--				; list
            	clr		Z
            	rets
            	
            @sfxdfp_label_1655:
            ; ~~ list broken...
            	P0=		PRAM_OFFSET
            	clr		Z
            	rets
            ; }
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free link start
            ; AX = function end address
            
            
            sfx_DynBooking:
            ; {
            	; check if PRG to big to fit in PRAM
            
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	; ~~ can not cache PRG (total PRAM_SIZE) ??
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdb_label_1345
            
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdb_label_1349
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdb_label_1349:
            	; create link list
            
            	AR=		P1
            	pm[P0++]=	AR		; PRG
            	AR=		P0
            	AR=		AR - 3		; remove 1 list and 1 next
            	CX=		CX + AR
            	pm[P0++]=	CX		; next
            
            	push		P1
            	P1=		#@sfxdfc_label_1840
            	AR=		pm[P1]		; inst -> P1.hh = 0
            	pm[P0++]=	AR
            	AR=		CX
            	P1=		AR
            	P1.hh=		PRAM_BANK
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	pop		P1
            	
            	set		Z
            	rets
            
            @sfxdb_label_1345:
            	P0.hh=		0
            	clr		Z
            	rets
            ; }
            
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free PRG entry
            ; AX = function end address
            
            sfx_DynCache:
            	push		P0
            	AR=		AX
            	AR=		AR - P1
            	CX=		AR
            	jmp		@sfxdynch_label_1650
            @sfxdynch_loop_1650:
            	AR=		pm[P1++]
            	pm[P0++]=	AR
            @sfxdynch_label_1650:
            	loop		@sfxdynch_loop_1650
            	pop		P0
            	P0--
            	rets
            
            ; --------------------------------------------------------
            
            
            ; ~~ for C
            
            ; P1 = function start address
            ; AX = function end address
            
            sfx_DynFastCall:
            ; {
            	; look up function entry by prom address (P1)
            
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfc_label_1759:
            	AR=		pm[P0++]		; next
            	if ZR jmp	@sfxdfc_label_1758
            	SF=		AR - P1
            	if EQ jmp	@sfxdfc_label_1722
            	AR=		pm[P0]
            	P0=		0xFC00
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfc_label_2035
            	P0=		AR
            	jmp		@sfxdfc_label_1759
            
            @sfxdfc_label_2035:
            	P0=		PRAM_OFFSET + 1
            
            ; -----
            
            @sfxdfc_label_1758:
            
            	; look for remain free space
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	P0--
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdfc_label_1840
            	
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdfc_label_1817
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdfc_label_1817:
            
            	; copy program to pram
            
            	; ~~ PROM field
            		AR=		P1
            		pm[P0++]=	AR
            	; ~~ next field
            		AR=		P0
            		AR=		AR - 3		; remove 1 list and 1 next
            		CX=		CX + AR
            		pm[P0++]=	CX		; next
            
            	; ~~ booking
            		push		P1
            		P1=		#@sfxdfc_label_1840
            		AR=		pm[P1]		; inst -> P1.hh = 0
            		pm[P0++]=	AR
            		AR=		CX
            		P1=		AR
            		P1.hh=		PRAM_BANK
            		AR=		0
            		pm[P1++]=	AR
            		pm[P1]=		AR
            		P1.hh=		0
            		pop		P1
            
            	; copy instruction  "P0.hh = 0"
            		push		P0		; save exec address
            	@sfxdfc_loop_1829:
            		AR=		pm[P1++]
            		pm[P0++]=	AR
            		AR=		P0
            		SF=		AR - CX
            		if AN jmp	@sfxdfc_loop_1829
            		pop		P0
            		P0--
            		fjmp		pm[P0]
            
            @sfxdfc_label_1722:
            	P0++			; program entry
            	fjmp		pm[P0]
            
            @sfxdfc_label_1840:
            	P0.hh=		0
            
            @sfxdfc_label_1733:
            	; free space too small, direct run
            	fjmp		pm[P1]
            ; }
            
            
            
            
            #endif
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> End=========================
            
            
            
            // .code segment
            
            WAKEUP_PROC:
00B80:      	PCH=	SYS_PROG_ENTRY
00B81:      	ljmp	SYS_PROG_ENTRY
            
            IntVectTable:
00B82:      	DW #EMPTY_INTENTRY
00B83:      	DW #EMPTY_INTENTRY
00B84:      	DW #EMPTY_INTENTRY
00B85:      	DW #EMPTY_INTENTRY
00B86:      	DW #EMPTY_INTENTRY
00B87:      	DW #PWM_ENTRY
            
            // .code ends
            ;;FDSP-IDE V2.53
            _SYSTEM_MAIN_PROGRAM_END_ADDRESS: 
