            ;=========================Include <OPTION.INC> Start=========================
            //--------------------------------------------------------------------------------------------------
            // TRITAN FDSP-IDE Option define file.
            // WARNING! All changes made in this file will be lost when recompiling.
            //--------------------------------------------------------------------------------------------------
            // Part number    : TRSF16127A
            // Option version : 2.2
            // Base Information--------------------------------------------------------------------------------
            #define       _OPT_TRSF16127A_                
            #define       _OPT_PROMSize_                0x20000   //PROM Size
            #define       _OPT_SRAMSize_                3072      //SRAM Size
            // I/O Configuration--------------------------------------------------------------------------------
            #define       _OPT_EXTReset_EN_             0         //EXT Reset Enable,0:Disable,1:Enable
            #define       _OPT_EXTINT1_EN_              0         //EXTINT1_EN,0:Disable,1:Enable
            #define       _OPT_EXTINT0_EN_              0         //EXTINT0_EN,0:Disable,1:Enable
            #define       _OPT_SpreadSpectrum_          0         //Spread Spectrum Enable,0:Disable,1:Enable
            #define       _OPT_EXTResetPin_             0         //EXT Reset Pin Select,0:PB3,1:PC3
            #define       _OPT_EXTINT1_INV_             0         //EXTINT1_INV,0:Disable,1:Enable
            #define       _OPT_EXTINT0_INV_             0         //EXTINT0_INV,0:Disable,1:Enable
            // Memory Configuration-----------------------------------------------------------------------------
            #define       _OPT_PRAMBank_                0         //PRAM Bank
            #define       _OPT_PRAMSize_                0         //PRAM Size(Words)
            #define       _OPT_WriteSegmentProtection_  0x0FFFF   //Write Segment Protection(0000H~ )
            // System Control Setup-----------------------------------------------------------------------------
            #define       _OPT_Bank0Speed_              11        //Bank0 Speed(MHz)
            #define       _OPT_RTCINT_                  1         //RTC interrupt,0:Disable,1:Enable
            #define       _OPT_RTCinHalt_               0         //RTC LP32K in Halt Mode,0:Disable,1:Enable
            #define       _OPT_LVR_                     2200      //LVR(mv)
            #define       _OPT_WatchDog_                256       //Watch dog(ms)
            #define       _OPT_ICEEnable_               1         //ICE Disable/Enable,0:Disable,1:Enable
            // Audio Configuration------------------------------------------------------------------------------
            #define       _OPT_AudioSamplingRate_       32        //Audio Sampling Rate(KHz)
            #define       _OPT_PWMBit_                  16        //PWM Bit
            #define       _OPT_DACFIFO_                 1         //DAC FIFO,0:Disable,1:Enable
            //--------------------------------------------------------------------------------------------------
            ;=========================Include <OPTION.INC> End=========================
            
            #define DSP_SRAM_SIZE		3072
            #define DSP_VECT_SUPPORT		6
            #define _PROJECT_CONFIG_FILE_		
            #define MIDIPCMDEC		
            #define _PWM_32K_		
            #define _MD2_TINY_MODE2_		
            #define MD2_USE_PROM		
            #define MD2_WORD_ADR		
            #define RAMBANK 		 15
            #define MD2_PRAM_START_BASE 		 0x0000
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> Start=========================
            
            ; =====================
            ;      COMMON I/O
            ; =====================
            
            #ifdef _MFDSP_
            
            ; {
            	STATUS          EQU             00H             ;R/W, BIT0: Zero.
            							;R/W, BIT1: Carry.
            							;R/W, BIT2: Overflow.
            							;R/W, BIT3: Negative.
            							;R/W, BIT7: Global Interrupt Enable.
            							;R/W, BIT[12:8]: SD_EN, TRA_EN, ADH_EN, SPIS_EN, SPIM_EN.
            							;R/W, BIT13: Interrupt Vector Table Access Enable.
            							;R/W, BIT14: Filter Buffer Available.
            							;R/W, BIT15: Parser Buffer Available.
            
            	INTENA          EQU             01H             ;R/W, Int Enable.
            	INTREQ          EQU             02H             ;R/W, Int Request.
            	IntVect         EQU             03H             ;R/W, Interrupt Table
            	IOC_PA          EQU             04H             ;R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB          EQU             05H             ;R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PCI         EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PC          EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA           EQU             07H             ;R/W, General input/output port.
            	PortB           EQU             08H             ;R/W, General input/output port.
            	PortCI          EQU             09H             ;R/W, General input/output port.
            	PortC           EQU             09H             ;R/W, General input/output port.
            	INTMASK         EQU             0AH             ;R/W, Int Mask.
            	SPIS_CTL        EQU             0BH             ;R/W, SPI slaver control register.
            	SPIS_DAT        EQU             0CH             ;R/W, SPI slaver data    register.
            	SPI_CTL         EQU             0DH             ;R/W, SPI master control register.
            	SPI_DAT         EQU             0EH             ;R/W, SPI master data    register.
            	SD_CTL          EQU             0FH             ;R/W, SD card interface control register.
            	SD_DAT          EQU             10H             ;R/W, SD card interface data.
            	SD_RSP          EQU             11H             ;R/W, SD card interface response register.
            	UART_CTL        EQU             12H
            	UART_DAT        EQU             13H
            	DPPWM           EQU             14H
            	//------------------------------------
            	PUPD_PA         EQU             15H             ;R/W, PortA  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	DACL            EQU             16H
            	DACR            EQU             17H
            	USB_CTL         EQU             18H
            	USB_DAT         EQU             19H
            	PUPD_PB         EQU             1AH             ;R/W, PortB  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	PUPD_PC         EQU             1BH             ;R/W, PortC  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	MISC            EQU             1CH
            	ClrWDT          EQU             1DH             ;W, Clear Watch-dog reset.
            	Real_T          EQU             1DH             ;R, System Real-Time Counter, base on 31.25us
            	IOP_IX          EQU             1EH             ;W, Programming IO Port index .
            	IOP_DAT         EQU             1FH             ;W, Programming IO Port Data .
            
            	//------------------------------------
            	// Virtual         Program IO Port
            	IOP_Timer1      EQU             00H
            	IOP_Timer2      EQU             01H
            	IOP_RTC32K      EQU             02H
            	IOP_PreScale    EQU             03H
            	IOP_FGREEN32K   EQU             04H
            	IOP_ODEN_PA     EQU             05H
            	IOP_ODEN_PB     EQU             06H
            	IOP_ODEN_PC     EQU             07H
            
            	IOP_TOUCH_CFG   EQU             08H
            	IOP_TOUCH_DAT   EQU             09H
            
            	IOP_CLK_CFG     EQU             0AH
            	IOP_CLK_DAT1    EQU             0BH
            	IOP_CLK_DAT2    EQU             0CH
            	IOP_CUR_PA      EQU             0DH
            	IOP_CUR_PB      EQU             0EH
            	IOP_CUR_PC      EQU             0FH
            
            	//------------------------------------
            	// IO[0x40-0x7F]
            	ADH_CFG0        EQU             40H
            	ADH_CFG1        EQU             41H
            	ADH_CFG2        EQU             42H
            	ADH_CFG3        EQU             43H
            	ADH_DO          EQU             44H
            
            	ADL_CFG         EQU             45H
            
            	TRA_CFG         EQU             46H
            	TRA_DAT         EQU             47H
            
            	I2C_CTL         EQU             48H
            	I2C_DAT         EQU             49H
            	I2C_CMD         EQU             4AH
            	I2C_SR          EQU             4AH             ; same as I2C_CMD
            
            	I80_CTL         EQU             4BH
            	I80_INX         EQU             4CH
            	I80_DAT         EQU             4DH
            	I80_RADR        EQU             4EH
            	I80_DMANUM      EQU             4FH
            
            	SD_DMA_CTL      EQU             50H
            	SD_DMA_RADR     EQU             51H
            	SD_DMA_DMANUM   EQU             52H
            
            	SPI_DMA_CTL     EQU             53H
            	SPI_DMA_RADR    EQU             54H
            	SPI_DMA_DMANUM  EQU             55H
            
            	USB_DMA_CTL     EQU             56H
            	USB_DMA_RADR    EQU             57H
            	USB_DMA_DMANUM  EQU             58H
            
            	SSC             EQU             63H
            	MIC             EQU             64H
            	GREEN           EQU             65H
            	SLEEP           EQU             66H
            	SPEED           EQU             67H
            	PR              EQU             68H
            
            	//------------------------------------
            	IOP_WAKEN_PA    EQU             10H
            	IOP_WAKEN_PB    EQU             11H
            	IOP_WAKEN_PC    EQU             12H
            ; }
            
            #endif
            
            
            
            
            #ifdef _MSPEECHDSP_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            
            #ifdef _MSPEECHDSP2_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            
            
            ;-----------------------------------------------------------
            
            #ifdef NO_OPTIMAL_RM
            
            
            #else
            
            #define Optimal_RM	; Optimal RAM function Enable
            
            #endif
            
            
            VarRM[0:127] = {
            BP_SAVE,
            
            }
            
            VarRM[128:511] = {
            
            }
            
            VarRM[512:4095] = {
            
            }
            
            ShareVar = {
            
            }
            
            ;--------------------------------------------------------------------
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> Start=========================
            
            	org	0000h
            RSTB_ENTRY:
00000:      	PCH=		SYS_PROG_ENTRY
00001:      	ljmp		SYS_PROG_ENTRY
            
            
            	org	0004h
            WAKEUP_ENTRY:
00004:      	PCH=		WAKEUP_PROC
00005:      	ljmp		WAKEUP_PROC
            
            
            	org	0100h
            
            
            
            SYS_PROG_ENTRY:
            	; ~~ DSP initial
            
00100:      	dsi
00101:      	nop
00102:      	AR=		@STACKBOTTOM
00104:      	BP=		AR
00105:      	AR=		DSP_SRAM_SIZE
00107:      	AR--
00108:      	CX=		AR
00109:      	I1=		AR
0010A:      	AR=		0
            @clearram_loop_1705:
0010B:      	rm[I1--]=	AR
0010C:      	loop		@clearram_loop_1705
            
0010D:      	io[ClrWDT]=	AR
            
0010E:      	set		io[STATUS].b13
0010F:      	CX=		DSP_VECT_SUPPORT
00110:      	P1=		#IntVectTable
00113:      	jmp		@setintvect_label_1548
            @setintvect_loop_1548:
00114:      	AR=		pm[P1++]
00115:      	io[IntVect]=	AR
            @setintvect_label_1548:
00116:      	loop		@setintvect_loop_1548
            
00117:      	clr		io[STATUS].b13
            
            	; ~~ C code
            
            #ifdef PRAM_BANK
            	PCH=		sfx_DynFastCallInit
            	lcall		sfx_DynFastCallInit
            #endif
            
00118:      	PCH=		ginit_code
00119:      	lcall		ginit_code
            
0011A:      	PCH=		_main
0011B:      	lcall		_main
0011C:      	jmp		SYS_PROG_ENTRY
            
            
            /* ================================================================= */
            // ------------- Interrupt Service Routine--------------------------
            /* ================================================================= */
            
            EMPTY_INTENTRY:
0011D:      	reti
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> End=========================
            
            ;=========================Include <DEPS\HOW DO I PLAY MD2 AND ADPCM SIMULTANEOUSLY_D38B16D5.S.CODE.ASM> Start=========================
            ; HOW DO I PLAY MD2 AND ADPCM SIMULTANEOUSLY.C Code Start!!;
            VarRM[0:4095]={
             PCMY[32],_PLAY59F2A4ED 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _main();
            ; //rjmp void _KeyPlayADPCM2EB28CF3();
            ; //rjmp void _KeyNextSong7526CDA5();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _main()				
            _main:
            ; //{
            ; //	__int16 _i_1_2;
            ; //						
0011E:      	AR	= rm[BP_SAVE]
0011F:      	push	AR
00120:      	AR	= BP
00121:      	rm[BP_SAVE]	= AR
00122:      	AR	 = -1
00123:      	BP	+= AR
            ; //_A149B8B01_0:;					
            _A149B8B01_0:
            ; //_A149B8B01_1:;					
            _A149B8B01_1:
            ; //_A149B8B01_2:;					
            _A149B8B01_2:
            ; //	_InitialDA4A7CC4();			
00124:      	pch	= _InitialDA4A7CC4
00125:      	lcall	_InitialDA4A7CC4
            ; //_A149B8B01_3:;					
            _A149B8B01_3:
            ; //_A149B8B01_4:;					
            _A149B8B01_4:
            ; //	_InitKey3C587B6D();			
00126:      	pch	= _InitKey3C587B6D
00127:      	lcall	_InitKey3C587B6D
            ; //_A149B8B01_5:;					
            _A149B8B01_5:
            ; //_A149B8B01_6:;					
            _A149B8B01_6:
            ; //	md2Initialize();			
00128:      	pch	= md2Initialize
00129:      	lcall	md2Initialize
            ; //_A149B8B01_7:;					
            _A149B8B01_7:
            ; //_A149B8B01_8:;					
            _A149B8B01_8:
            ; //	ADPCM_ChX_init();			
0012A:      	pch	= ADPCM_ChX_init
0012B:      	lcall	ADPCM_ChX_init
            ; //_A149B8B01_9:;					
            _A149B8B01_9:
            ; //	sAX	= 0x0001;			
0012C:      	AX	= 0x01
            ; //	asm I1 = CopyToBank+0;			
0012D:      	I1 = CopyToBank+0//
            ; //	*(__int16*)sSI	= sAX			
0012E:      	rm[I1]	= AX
            ; //_A149B8B01_10:;					
            _A149B8B01_10:
            ; //	sAX	= 0x0001;			
0012F:      	AX	= 0x01
            ; //	asm I1 = _PLAY59F2A4ED+0;		
00130:      	I1 = _PLAY59F2A4ED+0//
            ; //	*(__int16*)sSI	= sAX			
00131:      	rm[I1]	= AX
            ; //_A149B8B01_11:;					
            _A149B8B01_11:
            ; //_A149B8B01_12:;					
            _A149B8B01_12:
            ; //	asm AX = #MidiData+0;			
00132:      	AX = #MidiData+0//
            ; //	asm DX = #MidiData.n2			
00134:      	DX = #MidiData.n2
            ; //	asm set DX.b11				
00135:      	set DX.b11
            ; //	_md2FindMidiEntry757C576D(STACK[sSP + 0], STACK[sSP + 1]);
00136:      	pch	= _md2FindMidiEntry757C576D
00137:      	lcall	_md2FindMidiEntry757C576D
            ; //	sfx_CHECKZERO();			
00138:      	AR	= AX
            ; //	if(__jz__)	goto L3723FA83_6;	
00139:      	if ZR	jmp L3723FA83_6
            ; //	goto	L3723FA83_5;			
0013A:      	jmp	L3723FA83_5
            ; //L3723FA83_6:;					
            L3723FA83_6:
            ; //	
            ; //L3723FA83_8:;					
            L3723FA83_8:
            ; //_A149B8B01_13:;					
            _A149B8B01_13:
            ; //	goto L3723FA83_8;			
0013B:      	jmp	L3723FA83_8
            ; //L3723FA83_7:;					
            L3723FA83_7:
            ; //L3723FA83_5:;					
            L3723FA83_5:
            ; //_A149B8B01_14:;					
            _A149B8B01_14:
            ; //_A149B8B01_15:;					
            _A149B8B01_15:
            ; //_A149B8B01_16:;					
            _A149B8B01_16:
            ; //	md2InitParameters();			
0013C:      	pch	= md2InitParameters
0013D:      	lcall	md2InitParameters
            ; //_A149B8B01_17:;					
            _A149B8B01_17:
            ; //_A149B8B01_18:;					
            _A149B8B01_18:
            ; //	md2StartBGServe();			
0013E:      	pch	= md2StartBGServe
0013F:      	lcall	md2StartBGServe
            ; //_A149B8B01_19:;					
            _A149B8B01_19:
            ; //	sAX	= 0xFFFF;			
00140:      	AX	= 0xFFFF
            ; //	asm I1 = _songidx8C42F7DA+0;		
00142:      	I1 = _songidx8C42F7DA+0//
            ; //	*(__int16*)sSI	= sAX			
00143:      	rm[I1]	= AX
            ; //_A149B8B01_20:;					
            _A149B8B01_20:
            ; //	sAX	= 0x003F;			
00144:      	AX	= 0x3F
            ; //	asm I1 = mp_vol+0;			
00145:      	I1 = mp_vol+0//
            ; //	*(__int16*)sSI	= sAX			
00146:      	rm[I1]	= AX
            ; //_A149B8B01_21:;					
            _A149B8B01_21:
            ; //	sAX	= 0x4000;			
00147:      	AX	= 0x4000
            ; //	asm I1 = mp_tempo+0;			
00149:      	I1 = mp_tempo+0//
            ; //	*(__int16*)sSI	= sAX			
0014A:      	rm[I1]	= AX
            ; //_A149B8B01_22:;					
            _A149B8B01_22:
            ; //	sAX	= 0x0007;			
0014B:      	AX	= 0x07
            ; //	asm I1 = mp_lop+0;			
0014C:      	I1 = mp_lop+0//
            ; //	*(__int16*)sSI	= sAX			
0014D:      	rm[I1]	= AX
            ; //L3723FA83_10:;					
            L3723FA83_10:
            ; //_A149B8B01_23:;					
            _A149B8B01_23:
            ; //_A149B8B01_24:;					
            _A149B8B01_24:
            ; //	asm	io[ClrWDT] = AR			
0014E:      	io[ClrWDT] = AR
            ; //	
            ; //_A149B8B01_25:;					
            _A149B8B01_25:
            ; //_A149B8B01_26:;					
            _A149B8B01_26:
            ; //	_PollingKey3B90E3B1();			
0014F:      	pch	= _PollingKey3B90E3B1
00150:      	lcall	_PollingKey3B90E3B1
            ; //_A149B8B01_27:;					
            _A149B8B01_27:
            ; //	asm I1 = _PLAY59F2A4ED+0;		
00151:      	I1 = _PLAY59F2A4ED+0//
            ; //	sAX	= *(__int16*)sSI;		
00152:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
00153:      	AR	= AX
            ; //	if(__jnz__)	goto L3723FA83_12;	
00154:      	if NZ	jmp L3723FA83_12
            ; //	goto	L3723FA83_11;			
00155:      	jmp	L3723FA83_11
            ; //L3723FA83_12:;					
            L3723FA83_12:
            ; //	
            ; //_A149B8B01_28:;					
            _A149B8B01_28:
            ; //_A149B8B01_29:;					
            _A149B8B01_29:
            ; //	_md2ChkSongEnd0B00CDA5();		
00156:      	pch	= _md2ChkSongEnd0B00CDA5
00157:      	lcall	_md2ChkSongEnd0B00CDA5
            ; //	sfx_CHECKZERO();			
00158:      	AR	= AX
            ; //	if(__jnz__)	goto L3723FA83_14;	
00159:      	if NZ	jmp L3723FA83_14
            ; //	goto	L3723FA83_13;			
0015A:      	jmp	L3723FA83_13
            ; //L3723FA83_14:;					
            L3723FA83_14:
            ; //	
            ; //_A149B8B01_30:;					
            _A149B8B01_30:
            ; //	asm I1 = _songidx8C42F7DA+0;		
0015B:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
0015C:      	AX	= rm[I1]
            ; //	sSI	= (int)&_songidx8C42F7DA;	
0015D:      	I1	= _songidx8C42F7DA
            ; //	sCX	= *(__int16*)sSI;		
0015E:      	CX	= rm[I1]
            ; //	sCX++;					
0015F:      	CX++
            ; //	*(__int16*)sSI	= sCX;			
00160:      	rm[I1]	= CX
            ; //_A149B8B01_31:;					
            _A149B8B01_31:
            ; //_A149B8B01_32:;					
            _A149B8B01_32:
            ; //	_CheckSongLimit402181B4();		
00161:      	pch	= _CheckSongLimit402181B4
00162:      	lcall	_CheckSongLimit402181B4
            ; //_A149B8B01_33:;					
            _A149B8B01_33:
            ; //_A149B8B01_34:;					
            _A149B8B01_34:
            ; //	asm I1 = _songidx8C42F7DA+0;		
00163:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
00164:      	AX	= rm[I1]
            ; //	_md2PlaySongF1CD4C9D(STACK[sSP + 0]);	
00165:      	pch	= _md2PlaySongF1CD4C9D
00166:      	lcall	_md2PlaySongF1CD4C9D
            ; //L3723FA83_13:;					
            L3723FA83_13:
            ; //_A149B8B01_35:;					
            _A149B8B01_35:
            ; //L3723FA83_11:;					
            L3723FA83_11:
            ; //_A149B8B01_36:;					
            _A149B8B01_36:
            ; //_A149B8B01_37:;					
            _A149B8B01_37:
            ; //_A149B8B01_38:;					
            _A149B8B01_38:
            ; //	SyncNow();				
00167:      	pch	= SyncNow
00168:      	lcall	SyncNow
            ; //	sfx_CHECKZERO();			
00169:      	AR	= AX
            ; //	if(__jz__)	goto L3723FA83_16;	
0016A:      	if ZR	jmp L3723FA83_16
            ; //	goto	L3723FA83_15;			
0016B:      	jmp	L3723FA83_15
            ; //L3723FA83_16:;					
            L3723FA83_16:
            ; //_A149B8B01_39:;					
            _A149B8B01_39:
            ; //	goto L3723FA83_10;			
0016C:      	jmp	L3723FA83_10
            ; //L3723FA83_15:;					
            L3723FA83_15:
            ; //_A149B8B01_40:;					
            _A149B8B01_40:
            ; //_A149B8B01_41:;					
            _A149B8B01_41:
            ; //_A149B8B01_42:;					
            _A149B8B01_42:
            ; //	_md2DoRoutine82B98B9D();		
0016D:      	pch	= _md2DoRoutine82B98B9D
0016E:      	lcall	_md2DoRoutine82B98B9D
            ; //_A149B8B01_43:;					
            _A149B8B01_43:
            ; //	asm AX = _adpch30670376+0;		
0016F:      	AX = _adpch30670376+0//
            ; //	asm I1 = ADPCM_Tmpi+0;			
00170:      	I1 = ADPCM_Tmpi+0//
            ; //	*(__int16*)sSI	= sAX			
00171:      	rm[I1]	= AX
            ; //_A149B8B01_44:;					
            _A149B8B01_44:
            ; //_A149B8B01_45:;					
            _A149B8B01_45:
            ; //	ClearAudioBuffer();			
00172:      	pch	= ClearAudioBuffer
00173:      	lcall	ClearAudioBuffer
            ; //_A149B8B01_46:;					
            _A149B8B01_46:
            ; //	_i_1_2+0	= 0x04;			
00174:      	I1	= rm[BP_SAVE]
00175:      	AR	= 0x04
00176:      	rm[I1]	= AR
            ; //L3723FA83_18:;					
            L3723FA83_18:
            ; //_A149B8B01_47:;					
            _A149B8B01_47:
            ; //	sSI	= (int)&_i_1_2;			
00177:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00178:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
00179:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
0017A:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
0017B:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
0017C:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
0017D:      	AR	= AX
            ; //	if(__jnz__)	goto L3723FA83_19;	
0017E:      	if NZ	jmp L3723FA83_19
            ; //	goto	L3723FA83_17;			
0017F:      	jmp	L3723FA83_17
            ; //L3723FA83_19:;					
            L3723FA83_19:
            ; //	
            ; //_A149B8B01_48:;					
            _A149B8B01_48:
            ; //_A149B8B01_49:;					
            _A149B8B01_49:
            ; //	DecodeChannel();			
00180:      	pch	= DecodeChannel
00181:      	lcall	DecodeChannel
            ; //_A149B8B01_50:;					
            _A149B8B01_50:
            ; //	asm I1 = ADPCM_Tmpi+0;			
00182:      	I1 = ADPCM_Tmpi+0//
            ; //	sAX	= *(__int16*)sSI;		
00183:      	AX	= rm[I1]
            ; //	sSI	= (int)&ADPCM_Tmpi;		
00184:      	I1	= ADPCM_Tmpi
            ; //	sCX	= *(__int16*)sSI;		
00185:      	CX	= rm[I1]
            ; //	asm AR = 0x0012;			
00186:      	AR = 0x0012//
            ; //	asm rm[I1] = CX + AR;			
00187:      	rm[I1] = CX + AR//
            ; //	goto L3723FA83_18;			
00188:      	jmp	L3723FA83_18
            ; //L3723FA83_17:;					
            L3723FA83_17:
            ; //_A149B8B01_51:;					
            _A149B8B01_51:
            ; //_A149B8B01_52:;					
            _A149B8B01_52:
            ; //	MixAll();				
00189:      	pch	= MixAll
0018A:      	lcall	MixAll
            ; //	goto L3723FA83_10;			
0018B:      	jmp	L3723FA83_10
            ; //L3723FA83_9:;					
            L3723FA83_9:
            ; //L3723FA83_4:;					
            L3723FA83_4:
            ; //_A149B8B01_53:;					
            _A149B8B01_53:
            ; //	return;					
0018C:      	AR	= 1
0018D:      	BP	+= AR
0018E:      	pop	AR
0018F:      	rm[BP_SAVE]	= AR
00190:      	rets
            ; //_main_end:;					
            _main_end:
            ; //_A149B8B01_54:;					
            _A149B8B01_54:
            ; //}
            ; //
            ; //rjmp void _KeyPlayADPCM2EB28CF3()		
            _KeyPlayADPCM2EB28CF3:
            ; //{
            ; //_A149B8B01_55:;					
            _A149B8B01_55:
            ; //	
            ; //_A149B8B01_56:;					
            _A149B8B01_56:
            ; //_A149B8B01_57:;					
            _A149B8B01_57:
            ; //	md2StopSong();				
00191:      	pch	= md2StopSong
00192:      	lcall	md2StopSong
            ; //_A149B8B01_58:;					
            _A149B8B01_58:
            ; //	sAX	= 0x0000;			
00193:      	AX	= 0x00
            ; //	asm I1 = _PLAY59F2A4ED+0;		
00194:      	I1 = _PLAY59F2A4ED+0//
            ; //	*(__int16*)sSI	= sAX			
00195:      	rm[I1]	= AX
            ; //_A149B8B01_59:;					
            _A149B8B01_59:
            ; //	asm AX = #_adpdata32993E3B+0;		
00196:      	AX = #_adpdata32993E3B+0//
            ; //	PUSH(sAX);				
00198:      	push	AX
            ; //	asm I1 = _iADPCCACC469+0;		
00199:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
0019B:      	AX	= rm[I1]
            ; //	sCX	= 0x0004;			
0019C:      	CX	= 0x04
            ; //	sfx_IMUL_AX_CX();			
0019D:      	pch	= sfx_IMUL_AX_CX
0019E:      	lcall	sfx_IMUL_AX_CX
            ; //	sCX	= POP();			
0019F:      	pop	CX
            ; //	sAX	= sAX + sCX;			
001A0:      	AR	= CX
001A1:      	AX	+= AR
            ; //	sDI	= sAX;				
001A2:      	AR	= AX
001A3:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI++;		
001A4:      	AX	= pm[P1++]
            ; //	sDX	= *(__int16*)sDI--;		
001A5:      	DX	= pm[P1--]
            ; //	sfx_CHECKZEROLONG();			
001A6:      	AR	= AX
001A7:      	AR	|= DX
            ; //	if(__jz__)	goto L3723FA83_22;	
001A8:      	if ZR	jmp L3723FA83_22
            ; //	goto	L3723FA83_21;			
001A9:      	jmp	L3723FA83_21
            ; //L3723FA83_22:;					
            L3723FA83_22:
            ; //_A149B8B01_60:;					
            _A149B8B01_60:
            ; //	sAX	= 0x0000;			
001AA:      	AX	= 0x00
            ; //	asm I1 = _iADPCCACC469+0;		
001AB:      	I1 = _iADPCCACC469+0//
            ; //	*(__int16*)sSI	= sAX			
001AD:      	rm[I1]	= AX
            ; //L3723FA83_21:;					
            L3723FA83_21:
            ; //_A149B8B01_61:;					
            _A149B8B01_61:
            ; //_A149B8B01_62:;					
            _A149B8B01_62:
            ; //_A149B8B01_63:;					
            _A149B8B01_63:
            ; //	asm I1 = _iADPCCACC469+0;		
001AE:      	I1 = _iADPCCACC469+0//
            ; //	sAX	= *(__int16*)sSI;		
001B0:      	AX	= rm[I1]
            ; //	sSI	= (int)&_iADPCCACC469;		
001B1:      	I1	= _iADPCCACC469
            ; //	sCX	= *(__int16*)sSI;		
001B3:      	CX	= rm[I1]
            ; //	sCX++;					
001B4:      	CX++
            ; //	*(__int16*)sSI	= sCX;			
001B5:      	rm[I1]	= CX
            ; //	PUSH(sAX);				
001B6:      	push	AX
            ; //	_playADPCMBACD5AFD(STACK[sSP + 0]);	
001B7:      	pch	= _playADPCMBACD5AFD
001B8:      	lcall	_playADPCMBACD5AFD
            ; //	RESTORESP(1);				
001B9:      	pop	AR
            ; //L3723FA83_20:;					
            L3723FA83_20:
            ; //_A149B8B01_64:;					
            _A149B8B01_64:
            ; //	return;					
001BA:      	rets
            ; //_KeyPlayADPCM2EB28CF3_end:;			
            _KeyPlayADPCM2EB28CF3_end:
            ; //_A149B8B01_65:;					
            _A149B8B01_65:
            ; //}
            ; //
            ; //rjmp void _KeyNextSong7526CDA5()		
            _KeyNextSong7526CDA5:
            ; //{
            ; //_A149B8B01_66:;					
            _A149B8B01_66:
            ; //	
            ; //_A149B8B01_67:;					
            _A149B8B01_67:
            ; //_A149B8B01_68:;					
            _A149B8B01_68:
            ; //	_StopAllADPCM9255018D();		
001BB:      	pch	= _StopAllADPCM9255018D
001BC:      	lcall	_StopAllADPCM9255018D
            ; //_A149B8B01_69:;					
            _A149B8B01_69:
            ; //_A149B8B01_70:;					
            _A149B8B01_70:
            ; //	md2StopSong();				
001BD:      	pch	= md2StopSong
001BE:      	lcall	md2StopSong
            ; //_A149B8B01_71:;					
            _A149B8B01_71:
            ; //	sAX	= 0x0001;			
001BF:      	AX	= 0x01
            ; //	asm I1 = _PLAY59F2A4ED+0;		
001C0:      	I1 = _PLAY59F2A4ED+0//
            ; //	*(__int16*)sSI	= sAX			
001C1:      	rm[I1]	= AX
            ; //L3723FA83_23:;					
            L3723FA83_23:
            ; //_A149B8B01_72:;					
            _A149B8B01_72:
            ; //	return;					
001C2:      	rets
            ; //_KeyNextSong7526CDA5_end:;			
            _KeyNextSong7526CDA5_end:
            ; //_A149B8B01_73:;					
            _A149B8B01_73:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_HOW_DO_I_PLAY_MD2_AND_ADPCM_SIMULTANEOUSLY_D38B16D5_s(void)
            ginit_code_HOW_DO_I_PLAY_MD2_AND_ADPCM_SIMULTANEOUSLY_D38B16D5_s:
            ; //{
            ; //	return;					
001C3:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //__int16 _keyfuncF06F3D55[15] = {		
            _keyfuncF06F3D55:
            ; //	(int)&_KeyPlayADPCM2EB28CF3, 0x0000, 0x0000, (int)&_KeyNextSong7526CDA5, 0x0000, 0x0000, 0x0000, 0x0000, 
001C4:      DW #_KeyPlayADPCM2EB28CF3,0x0000,0x0000,#_KeyNextSong7526CDA5,0x0000,0x0000,0x0000,0x0000,
            ; //	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
001CC:      DW 0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
            ; //};
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\HOW DO I PLAY MD2 AND ADPCM SIMULTANEOUSLY_D38B16D5.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\KEYPAD_0E0216C1.S.CODE.ASM> Start=========================
            ; keypad.c Code Start!!;
            VarRM[0:4095]={
             L5589D4CE_25,L5589D4CE_26,L5589D4CE_27 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _InitKey3C587B6D();
            ; //rjmp void _PollingKey3B90E3B1();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _InitKey3C587B6D()			
            _InitKey3C587B6D:
            ; //{
            ; //_A149B8B01_74:;					
            _A149B8B01_74:
            ; //	
            ; //_A149B8B01_75:;					
            _A149B8B01_75:
            ; //	asm clr io[0x04].b0;			
001D3:      	clr io[0x04].b0//
            ; //_A149B8B01_76:;					
            _A149B8B01_76:
            ; //	asm clr io[0x04].b1;			
001D4:      	clr io[0x04].b1//
            ; //_A149B8B01_77:;					
            _A149B8B01_77:
            ; //	asm clr io[0x04].b2;			
001D5:      	clr io[0x04].b2//
            ; //_A149B8B01_78:;					
            _A149B8B01_78:
            ; //	asm clr io[0x04].b3;			
001D6:      	clr io[0x04].b3//
            ; //_A149B8B01_79:;					
            _A149B8B01_79:
            ; //	io[0x1E]	= 0x0005;		
001D7:      	AR	= 0x05
001D8:      	io[0x1E]	= AR
            ; //_A149B8B01_80:;					
            _A149B8B01_80:
            ; //	sAX	= 0x000F;			
001D9:      	AX	= 0x0F
            ; //	sAX	= sAX | io[0x1F];		
001DA:      	AR	= io[0x1F]
001DB:      	AX	|= AR
            ; //	io[0x1F]	= sAX;			
001DC:      	AR	= AX
001DD:      	io[0x1F]	= AR
            ; //_A149B8B01_81:;					
            _A149B8B01_81:
            ; //	sAX	= 0x0000;			
001DE:      	AX	= 0x00
            ; //	sSI	= (int)&L5589D4CE_25;		
001DF:      	I1	= L5589D4CE_25
            ; //	*(__int16*)sSI	= sAX			
001E0:      	rm[I1]	= AX
            ; //_A149B8B01_82:;					
            _A149B8B01_82:
            ; //	sAX	= 0x0000;			
001E1:      	AX	= 0x00
            ; //	sSI	= (int)&L5589D4CE_26;		
001E2:      	I1	= L5589D4CE_26
            ; //	*(__int16*)sSI	= sAX			
001E3:      	rm[I1]	= AX
            ; //_A149B8B01_83:;					
            _A149B8B01_83:
            ; //	sAX	= 0x0200;			
001E4:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_27;		
001E6:      	I1	= L5589D4CE_27
            ; //	*(__int16*)sSI	= sAX			
001E7:      	rm[I1]	= AX
            ; //L5589D4CE_28:;					
            L5589D4CE_28:
            ; //_A149B8B01_84:;					
            _A149B8B01_84:
            ; //	return;					
001E8:      	rets
            ; //_InitKey3C587B6D_end:;				
            _InitKey3C587B6D_end:
            ; //_A149B8B01_85:;					
            _A149B8B01_85:
            ; //}
            ; //
            ; //rjmp void L5589D4CE_29()			
            L5589D4CE_29:
            ; //{
            ; //	__int16 _btn_1_2;
            ; //						
001E9:      	AR	= rm[BP_SAVE]
001EA:      	push	AR
001EB:      	AR	= BP
001EC:      	rm[BP_SAVE]	= AR
001ED:      	AR	 = -1
001EE:      	BP	+= AR
            ; //_A149B8B01_86:;					
            _A149B8B01_86:
            ; //_A149B8B01_87:;					
            _A149B8B01_87:
            ; //	sAX	= 0x000F;			
001EF:      	AX	= 0x0F
            ; //	sAX	= sAX & io[0x07];		
001F0:      	AR	= io[0x07]
001F1:      	AX	&= AR
            ; //	sSI	= (int)&_btn_1_2;		
001F2:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
001F3:      	rm[I1]	= AX
            ; //_A149B8B01_88:;					
            _A149B8B01_88:
            ; //	sSI	= (int)&_btn_1_2;		
001F4:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
001F5:      	AX	= rm[I1]
            ; //	goto L5589D4CE_31;			
001F6:      	jmp	L5589D4CE_31
            ; //L5589D4CE_31:;					
            L5589D4CE_31:
            ; //_A149B8B01_89:;					
            _A149B8B01_89:
            ; //	return;					
001F7:      	AR	= 1
001F8:      	BP	+= AR
001F9:      	pop	AR
001FA:      	rm[BP_SAVE]	= AR
001FB:      	rets
            ; //L5589D4CE_29_end:;				
            L5589D4CE_29_end:
            ; //_A149B8B01_90:;					
            _A149B8B01_90:
            ; //}
            ; //
            ; //rjmp void _PollingKey3B90E3B1()			
            _PollingKey3B90E3B1:
            ; //{
            ; //	__int16 _keynow_1_2;
            ; //	__int16 _i_1_4;
            ; //	__int16 _bits_1_6;
            ; //	__int16 _bitp_1_8;
            ; //	__int16 _pkey_1_10;
            ; //						
001FC:      	AR	= rm[BP_SAVE]
001FD:      	push	AR
001FE:      	AR	= BP
001FF:      	rm[BP_SAVE]	= AR
00200:      	AR	 = -5
00201:      	BP	+= AR
            ; //_A149B8B01_91:;					
            _A149B8B01_91:
            ; //_A149B8B01_92:;					
            _A149B8B01_92:
            ; //_A149B8B01_93:;					
            _A149B8B01_93:
            ; //	NEARCALL(L5589D4CE_29);			
00202:      	call	L5589D4CE_29
            ; //	sSI	= (int)&_keynow_1_2;		
00203:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
00204:      	rm[I1]	= AX
            ; //_A149B8B01_94:;					
            _A149B8B01_94:
            ; //	asm I1 = L5589D4CE_25+0;		
00205:      	I1 = L5589D4CE_25+0//
            ; //	sAX	= *(__int16*)sSI;		
00206:      	AX	= rm[I1]
            ; //	sSI	= (int)&_keynow_1_2;		
00207:      	I1	= rm[BP_SAVE]
            ; //	sCX	= *(__int16*)sSI;		
00208:      	CX	= rm[I1]
            ; //	sfx_CMP_AX_CX_JNE();			
00209:      	pch	= sfx_CMP_AX_CX_JNE
0020A:      	lcall	sfx_CMP_AX_CX_JNE
            ; //	if(__je__)	goto L5589D4CE_34;	
0020B:      	if ZR	jmp L5589D4CE_34
            ; //	goto	L5589D4CE_33;			
0020C:      	jmp	L5589D4CE_33
            ; //L5589D4CE_34:;					
            L5589D4CE_34:
            ; //	
            ; //_A149B8B01_95:;					
            _A149B8B01_95:
            ; //	sSI	= (int)&_keynow_1_2;		
0020D:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0020E:      	AX	= rm[I1]
            ; //	sSI	= (int)&L5589D4CE_25;		
0020F:      	I1	= L5589D4CE_25
            ; //	*(__int16*)sSI	= sAX			
00210:      	rm[I1]	= AX
            ; //_A149B8B01_96:;					
            _A149B8B01_96:
            ; //	sAX	= 0x0200;			
00211:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_27;		
00213:      	I1	= L5589D4CE_27
            ; //	*(__int16*)sSI	= sAX			
00214:      	rm[I1]	= AX
            ; //_A149B8B01_97:;					
            _A149B8B01_97:
            ; //	goto L5589D4CE_32;			
00215:      	jmp	L5589D4CE_32
            ; //L5589D4CE_33:;					
            L5589D4CE_33:
            ; //_A149B8B01_98:;					
            _A149B8B01_98:
            ; //_A149B8B01_99:;					
            _A149B8B01_99:
            ; //	asm I1 = L5589D4CE_27+0;		
00216:      	I1 = L5589D4CE_27+0//
            ; //	sAX	= *(__int16*)sSI;		
00217:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
00218:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_36;	
00219:      	if NZ	jmp L5589D4CE_36
            ; //	goto	L5589D4CE_35;			
0021A:      	jmp	L5589D4CE_35
            ; //L5589D4CE_36:;					
            L5589D4CE_36:
            ; //	
            ; //_A149B8B01_100:;				
            _A149B8B01_100:
            ; //	asm I1 = L5589D4CE_27+0;		
0021B:      	I1 = L5589D4CE_27+0//
            ; //	sAX	= *(__int16*)sSI;		
0021C:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
0021D:      	CX	= 0x01
            ; //	sAX	= sAX - sCX;			
0021E:      	AR	= CX
0021F:      	AX	-= AR
            ; //	sSI	= (int)&L5589D4CE_27;		
00220:      	I1	= L5589D4CE_27
            ; //	*(__int16*)sSI	= sAX			
00221:      	rm[I1]	= AX
            ; //_A149B8B01_101:;				
            _A149B8B01_101:
            ; //	goto L5589D4CE_32;			
00222:      	jmp	L5589D4CE_32
            ; //L5589D4CE_35:;					
            L5589D4CE_35:
            ; //_A149B8B01_102:;				
            _A149B8B01_102:
            ; //_A149B8B01_103:;				
            _A149B8B01_103:
            ; //	asm AX = #_keyfuncF06F3D55+0;		
00223:      	AX = #_keyfuncF06F3D55+0//
            ; //	sSI	= (int)&_pkey_1_10;		
00225:      	AR	= -4
00226:      	I1	= rm[BP_SAVE]
00227:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00228:      	rm[I1]	= AX
            ; //_A149B8B01_104:;				
            _A149B8B01_104:
            ; //	sAX	= 0x0200;			
00229:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_27;		
0022B:      	I1	= L5589D4CE_27
            ; //	*(__int16*)sSI	= sAX			
0022C:      	rm[I1]	= AX
            ; //_A149B8B01_105:;				
            _A149B8B01_105:
            ; //	asm I1 = L5589D4CE_26+0;		
0022D:      	I1 = L5589D4CE_26+0//
            ; //	sAX	= *(__int16*)sSI;		
0022E:      	AX	= rm[I1]
            ; //	asm I1 = L5589D4CE_25+0;		
0022F:      	I1 = L5589D4CE_25+0//
            ; //	asm AR = rm[I1];			
00230:      	AR = rm[I1]//
            ; //	asm AX = AX ^ AR;			
00231:      	AX = AX ^ AR//
            ; //	sSI	= (int)&_bits_1_6;		
00232:      	AR	= -2
00233:      	I1	= rm[BP_SAVE]
00234:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00235:      	rm[I1]	= AX
            ; //_A149B8B01_106:;				
            _A149B8B01_106:
            ; //	asm I1 = L5589D4CE_26+0;		
00236:      	I1 = L5589D4CE_26+0//
            ; //	sAX	= *(__int16*)sSI;		
00237:      	AX	= rm[I1]
            ; //	sSI	= (int)&_bitp_1_8;		
00238:      	AR	= -3
00239:      	I1	= rm[BP_SAVE]
0023A:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
0023B:      	rm[I1]	= AX
            ; //_A149B8B01_107:;				
            _A149B8B01_107:
            ; //	asm I1 = L5589D4CE_25+0;		
0023C:      	I1 = L5589D4CE_25+0//
            ; //	sAX	= *(__int16*)sSI;		
0023D:      	AX	= rm[I1]
            ; //	sSI	= (int)&L5589D4CE_26;		
0023E:      	I1	= L5589D4CE_26
            ; //	*(__int16*)sSI	= sAX			
0023F:      	rm[I1]	= AX
            ; //_A149B8B01_108:;				
            _A149B8B01_108:
            ; //	_i_1_4+0	= 0x05;			
00240:      	AR	= -1
00241:      	I1	= rm[BP_SAVE]
00242:      	I1	+= AR
00243:      	AR	= 0x05
00244:      	rm[I1]	= AR
            ; //L5589D4CE_38:;					
            L5589D4CE_38:
            ; //_A149B8B01_109:;				
            _A149B8B01_109:
            ; //	sSI	= (int)&_i_1_4;			
00245:      	AR	= -1
00246:      	I1	= rm[BP_SAVE]
00247:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00248:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_4;			
00249:      	AR	= -1
0024A:      	I1	= rm[BP_SAVE]
0024B:      	I1	+= AR
            ; //	asm AR = 0x0001;			
0024C:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
0024D:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
0024E:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
0024F:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_39;	
00250:      	if NZ	jmp L5589D4CE_39
            ; //	goto	L5589D4CE_37;			
00251:      	jmp	L5589D4CE_37
            ; //L5589D4CE_39:;					
            L5589D4CE_39:
            ; //	
            ; //_A149B8B01_110:;				
            _A149B8B01_110:
            ; //	sAX	= 0;				
00252:      	AX	= 0x00
            ; //	sSI	= (int)&_bits_1_6+0;		
00253:      	AR	= -2
00254:      	I1	= rm[BP_SAVE]
00255:      	I1	+= AR
            ; //	asm AR = rm[I1];			
00256:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
00257:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_41;		
00258:      	if ZR	jmp L5589D4CE_41
            ; //	sAX	= 1;				
00259:      	AX	= 0x01
            ; //L5589D4CE_41:;					
            L5589D4CE_41:
            ; //	sfx_CHECKZERO();			
0025A:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_42;	
0025B:      	if NZ	jmp L5589D4CE_42
            ; //	goto	L5589D4CE_40;			
0025C:      	jmp	L5589D4CE_40
            ; //L5589D4CE_42:;					
            L5589D4CE_42:
            ; //	
            ; //_A149B8B01_111:;				
            _A149B8B01_111:
            ; //	sAX	= 0;				
0025D:      	AX	= 0x00
            ; //	sSI	= (int)&_bitp_1_8+0;		
0025E:      	AR	= -3
0025F:      	I1	= rm[BP_SAVE]
00260:      	I1	+= AR
            ; //	asm AR = rm[I1];			
00261:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
00262:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_44;		
00263:      	if ZR	jmp L5589D4CE_44
            ; //	sAX	= 1;				
00264:      	AX	= 0x01
            ; //L5589D4CE_44:;					
            L5589D4CE_44:
            ; //	sfx_CHECKZERO();			
00265:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_45;	
00266:      	if NZ	jmp L5589D4CE_45
            ; //	goto	L5589D4CE_43;			
00267:      	jmp	L5589D4CE_43
            ; //L5589D4CE_45:;					
            L5589D4CE_45:
            ; //	
            ; //_A149B8B01_112:;				
            _A149B8B01_112:
            ; //	sSI	= (int)&_pkey_1_10;		
00268:      	AR	= -4
00269:      	I1	= rm[BP_SAVE]
0026A:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0026B:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
0026C:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
0026D:      	AR	= CX
0026E:      	AX	+= AR
            ; //	sDI	= sAX;				
0026F:      	AR	= AX
00270:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
00271:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
00272:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_47;	
00273:      	if NZ	jmp L5589D4CE_47
            ; //	goto	L5589D4CE_46;			
00274:      	jmp	L5589D4CE_46
            ; //L5589D4CE_47:;					
            L5589D4CE_47:
            ; //_A149B8B01_113:;				
            _A149B8B01_113:
            ; //	sSI	= (int)&_pkey_1_10;		
00275:      	AR	= -4
00276:      	I1	= rm[BP_SAVE]
00277:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00278:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
00279:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
0027A:      	AR	= CX
0027B:      	AX	+= AR
            ; //	sDI	= sAX;				
0027C:      	AR	= AX
0027D:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
0027E:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
0027F:      	AR	= AX
00280:      	P1	= AR
00281:      	P1.hh	= 0
00282:      	fcall	pm[P1]
            ; //L5589D4CE_46:;					
            L5589D4CE_46:
            ; //_A149B8B01_114:;				
            _A149B8B01_114:
            ; //	goto L5589D4CE_48;			
00283:      	jmp	L5589D4CE_48
            ; //L5589D4CE_43:;					
            L5589D4CE_43:
            ; //	
            ; //_A149B8B01_115:;				
            _A149B8B01_115:
            ; //	sSI	= (int)&_pkey_1_10;		
00284:      	AR	= -4
00285:      	I1	= rm[BP_SAVE]
00286:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00287:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
00288:      	AR	= AX
00289:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
0028A:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
0028B:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_50;	
0028C:      	if NZ	jmp L5589D4CE_50
            ; //	goto	L5589D4CE_49;			
0028D:      	jmp	L5589D4CE_49
            ; //L5589D4CE_50:;					
            L5589D4CE_50:
            ; //_A149B8B01_116:;				
            _A149B8B01_116:
            ; //	sSI	= (int)&_pkey_1_10;		
0028E:      	AR	= -4
0028F:      	I1	= rm[BP_SAVE]
00290:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00291:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
00292:      	AR	= AX
00293:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
00294:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
00295:      	AR	= AX
00296:      	P1	= AR
00297:      	P1.hh	= 0
00298:      	fcall	pm[P1]
            ; //L5589D4CE_49:;					
            L5589D4CE_49:
            ; //_A149B8B01_117:;				
            _A149B8B01_117:
            ; //L5589D4CE_48:;					
            L5589D4CE_48:
            ; //_A149B8B01_118:;				
            _A149B8B01_118:
            ; //	goto L5589D4CE_51;			
00299:      	jmp	L5589D4CE_51
            ; //L5589D4CE_40:;					
            L5589D4CE_40:
            ; //	
            ; //_A149B8B01_119:;				
            _A149B8B01_119:
            ; //	sAX	= 0;				
0029A:      	AX	= 0x00
            ; //	sSI	= (int)&_bitp_1_8+0;		
0029B:      	AR	= -3
0029C:      	I1	= rm[BP_SAVE]
0029D:      	I1	+= AR
            ; //	asm AR = rm[I1];			
0029E:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
0029F:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_53;		
002A0:      	if ZR	jmp L5589D4CE_53
            ; //	sAX	= 1;				
002A1:      	AX	= 0x01
            ; //L5589D4CE_53:;					
            L5589D4CE_53:
            ; //	sfx_CHECKZERO();			
002A2:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_54;	
002A3:      	if NZ	jmp L5589D4CE_54
            ; //	goto	L5589D4CE_52;			
002A4:      	jmp	L5589D4CE_52
            ; //L5589D4CE_54:;					
            L5589D4CE_54:
            ; //	
            ; //_A149B8B01_120:;				
            _A149B8B01_120:
            ; //	sSI	= (int)&_pkey_1_10;		
002A5:      	AR	= -4
002A6:      	I1	= rm[BP_SAVE]
002A7:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
002A8:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
002A9:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
002AA:      	AR	= CX
002AB:      	AX	+= AR
            ; //	sDI	= sAX;				
002AC:      	AR	= AX
002AD:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
002AE:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
002AF:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_56;	
002B0:      	if NZ	jmp L5589D4CE_56
            ; //	goto	L5589D4CE_55;			
002B1:      	jmp	L5589D4CE_55
            ; //L5589D4CE_56:;					
            L5589D4CE_56:
            ; //_A149B8B01_121:;				
            _A149B8B01_121:
            ; //	sSI	= (int)&_pkey_1_10;		
002B2:      	AR	= -4
002B3:      	I1	= rm[BP_SAVE]
002B4:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
002B5:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
002B6:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
002B7:      	AR	= CX
002B8:      	AX	+= AR
            ; //	sDI	= sAX;				
002B9:      	AR	= AX
002BA:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
002BB:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
002BC:      	AR	= AX
002BD:      	P1	= AR
002BE:      	P1.hh	= 0
002BF:      	fcall	pm[P1]
            ; //L5589D4CE_55:;					
            L5589D4CE_55:
            ; //_A149B8B01_122:;				
            _A149B8B01_122:
            ; //L5589D4CE_52:;					
            L5589D4CE_52:
            ; //_A149B8B01_123:;				
            _A149B8B01_123:
            ; //L5589D4CE_51:;					
            L5589D4CE_51:
            ; //_A149B8B01_124:;				
            _A149B8B01_124:
            ; //_A149B8B01_125:;				
            _A149B8B01_125:
            ; //	sSI	= (int)&_bits_1_6;		
002C0:      	AR	= -2
002C1:      	I1	= rm[BP_SAVE]
002C2:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
002C3:      	AX	= rm[I1]
            ; //	asm sra AX, 1;				
002C4:      	sra AX, 1//
            ; //	sSI	= (int)&_bits_1_6;		
002C5:      	AR	= -2
002C6:      	I1	= rm[BP_SAVE]
002C7:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
002C8:      	rm[I1]	= AX
            ; //_A149B8B01_126:;				
            _A149B8B01_126:
            ; //	sSI	= (int)&_bitp_1_8;		
002C9:      	AR	= -3
002CA:      	I1	= rm[BP_SAVE]
002CB:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
002CC:      	AX	= rm[I1]
            ; //	asm sra AX, 1;				
002CD:      	sra AX, 1//
            ; //	sSI	= (int)&_bitp_1_8;		
002CE:      	AR	= -3
002CF:      	I1	= rm[BP_SAVE]
002D0:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
002D1:      	rm[I1]	= AX
            ; //_A149B8B01_127:;				
            _A149B8B01_127:
            ; //	sSI	= (int)&_pkey_1_10;		
002D2:      	AR	= -4
002D3:      	I1	= rm[BP_SAVE]
002D4:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
002D5:      	AX	= rm[I1]
            ; //	sSI	= (int)&_pkey_1_10;		
002D6:      	AR	= -4
002D7:      	I1	= rm[BP_SAVE]
002D8:      	I1	+= AR
            ; //	asm AR = 0x0003;			
002D9:      	AR = 0x0003//
            ; //	sCX	= *(__int16*)sSI;		
002DA:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
002DB:      	rm[I1] = CX + AR//
            ; //	goto L5589D4CE_38;			
002DC:      	jmp	L5589D4CE_38
            ; //L5589D4CE_37:;					
            L5589D4CE_37:
            ; //L5589D4CE_32:;					
            L5589D4CE_32:
            ; //_A149B8B01_128:;				
            _A149B8B01_128:
            ; //	return;					
002DD:      	AR	= 5
002DE:      	BP	+= AR
002DF:      	pop	AR
002E0:      	rm[BP_SAVE]	= AR
002E1:      	rets
            ; //_PollingKey3B90E3B1_end:;			
            _PollingKey3B90E3B1_end:
            ; //_A149B8B01_129:;				
            _A149B8B01_129:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_keypad_0E0216C1_s(void)	
            ginit_code_keypad_0E0216C1_s:
            ; //{
            ; //	return;					
002E2:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\KEYPAD_0E0216C1.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\GLOBAL_6037E6D5.S.CODE.ASM> Start=========================
            ; global.c Code Start!!;
            VarRM[0:4095]={
             _songidx8C42F7DA,iSync,uSync 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _InitialDA4A7CC4();
            ; //rjmp void _CheckSongLimit402181B4();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void L0E8FA404_60()			
            L0E8FA404_60:
            ; //{
            ; //_A149B8B01_130:;				
            _A149B8B01_130:
            ; //	
            ; //_A149B8B01_131:;				
            _A149B8B01_131:
            ; //	io[0x16]	= 0x0000;		
002E3:      	AR	= 0x00
002E4:      	io[0x16]	= AR
            ; //_A149B8B01_132:;				
            _A149B8B01_132:
            ; //	io[0x16]	= 0x0000;		
002E5:      	AR	= 0x00
002E6:      	io[0x16]	= AR
            ; //_A149B8B01_133:;				
            _A149B8B01_133:
            ; //	io[0x16]	= 0x0000;		
002E7:      	AR	= 0x00
002E8:      	io[0x16]	= AR
            ; //_A149B8B01_134:;				
            _A149B8B01_134:
            ; //	io[0x16]	= 0x0000;		
002E9:      	AR	= 0x00
002EA:      	io[0x16]	= AR
            ; //_A149B8B01_135:;				
            _A149B8B01_135:
            ; //	io[0x36]	= 0x0000;		
002EB:      	AR	= 0x00
002EC:      	io[0x36]	= AR
            ; //_A149B8B01_136:;				
            _A149B8B01_136:
            ; //	io[0x36]	= 0x0000;		
002ED:      	AR	= 0x00
002EE:      	io[0x36]	= AR
            ; //_A149B8B01_137:;				
            _A149B8B01_137:
            ; //	io[0x36]	= 0x0000;		
002EF:      	AR	= 0x00
002F0:      	io[0x36]	= AR
            ; //_A149B8B01_138:;				
            _A149B8B01_138:
            ; //	io[0x36]	= 0x0000;		
002F1:      	AR	= 0x00
002F2:      	io[0x36]	= AR
            ; //_A149B8B01_139:;				
            _A149B8B01_139:
            ; //	io[0x36]	= 0x0000;		
002F3:      	AR	= 0x00
002F4:      	io[0x36]	= AR
            ; //_A149B8B01_140:;				
            _A149B8B01_140:
            ; //	io[0x36]	= 0x0000;		
002F5:      	AR	= 0x00
002F6:      	io[0x36]	= AR
            ; //_A149B8B01_141:;				
            _A149B8B01_141:
            ; //	io[0x36]	= 0x0000;		
002F7:      	AR	= 0x00
002F8:      	io[0x36]	= AR
            ; //_A149B8B01_142:;				
            _A149B8B01_142:
            ; //	io[0x36]	= 0x0000;		
002F9:      	AR	= 0x00
002FA:      	io[0x36]	= AR
            ; //_A149B8B01_143:;				
            _A149B8B01_143:
            ; //	io[0x3C]	= 0x003F;		
002FB:      	AR	= 0x3F
002FC:      	io[0x3C]	= AR
            ; //_A149B8B01_144:;				
            _A149B8B01_144:
            ; //	sAX	= io[0x3C];			
002FD:      	AR	= io[0x3C]
002FE:      	AX	= AR
            ; //_A149B8B01_145:;				
            _A149B8B01_145:
            ; //	asm	set io[MISC].b9			
002FF:      	set io[MISC].b9
            ; //_A149B8B01_146:;				
            _A149B8B01_146:
            ; //	asm	set io[MISC].b8			
00300:      	set io[MISC].b8
            ; //_A149B8B01_147:;				
            _A149B8B01_147:
            ; //	asm	set io[MISC].b4			
00301:      	set io[MISC].b4
            ; //L0E8FA404_62:;					
            L0E8FA404_62:
            ; //_A149B8B01_148:;				
            _A149B8B01_148:
            ; //	return;					
00302:      	rets
            ; //L0E8FA404_60_end:;				
            L0E8FA404_60_end:
            ; //_A149B8B01_149:;				
            _A149B8B01_149:
            ; //}
            ; //
            ; //rjmp void L0E8FA404_63()			
            L0E8FA404_63:
            ; //{
            ; //_A149B8B01_150:;				
            _A149B8B01_150:
            ; //	
            ; //_A149B8B01_151:;				
            _A149B8B01_151:
            ; //	io[0x04]	= 0x000F;		
00303:      	AR	= 0x0F
00304:      	io[0x04]	= AR
            ; //_A149B8B01_152:;				
            _A149B8B01_152:
            ; //	io[0x05]	= 0xFFFF;		
00305:      	AR	= 0xFFFF
00307:      	io[0x05]	= AR
            ; //_A149B8B01_153:;				
            _A149B8B01_153:
            ; //	io[0x07]	= 0x0000;		
00308:      	AR	= 0x00
00309:      	io[0x07]	= AR
            ; //_A149B8B01_154:;				
            _A149B8B01_154:
            ; //	io[0x08]	= 0xFFFF;		
0030A:      	AR	= 0xFFFF
0030C:      	io[0x08]	= AR
            ; //L0E8FA404_65:;					
            L0E8FA404_65:
            ; //_A149B8B01_155:;				
            _A149B8B01_155:
            ; //	return;					
0030D:      	rets
            ; //L0E8FA404_63_end:;				
            L0E8FA404_63_end:
            ; //_A149B8B01_156:;				
            _A149B8B01_156:
            ; //}
            ; //
            ; //rjmp void _InitialDA4A7CC4()			
            _InitialDA4A7CC4:
            ; //{
            ; //_A149B8B01_157:;				
            _A149B8B01_157:
            ; //	
            ; //_A149B8B01_158:;				
            _A149B8B01_158:
            ; //	sAX	= 0xFFFF;			
0030E:      	AX	= 0xFFFF
            ; //	asm I1 = _songidx8C42F7DA+0;		
00310:      	I1 = _songidx8C42F7DA+0//
            ; //	*(__int16*)sSI	= sAX			
00311:      	rm[I1]	= AX
            ; //_A149B8B01_159:;				
            _A149B8B01_159:
            ; //	sAX	= 0x0000;			
00312:      	AX	= 0x00
            ; //	asm I1 = _iADPCCACC469+0;		
00313:      	I1 = _iADPCCACC469+0//
            ; //	*(__int16*)sSI	= sAX			
00315:      	rm[I1]	= AX
            ; //_A149B8B01_160:;				
            _A149B8B01_160:
            ; //	sAX	= 0x5555;			
00316:      	AX	= 0x5555
            ; //	asm I1 = iSync+0;			
00318:      	I1 = iSync+0//
            ; //	*(__int16*)sSI	= sAX			
00319:      	rm[I1]	= AX
            ; //_A149B8B01_161:;				
            _A149B8B01_161:
            ; //	sAX	= 0xAAAA;			
0031A:      	AX	= 0xAAAA
            ; //	asm I1 = uSync+0;			
0031C:      	I1 = uSync+0//
            ; //	*(__int16*)sSI	= sAX			
0031D:      	rm[I1]	= AX
            ; //_A149B8B01_162:;				
            _A149B8B01_162:
            ; //_A149B8B01_163:;				
            _A149B8B01_163:
            ; //	NEARCALL(L0E8FA404_60);			
0031E:      	call	L0E8FA404_60
            ; //_A149B8B01_164:;				
            _A149B8B01_164:
            ; //_A149B8B01_165:;				
            _A149B8B01_165:
            ; //	NEARCALL(L0E8FA404_63);			
0031F:      	call	L0E8FA404_63
            ; //L0E8FA404_66:;					
            L0E8FA404_66:
            ; //_A149B8B01_166:;				
            _A149B8B01_166:
            ; //	return;					
00320:      	rets
            ; //_InitialDA4A7CC4_end:;				
            _InitialDA4A7CC4_end:
            ; //_A149B8B01_167:;				
            _A149B8B01_167:
            ; //}
            ; //
            ; //rjmp void _CheckSongLimit402181B4()		
            _CheckSongLimit402181B4:
            ; //{
            ; //_A149B8B01_168:;				
            _A149B8B01_168:
            ; //	
            ; //_A149B8B01_169:;				
            _A149B8B01_169:
            ; //	asm I1 = _songidx8C42F7DA+0;		
00321:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
00322:      	AX	= rm[I1]
            ; //	sCX	= 0x0000;			
00323:      	CX	= 0x00
            ; //	sfx_CMP_AX_CX_JL();			
00324:      	pch	= sfx_CMP_AX_CX_JL
00325:      	lcall	sfx_CMP_AX_CX_JL
            ; //	if(__je__)	goto L0E8FA404_69;	
00326:      	if ZR	jmp L0E8FA404_69
            ; //	goto	L0E8FA404_68;			
00327:      	jmp	L0E8FA404_68
            ; //L0E8FA404_69:;					
            L0E8FA404_69:
            ; //	
            ; //_A149B8B01_170:;				
            _A149B8B01_170:
            ; //	asm I1 = mp_songcnt+0;			
00328:      	I1 = mp_songcnt+0//
            ; //	sAX	= *(__int16*)sSI;		
00329:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
0032A:      	CX	= 0x01
            ; //	sAX	= sAX - sCX;			
0032B:      	AR	= CX
0032C:      	AX	-= AR
            ; //	asm I1 = _songidx8C42F7DA+0;		
0032D:      	I1 = _songidx8C42F7DA+0//
            ; //	*(__int16*)sSI	= sAX			
0032E:      	rm[I1]	= AX
            ; //	goto L0E8FA404_70;			
0032F:      	jmp	L0E8FA404_70
            ; //L0E8FA404_68:;					
            L0E8FA404_68:
            ; //	
            ; //_A149B8B01_171:;				
            _A149B8B01_171:
            ; //	asm I1 = _songidx8C42F7DA+0;		
00330:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
00331:      	AX	= rm[I1]
            ; //	asm I1 = mp_songcnt+0;			
00332:      	I1 = mp_songcnt+0//
            ; //	asm CX = rm[I1];			
00333:      	CX = rm[I1]//
            ; //	sfx_CMP_AX_CX_JGE();			
00334:      	pch	= sfx_CMP_AX_CX_JGE
00335:      	lcall	sfx_CMP_AX_CX_JGE
            ; //	if(__je__)	goto L0E8FA404_72;	
00336:      	if ZR	jmp L0E8FA404_72
            ; //	goto	L0E8FA404_71;			
00337:      	jmp	L0E8FA404_71
            ; //L0E8FA404_72:;					
            L0E8FA404_72:
            ; //	
            ; //_A149B8B01_172:;				
            _A149B8B01_172:
            ; //	sAX	= 0x0000;			
00338:      	AX	= 0x00
            ; //	asm I1 = _songidx8C42F7DA+0;		
00339:      	I1 = _songidx8C42F7DA+0//
            ; //	*(__int16*)sSI	= sAX			
0033A:      	rm[I1]	= AX
            ; //L0E8FA404_71:;					
            L0E8FA404_71:
            ; //_A149B8B01_173:;				
            _A149B8B01_173:
            ; //L0E8FA404_70:;					
            L0E8FA404_70:
            ; //_A149B8B01_174:;				
            _A149B8B01_174:
            ; //L0E8FA404_67:;					
            L0E8FA404_67:
            ; //_A149B8B01_175:;				
            _A149B8B01_175:
            ; //	return;					
0033B:      	rets
            ; //_CheckSongLimit402181B4_end:;			
            _CheckSongLimit402181B4_end:
            ; //_A149B8B01_176:;				
            _A149B8B01_176:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_global_6037E6D5_s(void)	
            ginit_code_global_6037E6D5_s:
            ; //{
            ; //	return;					
0033C:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\GLOBAL_6037E6D5.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\SUPPORT_EBA84A55.S.CODE.ASM> Start=========================
            ; support.c Code Start!!;
            VarRM[0:4095]={
             _adpch30670376[72],_adpFLTG0FBE3CB5[4],_iADPCCACC469 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _playADPCMBACD5AFD(__int16 _index_0_4);
            ; //rjmp void _StopAllADPCM9255018D();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _playADPCMBACD5AFD(__int16 _index_0_4)
            _playADPCMBACD5AFD:
            ; //{
            ; //	__int16 _i_1_2;
            ; //	__int16 _p_1_4;
            ; //	__int16 _q_1_6;
            ; //						
0033D:      	AR	= rm[BP_SAVE]
0033E:      	push	AR
0033F:      	AR	= BP
00340:      	rm[BP_SAVE]	= AR
00341:      	AR	 = -3
00342:      	BP	+= AR
            ; //_A149B8B01_177:;				
            _A149B8B01_177:
            ; //_A149B8B01_178:;				
            _A149B8B01_178:
            ; //	asm AX = _adpch30670376+0;		
00343:      	AX = _adpch30670376+0//
            ; //	sSI	= (int)&_p_1_4;			
00344:      	AR	= -1
00345:      	I1	= rm[BP_SAVE]
00346:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00347:      	rm[I1]	= AX
            ; //_A149B8B01_179:;				
            _A149B8B01_179:
            ; //	_i_1_2+0	= 0x00;			
00348:      	I1	= rm[BP_SAVE]
00349:      	AR	= 0x00
0034A:      	rm[I1]	= AR
            ; //LB7C4B5D5_75:;					
            LB7C4B5D5_75:
            ; //	sSI	= (int)&_i_1_2;			
0034B:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0034C:      	AX	= rm[I1]
            ; //	sCX	= 0x0004;			
0034D:      	CX	= 0x04
            ; //	sfx_CMP_AX_CX_JL();			
0034E:      	pch	= sfx_CMP_AX_CX_JL
0034F:      	lcall	sfx_CMP_AX_CX_JL
            ; //	if(__je__)	goto LB7C4B5D5_79;	
00350:      	if ZR	jmp LB7C4B5D5_79
            ; //	goto	LB7C4B5D5_77;			
00351:      	jmp	LB7C4B5D5_77
            ; //LB7C4B5D5_79:;					
            LB7C4B5D5_79:
            ; //	goto LB7C4B5D5_76;			
00352:      	jmp	LB7C4B5D5_76
            ; //LB7C4B5D5_78:;					
            LB7C4B5D5_78:
            ; //	sSI	= (int)&_i_1_2;			
00353:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00354:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
00355:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
00356:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
00357:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
00358:      	rm[I1] = CX + AR//
            ; //	goto LB7C4B5D5_75;			
00359:      	jmp	LB7C4B5D5_75
            ; //LB7C4B5D5_76:;					
            LB7C4B5D5_76:
            ; //	
            ; //_A149B8B01_180:;				
            _A149B8B01_180:
            ; //	sSI	= (int)&_p_1_4;			
0035A:      	AR	= -1
0035B:      	I1	= rm[BP_SAVE]
0035C:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0035D:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
0035E:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
0035F:      	AR	= CX
00360:      	AX	+= AR
            ; //	sSI	= sAX;				
00361:      	AR	= AX
00362:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI++;		
00363:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
00364:      	DX	= rm[I1--]
            ; //	sfx_CHECKZEROLONG();			
00365:      	AR	= AX
00366:      	AR	|= DX
            ; //	if(__jz__)	goto LB7C4B5D5_81;	
00367:      	if ZR	jmp LB7C4B5D5_81
            ; //	goto	LB7C4B5D5_80;			
00368:      	jmp	LB7C4B5D5_80
            ; //LB7C4B5D5_81:;					
            LB7C4B5D5_81:
            ; //	
            ; //_A149B8B01_181:;				
            _A149B8B01_181:
            ; //_A149B8B01_182:;				
            _A149B8B01_182:
            ; //	sAX	= 0x0012;			
00369:      	AX	= 0x12
            ; //	PUSH(sAX);				
0036A:      	push	AX
            ; //	sAX	= 0x0000;			
0036B:      	AX	= 0x00
            ; //	PUSH(sAX);				
0036C:      	push	AX
            ; //	sSI	= (int)&_p_1_4;			
0036D:      	AR	= -1
0036E:      	I1	= rm[BP_SAVE]
0036F:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00370:      	AX	= rm[I1]
            ; //	sDX	= 0;				
00371:      	DX	= 0x00
            ; //	PUSH(sDX);				
00372:      	push	DX
            ; //	PUSH(sAX);				
00373:      	push	AX
            ; //	_memset5A9D755A(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2], STACK[sSP + 3]);
00374:      	pch	= _memset5A9D755A
00375:      	lcall	_memset5A9D755A
            ; //	RESTORESP(4);				
00376:      	AR	= 4
00377:      	BP	+= AR
            ; //_A149B8B01_183:;				
            _A149B8B01_183:
            ; //	asm AX = #_adpdata32993E3B+0;		
00378:      	AX = #_adpdata32993E3B+0//
            ; //	PUSH(sAX);				
0037A:      	push	AX
            ; //	sSI	= (int)&_index_0_4;		
0037B:      	AR	= 2
0037C:      	I1	= rm[BP_SAVE]
0037D:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0037E:      	AX	= rm[I1]
            ; //	sCX	= 0x0004;			
0037F:      	CX	= 0x04
            ; //	sfx_IMUL_AX_CX();			
00380:      	pch	= sfx_IMUL_AX_CX
00381:      	lcall	sfx_IMUL_AX_CX
            ; //	sCX	= POP();			
00382:      	pop	CX
            ; //	sAX	= sAX + sCX;			
00383:      	AR	= CX
00384:      	AX	+= AR
            ; //	sSI	= (int)&_q_1_6;			
00385:      	AR	= -2
00386:      	I1	= rm[BP_SAVE]
00387:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00388:      	rm[I1]	= AX
            ; //_A149B8B01_184:;				
            _A149B8B01_184:
            ; //	sSI	= (int)&_p_1_4;			
00389:      	AR	= -1
0038A:      	I1	= rm[BP_SAVE]
0038B:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0038C:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
0038D:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
0038E:      	AR	= CX
0038F:      	AX	+= AR
            ; //	PUSH(sAX);				
00390:      	push	AX
            ; //	sSI	= (int)&_q_1_6;			
00391:      	AR	= -2
00392:      	I1	= rm[BP_SAVE]
00393:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00394:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
00395:      	AR	= AX
00396:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI++;		
00397:      	AX	= pm[P1++]
            ; //	sDX	= *(__int16*)sDI--;		
00398:      	DX	= pm[P1--]
            ; //	sSI	= POP();			
00399:      	pop	I1
            ; //	sfx_STORSILONG();			
0039A:      	rm[I1++]	= AX
0039B:      	rm[I1--]	= DX
            ; //_A149B8B01_185:;				
            _A149B8B01_185:
            ; //	sSI	= (int)&_p_1_4;			
0039C:      	AR	= -1
0039D:      	I1	= rm[BP_SAVE]
0039E:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0039F:      	AX	= rm[I1]
            ; //	sCX	= 0x0011;			
003A0:      	CX	= 0x11
            ; //	sAX	= sAX + sCX;			
003A1:      	AR	= CX
003A2:      	AX	+= AR
            ; //	PUSH(sAX);				
003A3:      	push	AX
            ; //	sSI	= (int)&_q_1_6;			
003A4:      	AR	= -2
003A5:      	I1	= rm[BP_SAVE]
003A6:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003A7:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
003A8:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
003A9:      	AR	= CX
003AA:      	AX	+= AR
            ; //	sDI	= sAX;				
003AB:      	AR	= AX
003AC:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
003AD:      	AX	= pm[P1]
            ; //	sSI	= POP();			
003AE:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
003AF:      	rm[I1]	= AX
            ; //_A149B8B01_186:;				
            _A149B8B01_186:
            ; //	asm AX = _adpFLTG0FBE3CB5+0;		
003B0:      	AX = _adpFLTG0FBE3CB5+0//
            ; //	PUSH(sAX);				
003B2:      	push	AX
            ; //	sSI	= (int)&_i_1_2;			
003B3:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
003B4:      	AX	= rm[I1]
            ; //	
            ; //	sCX	= POP();			
003B5:      	pop	CX
            ; //	sAX	= sAX + sCX;			
003B6:      	AR	= CX
003B7:      	AX	+= AR
            ; //	PUSH(sAX);				
003B8:      	push	AX
            ; //	sSI	= (int)&_q_1_6;			
003B9:      	AR	= -2
003BA:      	I1	= rm[BP_SAVE]
003BB:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003BC:      	AX	= rm[I1]
            ; //	sCX	= 0x0003;			
003BD:      	CX	= 0x03
            ; //	sAX	= sAX + sCX;			
003BE:      	AR	= CX
003BF:      	AX	+= AR
            ; //	sDI	= sAX;				
003C0:      	AR	= AX
003C1:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
003C2:      	AX	= pm[P1]
            ; //	sSI	= POP();			
003C3:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
003C4:      	rm[I1]	= AX
            ; //_A149B8B01_187:;				
            _A149B8B01_187:
            ; //	sAX	= 0x0001;			
003C5:      	AX	= 0x01
            ; //	goto LB7C4B5D5_74;			
003C6:      	jmp	LB7C4B5D5_74
            ; //LB7C4B5D5_80:;					
            LB7C4B5D5_80:
            ; //_A149B8B01_188:;				
            _A149B8B01_188:
            ; //_A149B8B01_189:;				
            _A149B8B01_189:
            ; //	sSI	= (int)&_p_1_4;			
003C7:      	AR	= -1
003C8:      	I1	= rm[BP_SAVE]
003C9:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003CA:      	AX	= rm[I1]
            ; //	sSI	= (int)&_p_1_4;			
003CB:      	AR	= -1
003CC:      	I1	= rm[BP_SAVE]
003CD:      	I1	+= AR
            ; //	asm AR = 0x0012;			
003CE:      	AR = 0x0012//
            ; //	sCX	= *(__int16*)sSI;		
003CF:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
003D0:      	rm[I1] = CX + AR//
            ; //	goto LB7C4B5D5_78;			
003D1:      	jmp	LB7C4B5D5_78
            ; //LB7C4B5D5_77:;					
            LB7C4B5D5_77:
            ; //_A149B8B01_190:;				
            _A149B8B01_190:
            ; //_A149B8B01_191:;				
            _A149B8B01_191:
            ; //	sAX	= 0x0000;			
003D2:      	AX	= 0x00
            ; //	goto LB7C4B5D5_74;			
003D3:      	jmp	LB7C4B5D5_74
            ; //LB7C4B5D5_74:;					
            LB7C4B5D5_74:
            ; //_A149B8B01_192:;				
            _A149B8B01_192:
            ; //	return;					
003D4:      	AR	= 3
003D5:      	BP	+= AR
003D6:      	pop	AR
003D7:      	rm[BP_SAVE]	= AR
003D8:      	rets
            ; //_playADPCMBACD5AFD_end:;			
            _playADPCMBACD5AFD_end:
            ; //_A149B8B01_193:;				
            _A149B8B01_193:
            ; //}
            ; //
            ; //rjmp void _StopAllADPCM9255018D()		
            _StopAllADPCM9255018D:
            ; //{
            ; //	__int16 _i_1_2;
            ; //	__int16 _p_1_4;
            ; //						
003D9:      	AR	= rm[BP_SAVE]
003DA:      	push	AR
003DB:      	AR	= BP
003DC:      	rm[BP_SAVE]	= AR
003DD:      	AR	 = -2
003DE:      	BP	+= AR
            ; //_A149B8B01_194:;				
            _A149B8B01_194:
            ; //_A149B8B01_195:;				
            _A149B8B01_195:
            ; //	_i_1_2+0	= 0x04;			
003DF:      	I1	= rm[BP_SAVE]
003E0:      	AR	= 0x04
003E1:      	rm[I1]	= AR
            ; //_A149B8B01_196:;				
            _A149B8B01_196:
            ; //	asm AX = _adpch30670376+0;		
003E2:      	AX = _adpch30670376+0//
            ; //	sSI	= (int)&_p_1_4;			
003E3:      	AR	= -1
003E4:      	I1	= rm[BP_SAVE]
003E5:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
003E6:      	rm[I1]	= AX
            ; //LB7C4B5D5_84:;					
            LB7C4B5D5_84:
            ; //_A149B8B01_197:;				
            _A149B8B01_197:
            ; //	sSI	= (int)&_i_1_2;			
003E7:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
003E8:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
003E9:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
003EA:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
003EB:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
003EC:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
003ED:      	AR	= AX
            ; //	if(__jnz__)	goto LB7C4B5D5_85;	
003EE:      	if NZ	jmp LB7C4B5D5_85
            ; //	goto	LB7C4B5D5_83;			
003EF:      	jmp	LB7C4B5D5_83
            ; //LB7C4B5D5_85:;					
            LB7C4B5D5_85:
            ; //	
            ; //_A149B8B01_198:;				
            _A149B8B01_198:
            ; //	sSI	= (int)&_p_1_4;			
003F0:      	AR	= -1
003F1:      	I1	= rm[BP_SAVE]
003F2:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003F3:      	AX	= rm[I1]
            ; //	sCX	= 0x000A;			
003F4:      	CX	= 0x0A
            ; //	sAX	= sAX + sCX;			
003F5:      	AR	= CX
003F6:      	AX	+= AR
            ; //	PUSH(sAX);				
003F7:      	push	AX
            ; //	sAX	= 0x0000;			
003F8:      	AX	= 0x00
            ; //	sDX	= 0x0000;			
003F9:      	DX	= 0x00
            ; //	sSI	= POP();			
003FA:      	pop	I1
            ; //	sfx_STORSILONG();			
003FB:      	rm[I1++]	= AX
003FC:      	rm[I1--]	= DX
            ; //_A149B8B01_199:;				
            _A149B8B01_199:
            ; //	sSI	= (int)&_p_1_4;			
003FD:      	AR	= -1
003FE:      	I1	= rm[BP_SAVE]
003FF:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00400:      	AX	= rm[I1]
            ; //	sSI	= (int)&_p_1_4;			
00401:      	AR	= -1
00402:      	I1	= rm[BP_SAVE]
00403:      	I1	+= AR
            ; //	asm AR = 0x0012;			
00404:      	AR = 0x0012//
            ; //	sCX	= *(__int16*)sSI;		
00405:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
00406:      	rm[I1] = CX + AR//
            ; //	goto LB7C4B5D5_84;			
00407:      	jmp	LB7C4B5D5_84
            ; //LB7C4B5D5_83:;					
            LB7C4B5D5_83:
            ; //LB7C4B5D5_82:;					
            LB7C4B5D5_82:
            ; //_A149B8B01_200:;				
            _A149B8B01_200:
            ; //	return;					
00408:      	AR	= 2
00409:      	BP	+= AR
0040A:      	pop	AR
0040B:      	rm[BP_SAVE]	= AR
0040C:      	rets
            ; //_StopAllADPCM9255018D_end:;			
            _StopAllADPCM9255018D_end:
            ; //_A149B8B01_201:;				
            _A149B8B01_201:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_support_EBA84A55_s(void)	
            ginit_code_support_EBA84A55_s:
            ; //{
            ; //	return;					
0040D:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //__int16 _adpdata32993E3B[40] = {		
            _adpdata32993E3B:
            ; //	(int)&ADPCM_CH0_Data, (int)&ADPCM_CH0_Data.h|0x0800, 0x1FFF, 0x003F, (int)&ADPCM_CH1_Data, (int)&ADPCM_CH1_Data.h|0x0800, 0x3FFF, 0x003F, 
0040E:      DW #ADPCM_CH0_Data,#ADPCM_CH0_Data.h|0x0800,0x1FFF,0x003F,#ADPCM_CH1_Data,#ADPCM_CH1_Data.h|0x0800,0x3FFF,0x003F,
            ; //	(int)&ADPCM_CH2_Data, (int)&ADPCM_CH2_Data.h|0x0800, 0x3FFF, 0x003F, (int)&ADPCM_CH3_Data, (int)&ADPCM_CH3_Data.h|0x0800, 0x3FFF, 0x003F, 
00416:      DW #ADPCM_CH2_Data,#ADPCM_CH2_Data.h|0x0800,0x3FFF,0x003F,#ADPCM_CH3_Data,#ADPCM_CH3_Data.h|0x0800,0x3FFF,0x003F,
            ; //	(int)&ADPCM_CH4_Data, (int)&ADPCM_CH4_Data.h|0x0800, 0x3FFF, 0x003F, (int)&ADPCM_CH5_Data, (int)&ADPCM_CH5_Data.h|0x0800, 0x3FFF, 0x003F, 
0041E:      DW #ADPCM_CH4_Data,#ADPCM_CH4_Data.h|0x0800,0x3FFF,0x003F,#ADPCM_CH5_Data,#ADPCM_CH5_Data.h|0x0800,0x3FFF,0x003F,
            ; //	(int)&ADPCM_CH6_Data, (int)&ADPCM_CH6_Data.h|0x0800, 0x1FFF, 0x003F, (int)&ADPCM_CH7_Data, (int)&ADPCM_CH7_Data.h|0x0800, 0x3FFF, 0x003F, 
00426:      DW #ADPCM_CH6_Data,#ADPCM_CH6_Data.h|0x0800,0x1FFF,0x003F,#ADPCM_CH7_Data,#ADPCM_CH7_Data.h|0x0800,0x3FFF,0x003F,
            ; //	(int)&ADPCM_CH8_Data, (int)&ADPCM_CH8_Data.h|0x0800, 0x3FFF, 0x003F, 0x0000, 0x0000, 0x0000, 0x0000
0042E:      DW #ADPCM_CH8_Data,#ADPCM_CH8_Data.h|0x0800,0x3FFF,0x003F,0x0000,0x0000,0x0000,0x0000,
            ; //};
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\SUPPORT_EBA84A55.S.CODE.ASM> End=========================
            
            ;=========================Include <ASMFUNC\INTERRUPT.ASM> Start=========================
            
            Pwm_process:
00436:      	clr             io[INTREQ].b0
            
00437:      	push		CBL
00438:      	push		I0
            
            	; CBL = I0_CIRCLE_ALIGN_64;
00439:      		AR=		6
0043A:      		CBL=		AR
            
0043B:      		I0=		_mp_outbufE6EABE1D
0043C:      		AR=		rm[I0]
0043D:      		I0=		AR
            
0043E:      		AR=		rm[I0++2]
0043F:      		io[DACL]=	AR
00440:      		AR=		rm[I0++2]
00441:      		io[DACL]=	AR
00442:      		AR=		rm[I0++2]
00443:      		io[DACL]=	AR
00444:      		AR=		rm[I0++2]
00445:      		io[DACL]=	AR
            
            	; mp.outbuf += 4;
00446:      		AR=		I0
00447:      		I0=		_mp_outbufE6EABE1D
00448:      		rm[I0]=		AR
            
            
00449:      	pop		I0
0044A:      	pop		CBL
0044B:      	reti
            Pwm_process_end:
            
            
            
            ;=========================Include <ASMFUNC\INTERRUPT.ASM> End=========================
            
            ;=========================Include <ASMFUNC\SUPPORT.ASM> Start=========================
            
            
            #define ADPDEC_PRAM_START_ADR	0x0200
            
            #define ADPDEC_BUFFER_COUNT	15
            
            
            ///////////////////////////////////////////////////////////////////////////////////////////////
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ADPCM_decoder:
0044C:      	push		I0
0044D:      	PCH=            SDSP_ADPCM_4Bit_SingleCH_decoder
0044E:              lcall           SDSP_ADPCM_4Bit_SingleCH_decoder
0044F:              AX=		0
00450:              if NZ jmp	ADPCM_4Bit_decoder_A
00451:              AX=		1
            ADPCM_4Bit_decoder_A:
00452:      	pop		I0
00453:      	rets
            
            
            ; --------------------------
            
            ClearAudioBuffer:
            ; {
00454:      	CX=		ADPDEC_BUFFER_COUNT
00455:      	I1=		PCMY
00456:      	AR=		0
            @clrbuf_loop_1659:
00457:      	rm[I1++]=	AR
00458:      	rm[I1++]=	AR
00459:      	loop		@clrbuf_loop_1659
            
0045A:      	rets
            ; }
            
            
            ; ------------------------------------------------
            
            
            ; ADPCM structure
            
            ; typedef struct _ADPSTRU {
            	; int PCMData;
            	; int ADPDEC[9];
            	; lptr_t adpptr;
            	; int FLTI[4];
            	; int FLTA;
            	; int FLTP;
            ; }ADPSTRU;
            
            
            ; ------------------------------------------------
            
            ADPCM_ChxGetBts:
            ; {
0045B:      	push		I1
0045C:      	push		AX
0045D:      	push		P1
0045E:      	AR=		P1.hh
0045F:      	push		AR
            
            	; LoadAR(_lptr_read(ADPCM_Tmpi->adpptr++));
00460:      		I1=		rm[ADPCM_Tmpi]
00461:      		AR=		10
00462:      		I1=		I1 + AR
00463:      		P1=		rm[I1++]	; low
00464:      		AR=		rm[I1]		; high
00465:      		P1.hh=		AR
            
00466:      		AX=		pm[P1++]
            
00467:      		AR=		P1.hh		; high
00468:      		set		AR.b11
00469:      		rm[I1--]=	AR
0046A:      		rm[I1]=		P1		; low
            
0046B:      	pop		AR
0046C:      	P1.hh=		AR
0046D:      	pop		P1
0046E:      	AR=		AX
0046F:      	pop		AX
00470:      	pop		I1
00471:      	rets
            ; }
            
            
            ; --------------------------------------------------
            
            ADPDEC_PRAM_START:
            
            #ifdef ADPCM_USE_PRAM
            __DecodeChannel:
            #else
            DecodeChannel:
            #endif
            ; {
            	; if(ADPCM_Tmpi->adpptr)
00472:      		I1=		rm[ADPCM_Tmpi]
00473:      		AR=		10
00474:      		I1=		I1 + AR
00475:      		AR=		rm[I1++]
00476:      		AX=		rm[I1]
00477:      		AR=		AR | AX
00478:      		if ZR jmp	@decodech_label_1654
            	; {
            		; BackupFilter();
00479:      			I1=		rm[ADPCM_Tmpi]
0047A:      			AR=		12
0047B:      			I1=		I1 + AR
0047C:      			FLTI=		rm[I1++]
0047D:      			FLTI=		rm[I1++]
0047E:      			FLTI=		rm[I1++]
0047F:      			FLTI=		rm[I1++]
00480:      			FLTA=		rm[I1++]
00481:      			FLTP=		rm[I1]
00482:      			AR=		0x3F
00483:      			FLTG=		AR
00484:      			AR=		FLTO
            
            		; set_I0(PCMYIN_PTR);
00485:      			I0=		PCMY
            
            		; for(i = 0; i < 32; i++)
00486:      			CX=		ADPDEC_BUFFER_COUNT
            		@decodech_loop_1408:
            		; {
            			; if(!FA())
00487:      				if FA jmp	@decodech_label_1408
            			; {
            				; if(ADPCM_decoder())
00488:      					push		CX
00489:      					PCH=		ADPCM_decoder
0048A:      					lcall		ADPCM_decoder
0048B:      					pop		CX
0048C:      					AR=		AX
0048D:      					if ZR jmp	@decodech_label_1658
            				; {
            					; ADPCM_Tmpi->adpptr = 0;
0048E:      						I1=		rm[ADPCM_Tmpi]
0048F:      						AR=		10
00490:      						I1=		I1 + AR
00491:      						AR=		0
00492:      						rm[I1++]=	AR
00493:      						rm[I1++]=	AR
            
            					; return;
00494:      						P1.hh=		0
00495:      						rets
            				; }
            				@decodech_label_1658:
            
            				; FLTI = ADPCM_Tmpi->PCMData;
00496:      					I1=		rm[ADPCM_Tmpi]
00497:      					AR=		rm[I1]
00498:      					FLTI=		AR
            			; }
            			@decodech_label_1408:
            
            
            			; MixToBuf();
00499:      				MX=		1
0049A:      				AR=		FLTO
            			#ifdef _MSPEECHDSP_
            				MULSS
            			#else
0049B:      				MR=		MX * AR
            			#endif
0049C:      				AX=		rm[I0]
0049D:      				AR=		MR0
0049E:      				rm[I0++]=	AR + AX
0049F:      				AX=		rm[I0]
004A0:      				AR=		MR1
004A1:      				rm[I0++]=	AR + AX + C
004A2:      			loop		@decodech_loop_1408
            		; }
            
            		; BackupFilter();
004A3:      			I1=		rm[ADPCM_Tmpi]
004A4:      			AR=		12
004A5:      			I1=		I1 + AR
004A6:      			rm[I1++]=	FLTI
004A7:      			rm[I1++]=	FLTI
004A8:      			rm[I1++]=	FLTI
004A9:      			rm[I1++]=	FLTI
004AA:      			rm[I1++]=	FLTA
            
            	; }
            	@decodech_label_1654:
            
004AB:      	P1.hh=		0
004AC:      	rets
            ; }
            
            
            ; --------------------------------------------------
            
            
            ; --------------------------------------------------
            
            
            ; ---------------------------------------------------
            ; Mix mp@tinyrender to PCMY with satv
            ; ---------------------------------------------------
            
            #ifdef ADPCM_USE_PRAM
            __MixAll:
            #else
            MixAll:
            #endif
004AD:      	CX=		ADPDEC_BUFFER_COUNT
004AE:      	I1=		rm[mp_inbuf]
004AF:      	I0=		PCMY
004B0:      	AR=		SATV
            @Do_Satv_lp:
004B1:      	AR=		rm[I0++]
004B2:      	AX=		rm[I1++]
004B3:      	AR=		AR + AX
004B4:      	SATV=		AR
            
004B5:      	AR=		rm[I0++]
004B6:      	AX=		rm[I1--]
004B7:      	AR=		AR + AX + C
            
004B8:      	SATV=		AR
004B9:      	AR=		SATV
004BA:      	rm[I1++2]=	AR
004BB:      	loop		@Do_Satv_lp
            
004BC:      	AR=		rm[mp_inbuf]
004BD:      	not		AR.b5
004BE:      	rm[mp_inbuf]=AR
004BF:      	P1.hh=		0
004C0:      	rets
            
            ADPDEC_PRAM_START_END:
            
            ; ---------------------------------------------------
            
            
            #ifdef ADPCM_USE_PRAM
            
            DecodeChannel:
            	AR=		#__DecodeChannel
            	P1=		#ADPDEC_PRAM_START
            	P1=		AR - P1
            	AR=		ADPDEC_PRAM_START_ADR
            	P1=		P1 + AR
            	P1.hh=		RAMBANK
            	fjmp		pm[P1]
            
            
            MixAll:
            	AR=		#__MixAll
            	P1=		#ADPDEC_PRAM_START
            	P1=		AR - P1
            	AR=		ADPDEC_PRAM_START_ADR
            	P1=		P1 + AR
            	P1.hh=		RAMBANK
            	fjmp		pm[P1]
            
            #endif
            
            ; ----------------------------------------------------
            
            ; ---------------------------------------------------
            
            SyncNow:
            ; {
004C1:      	AX=		rm[mp_inbuf]
004C2:      	AR=		rm[mp_outbuf]
004C3:      	AR=		AR ^ AX
004C4:      	test		AR.b5		; ~~ long address
004C5:      	if ZR jmp	@syncnow_label_1503
            
004C6:      	AX=		1
004C7:      	rets
            @syncnow_label_1503:
004C8:      	AX=		0
004C9:      	rets
            ; }
            
            
            
            
            ; ---------------------------------------------------
            
            
            
            ADPCM_ChX_init:
            
            #ifdef ADPCM_USE_PRAM
            
            	P1=		ADPDEC_PRAM_START_ADR
            	P1.hh=		RAMBANK
            	CX=		#ADPDEC_PRAM_START_END
            	AR=		#ADPDEC_PRAM_START
            	CX=		CX - AR
            	P0=		#ADPDEC_PRAM_START
            	jmp		@adpcm_init_label_1122
            @adpcm_init_loop_1122:
            	AR=		pm[P0++]
            	pm[P1++]=	AR
            @adpcm_init_label_1122:
            	loop		@adpcm_init_loop_1122
            
            #endif
            
004CA:      	P1.hh=		0
004CB:      	P0.hh=		0
004CC:      	rets
            ;=========================Include <ASMFUNC\SUPPORT.ASM> End=========================
            
            ;=========================Include <DEPS\DATA_0EBCA7F9.S.CODE.ASM> Start=========================
            ; data.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //naked void ADPCM_CH0_Data();
            ; //naked void ADPCM_CH1_Data();
            ; //naked void ADPCM_CH2_Data();
            ; //naked void ADPCM_CH3_Data();
            ; //naked void ADPCM_CH4_Data();
            ; //naked void ADPCM_CH5_Data();
            ; //naked void ADPCM_CH6_Data();
            ; //naked void ADPCM_CH7_Data();
            ; //naked void ADPCM_CH8_Data();
            ; //naked void MidiData();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_data_0EBCA7F9_s(void)	
            ginit_code_data_0EBCA7F9_s:
            ; //{
            ; //	return;					
004CD:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //naked void ADPCM_CH0_Data()			
            ADPCM_CH0_Data:
            ; //{
            ; //	asm	DW "adpcm\bird_8000_4-12.XAM"	
0180B:      DW "adpcm\bird_8000_4-12.XAM"
            ; //}
            ; //
            ; //naked void ADPCM_CH1_Data()			
            ADPCM_CH1_Data:
            ; //{
            ; //	asm	DW "adpcm\horse_16000_4-12.xam"	
03B4F:      DW "adpcm\horse_16000_4-12.xam"
            ; //}
            ; //
            ; //naked void ADPCM_CH2_Data()			
            ADPCM_CH2_Data:
            ; //{
            ; //	asm	DW "adpcm\2cat_16000_4-12.XAM"	
05321:      DW "adpcm\2cat_16000_4-12.XAM"
            ; //}
            ; //
            ; //naked void ADPCM_CH3_Data()			
            ADPCM_CH3_Data:
            ; //{
            ; //	asm	DW "adpcm\cat_16000_4-12.XAM"	
05B66:      DW "adpcm\cat_16000_4-12.XAM"
            ; //}
            ; //
            ; //naked void ADPCM_CH4_Data()			
            ADPCM_CH4_Data:
            ; //{
            ; //	asm	DW "adpcm\Dog_Barking_002_16000_4-12.XAM"
06EA0:      DW "adpcm\Dog_Barking_002_16000_4-12.XAM"
            ; //}
            ; //
            ; //naked void ADPCM_CH5_Data()			
            ADPCM_CH5_Data:
            ; //{
            ; //	asm	DW "adpcm\duck_A1S_16000_4-12.XAM"
07867:      DW "adpcm\duck_A1S_16000_4-12.XAM"
            ; //}
            ; //
            ; //naked void ADPCM_CH6_Data()			
            ADPCM_CH6_Data:
            ; //{
            ; //	asm	DW "adpcm\frog_5th_8000_4-12.XAM"
07B65:      DW "adpcm\frog_5th_8000_4-12.XAM"
            ; //}
            ; //
            ; //naked void ADPCM_CH7_Data()			
            ADPCM_CH7_Data:
            ; //{
            ; //	asm	DW "adpcm\Insect_chirping_16000_4-12.XAM"
07D75:      DW "adpcm\Insect_chirping_16000_4-12.XAM"
            ; //}
            ; //
            ; //naked void ADPCM_CH8_Data()			
            ADPCM_CH8_Data:
            ; //{
            ; //	asm	DW "adpcm\sheep_16000_4-12.XAM"	
0998F:      DW "adpcm\sheep_16000_4-12.XAM"
            ; //}
            ; //
            ; //naked void MidiData()				
            MidiData:
            ; //{
            ; //	asm	DW "midi\piano_32K_6CH.md2"	
0A13B:      DW "midi\piano_32K_6CH.md2"
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\DATA_0EBCA7F9.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\MEMSET_CDCF17ED.S.CODE.ASM> Start=========================
            ; C:\TRITAN\FDSP-IDE\tools\CC\lib\libc\memset.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rcall rjmp void _memset_sC3E11DB1(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8);
            ; //rcall rjmp void _memset_rC7200006(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8);
            ; //rcall rjmp void _memset5A9D755A(__int16 _s_0_4_0, __int16 _s_0_4_1, __int16 _c_0_8, __int16 _n_0_10);
            ; //
            ; //
            ; //
            ; //
            .code
            ; //rcall rjmp void _memset_sC3E11DB1(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8)
            _memset_sC3E11DB1:
            ; //{
            ; //	__int16 _ret_1_2;
            ; //						
004CE:      	AR	= rm[BP_SAVE]
004CF:      	push	AR
004D0:      	AR	= BP
004D1:      	rm[BP_SAVE]	= AR
004D2:      	AR	 = -1
004D3:      	BP	+= AR
            ; //_A149B8B01_202:;				
            _A149B8B01_202:
            ; //_A149B8B01_203:;				
            _A149B8B01_203:
            ; //	sSI	= (int)&_s_0_4;			
004D4:      	AR	= 2
004D5:      	I1	= rm[BP_SAVE]
004D6:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004D7:      	AX	= rm[I1]
            ; //	sSI	= (int)&_ret_1_2;		
004D8:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
004D9:      	rm[I1]	= AX
            ; //LF2D2B0F3_88:;					
            LF2D2B0F3_88:
            ; //_A149B8B01_204:;				
            _A149B8B01_204:
            ; //	sSI	= (int)&_n_0_8;			
004DA:      	AR	= 4
004DB:      	I1	= rm[BP_SAVE]
004DC:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004DD:      	AX	= rm[I1]
            ; //	sSI	= (int)&_n_0_8;			
004DE:      	AR	= 4
004DF:      	I1	= rm[BP_SAVE]
004E0:      	I1	+= AR
            ; //	asm AR = 0x0001;			
004E1:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
004E2:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
004E3:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
004E4:      	AR	= AX
            ; //	if(__jnz__)	goto LF2D2B0F3_89;	
004E5:      	if NZ	jmp LF2D2B0F3_89
            ; //	goto	LF2D2B0F3_87;			
004E6:      	jmp	LF2D2B0F3_87
            ; //LF2D2B0F3_89:;					
            LF2D2B0F3_89:
            ; //_A149B8B01_205:;				
            _A149B8B01_205:
            ; //	sSI	= (int)&_ret_1_2;		
004E7:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
004E8:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
004E9:      	push	AX
            ; //	sSI	= (int)&_c_0_6;			
004EA:      	AR	= 3
004EB:      	I1	= rm[BP_SAVE]
004EC:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004ED:      	AX	= rm[I1]
            ; //	sSI	= POP();			
004EE:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
004EF:      	rm[I1]	= AX
            ; //	sSI	= (int)&_ret_1_2;		
004F0:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
004F1:      	AR = 0x0001//
            ; //	sAX	= *(__int16*)sSI;		
004F2:      	AX	= rm[I1]
            ; //	asm rm[I1] = AX + AR;			
004F3:      	rm[I1] = AX + AR//
            ; //	goto LF2D2B0F3_88;			
004F4:      	jmp	LF2D2B0F3_88
            ; //LF2D2B0F3_87:;					
            LF2D2B0F3_87:
            ; //_A149B8B01_206:;				
            _A149B8B01_206:
            ; //	sSI	= (int)&_s_0_4;			
004F5:      	AR	= 2
004F6:      	I1	= rm[BP_SAVE]
004F7:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
004F8:      	AX	= rm[I1]
            ; //	goto LF2D2B0F3_86;			
004F9:      	jmp	LF2D2B0F3_86
            ; //LF2D2B0F3_86:;					
            LF2D2B0F3_86:
            ; //_A149B8B01_207:;				
            _A149B8B01_207:
            ; //	return;					
004FA:      	AR	= 1
004FB:      	BP	+= AR
004FC:      	pop	AR
004FD:      	rm[BP_SAVE]	= AR
004FE:      	rets
            ; //_memset_sC3E11DB1_end:;				
            _memset_sC3E11DB1_end:
            ; //_A149B8B01_208:;				
            _A149B8B01_208:
            ; //}
            ; //
            ; //rcall rjmp void _memset_rC7200006(__int16 _s_0_4, __int16 _c_0_6, __int16 _n_0_8)
            _memset_rC7200006:
            ; //{
            ; //	__int16 _ret_1_2;
            ; //						
004FF:      	AR	= rm[BP_SAVE]
00500:      	push	AR
00501:      	AR	= BP
00502:      	rm[BP_SAVE]	= AR
00503:      	AR	 = -1
00504:      	BP	+= AR
            ; //_A149B8B01_209:;				
            _A149B8B01_209:
            ; //_A149B8B01_210:;				
            _A149B8B01_210:
            ; //	sSI	= (int)&_s_0_4;			
00505:      	AR	= 2
00506:      	I1	= rm[BP_SAVE]
00507:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00508:      	AX	= rm[I1]
            ; //	sSI	= (int)&_ret_1_2;		
00509:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
0050A:      	rm[I1]	= AX
            ; //LF2D2B0F3_92:;					
            LF2D2B0F3_92:
            ; //_A149B8B01_211:;				
            _A149B8B01_211:
            ; //	sSI	= (int)&_n_0_8;			
0050B:      	AR	= 4
0050C:      	I1	= rm[BP_SAVE]
0050D:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0050E:      	AX	= rm[I1]
            ; //	sSI	= (int)&_n_0_8;			
0050F:      	AR	= 4
00510:      	I1	= rm[BP_SAVE]
00511:      	I1	+= AR
            ; //	asm AR = 0x0001;			
00512:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
00513:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
00514:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
00515:      	AR	= AX
            ; //	if(__jnz__)	goto LF2D2B0F3_93;	
00516:      	if NZ	jmp LF2D2B0F3_93
            ; //	goto	LF2D2B0F3_91;			
00517:      	jmp	LF2D2B0F3_91
            ; //LF2D2B0F3_93:;					
            LF2D2B0F3_93:
            ; //_A149B8B01_212:;				
            _A149B8B01_212:
            ; //	sSI	= (int)&_ret_1_2;		
00518:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00519:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
0051A:      	push	AX
            ; //	sSI	= (int)&_c_0_6;			
0051B:      	AR	= 3
0051C:      	I1	= rm[BP_SAVE]
0051D:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0051E:      	AX	= rm[I1]
            ; //	sSI	= POP();			
0051F:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00520:      	rm[I1]	= AX
            ; //	sSI	= (int)&_ret_1_2;		
00521:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
00522:      	AR = 0x0001//
            ; //	sAX	= *(__int16*)sSI;		
00523:      	AX	= rm[I1]
            ; //	asm rm[I1] = AX + AR;			
00524:      	rm[I1] = AX + AR//
            ; //	goto LF2D2B0F3_92;			
00525:      	jmp	LF2D2B0F3_92
            ; //LF2D2B0F3_91:;					
            LF2D2B0F3_91:
            ; //_A149B8B01_213:;				
            _A149B8B01_213:
            ; //	sSI	= (int)&_s_0_4;			
00526:      	AR	= 2
00527:      	I1	= rm[BP_SAVE]
00528:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00529:      	AX	= rm[I1]
            ; //	goto LF2D2B0F3_90;			
0052A:      	jmp	LF2D2B0F3_90
            ; //LF2D2B0F3_90:;					
            LF2D2B0F3_90:
            ; //_A149B8B01_214:;				
            _A149B8B01_214:
            ; //	return;					
0052B:      	AR	= 1
0052C:      	BP	+= AR
0052D:      	pop	AR
0052E:      	rm[BP_SAVE]	= AR
0052F:      	rets
            ; //_memset_rC7200006_end:;				
            _memset_rC7200006_end:
            ; //_A149B8B01_215:;				
            _A149B8B01_215:
            ; //}
            ; //
            ; //rcall rjmp void _memset5A9D755A(__int16 _s_0_4_0, __int16 _s_0_4_1, __int16 _c_0_8, __int16 _n_0_10)
            _memset5A9D755A:
            ; //{						
00530:      	AR	= rm[BP_SAVE]
00531:      	push	AR
00532:      	AR	= BP
00533:      	rm[BP_SAVE]	= AR
            ; //_A149B8B01_216:;				
            _A149B8B01_216:
            ; //	
            ; //_A149B8B01_217:;				
            _A149B8B01_217:
            ; //	sAX	= (int)&_s_0_4_0;		
00534:      	AR	= 2
00535:      	AX	= rm[BP_SAVE]
00536:      	AX	+= AR
            ; //	sCX	= 0x0001;			
00537:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
00538:      	AR	= CX
00539:      	AX	+= AR
            ; //	sSI	= sAX;				
0053A:      	AR	= AX
0053B:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
0053C:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
0053D:      	AR	= AX
            ; //	if(__jnz__)	goto LF2D2B0F3_96;	
0053E:      	if NZ	jmp LF2D2B0F3_96
            ; //	goto	LF2D2B0F3_95;			
0053F:      	jmp	LF2D2B0F3_95
            ; //LF2D2B0F3_96:;					
            LF2D2B0F3_96:
            ; //_A149B8B01_218:;				
            _A149B8B01_218:
            ; //_A149B8B01_219:;				
            _A149B8B01_219:
            ; //	sSI	= (int)&_n_0_10;		
00540:      	AR	= 5
00541:      	I1	= rm[BP_SAVE]
00542:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00543:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
00544:      	push	AX
            ; //	sSI	= (int)&_c_0_8;			
00545:      	AR	= 4
00546:      	I1	= rm[BP_SAVE]
00547:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00548:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
00549:      	push	AX
            ; //	sAX	= (int)&_s_0_4_0;		
0054A:      	AR	= 2
0054B:      	AX	= rm[BP_SAVE]
0054C:      	AX	+= AR
            ; //	sSI	= sAX;				
0054D:      	AR	= AX
0054E:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
0054F:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
00550:      	push	AX
            ; //	_memset_rC7200006(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2]);
00551:      	call	_memset_rC7200006
            ; //	RESTORESP(3);				
00552:      	AR	= 3
00553:      	BP	+= AR
            ; //	sDX	= 0x0800;			
00554:      	DX	= 0x0800
            ; //	goto LF2D2B0F3_94;			
00556:      	jmp	LF2D2B0F3_94
            ; //LF2D2B0F3_95:;					
            LF2D2B0F3_95:
            ; //_A149B8B01_220:;				
            _A149B8B01_220:
            ; //_A149B8B01_221:;				
            _A149B8B01_221:
            ; //_A149B8B01_222:;				
            _A149B8B01_222:
            ; //	sSI	= (int)&_n_0_10;		
00557:      	AR	= 5
00558:      	I1	= rm[BP_SAVE]
00559:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0055A:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
0055B:      	push	AX
            ; //	sSI	= (int)&_c_0_8;			
0055C:      	AR	= 4
0055D:      	I1	= rm[BP_SAVE]
0055E:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0055F:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
00560:      	push	AX
            ; //	sAX	= (int)&_s_0_4_0;		
00561:      	AR	= 2
00562:      	AX	= rm[BP_SAVE]
00563:      	AX	+= AR
            ; //	sSI	= sAX;				
00564:      	AR	= AX
00565:      	I1	= AR
            ; //	sAX	= *(__int16*)sSI;		
00566:      	AX	= rm[I1]
            ; //	PUSH(sAX);				
00567:      	push	AX
            ; //	_memset_sC3E11DB1(STACK[sSP + 0], STACK[sSP + 1], STACK[sSP + 2]);
00568:      	call	_memset_sC3E11DB1
            ; //	RESTORESP(3);				
00569:      	AR	= 3
0056A:      	BP	+= AR
            ; //	sDX	= 0;				
0056B:      	DX	= 0x00
            ; //	goto LF2D2B0F3_94;			
0056C:      	jmp	LF2D2B0F3_94
            ; //LF2D2B0F3_94:;					
            LF2D2B0F3_94:
            ; //_A149B8B01_223:;				
            _A149B8B01_223:
            ; //	return;					
0056D:      	pop	AR
0056E:      	rm[BP_SAVE]	= AR
0056F:      	rets
            ; //_memset5A9D755A_end:;				
            _memset5A9D755A_end:
            ; //_A149B8B01_224:;				
            _A149B8B01_224:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_memset_CDCF17ED_s(void)	
            ginit_code_memset_CDCF17ED_s:
            ; //{
            ; //	return;					
00570:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\MEMSET_CDCF17ED.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\MD2_8786BA41.S.CODE.ASM> Start=========================
            ; C:\TRITAN\FDSP-IDE\tools\CC\lib\libmd2tiny\md2.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_md2_8786BA41_s(void)	
            ginit_code_md2_8786BA41_s:
            ; //{
            ; //	return;					
00571:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\MD2_8786BA41.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\ADP12_EF8DA009.S.CODE.ASM> Start=========================
            ; C:\TRITAN\FDSP-IDE\tools\CC\lib\libadpcm\adp12.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_adp12_EF8DA009_s(void)	
            ginit_code_adp12_EF8DA009_s:
            ; //{
            ; //	return;					
00572:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //	nop
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\ADP12_EF8DA009.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBMD2TINY\F2GM-PIANO-COHERE-TINY.ASM> Start=========================
            
            
            
            #define DSP_INSBANK_NUM		0x0C00
            
            #define MC_INSLOOP_L		0
            #define MC_INSLOOP_H		1
            #define	MC_INSADR_L		2
            #define MC_INSADR_H		3
            #define MC_FLTA			4
            #define MC_FLTP			5
            #define MC_FLTG			6
            #define MC_RR			7
            #define MC_FLTI			8
            #define MC_ADSR_VOL		12
            #define MC_ADSR_LPATTACK	13
            #define MC_ADSR_SATTACK		14
            #define MC_ADSR_LPDECAY		15
            #define MC_ADSR_SDECAY		16
            #define MC_ADSR_LPSUSTAIN	17
            #define MC_ADSR_SSUSTAIN	18
            
            #define MC_ADPCM_HD		19
            #define MC_ADPCM_S0		20
            #define MC_ADPCM_S1		21
            #define MC_ADPCM_CNT		22
            #define MC_ADPCM_BUF		23
            
            #define MC_SAMPLE_SKIP		24
            #define MC_SAMPLE_SKIPRE	25
            
            #define MC_LEFT_VOL		26
            #define MC_RIGHT_VOL		27
            #define MC_MIDICH		28
            
            #define MC_SIZEOF		29
            
            
            
            #ifdef _MSPEECHDSP_
            
            	macro	mMULSS		PartA, PartB
            		AR=		PartA
            		MX=		AR
            		AR=		PartB
            		MULSS   		; ~~ MULSS  (MY sign * MX sign)
            		endm
            
            
            	macro	mMULSS_NW	PartA, PartB
            		AR=		PartA
            		MX=		AR
            		AR=		PartB
            		MULSS   		; ~~ MULSS  (MY sign * MX sign)
            		endm
            
            #else
            
            	macro	mMULSS		PartA, PartB
            		AR=		PartA
            		MX=		AR
            		AR=		PartB
            		MR=		MX * AR
            		endm
            
            
            	macro	mMULSS_NW	PartA, PartB
            		AR=		PartA
            		MX=		AR
            		AR=		PartB
            		MR=		MX * AR
            		endm
            
            #endif
            
            
            
            VarRM[0:127] = {
            	; mp.baseadr
            		mp_baseadr[2],
            
            	; mp.songcnt
            		mp_songcnt,
            
            	; mp.tinsbank
            		mp_tinsbank,
            
            	; mp.occupyopr
            		mp_occupyopr,
            
            	; mp.inbuf
            		mp_inbuf
            
            	; mp.outbuf
            		mp_outbuf
            
            	; mp.tempo		; ~~ 2 (0x7FFF) ~ 0.5 (0x2000)
            		mp_tempo
            
            	; mp.vol;
            		mp_vol
            
            	; mp.lop;
            		mp_lop
            
            	; mp.pitch;
            		mp_pitch
            }
            
            
            VarRM[128:511]={
            
            
            }
            
            
            VarRM[512:4095] = {
            
            	; struct md2Play mp;
            		; mp.ch[0]
            		mp[232]
            
            		; -=-=
            
            		; -=-=
            
            		; mp.insbase
            
            		mp@insbase[2],
            
            		; mp.songhdr
            		mp@songhdr[2],
            
            		; mp.kmapbase,
            		mp@kmapbase[2],
            
            		; mp.flags,
            		mp@flags,
            
            		; ~~ --
            
            		; mp.extev
            		mp@extev,
            
            		; mp.note
            		mp@note[2],
            
            		; mp.PlayInfo
            		mp@PlayInfo[2],
            
            		; mp.PlayChannel
            		mp@PlayChannel[2],
            
            		; mp.ReleaseInfo
            		mp@ReleaseInfo[2],
            
            		; mp.ReleaseCh
            		mp@ReleaseCh[2],
            
            		; mp.BaseTimer
            		mp@BaseTimer,
            
            		; mp.EventTimer
            		mp@EventTimer
            
            		; mp.lpadr	; ~~ midi loop setting
            		mp@lpadr[2],
            
            		mp@mchmask,
            		mp@adsrcnt,
            
            		; mp.keych[20]
            		mp@keych[8],
            
            		mp@okmask,
            
            		mp@keymap[2],
            
            		mp@ofsevent[2],
            
            		mp@okon[16]
            
            		mp_ctlev,
            
            
            	#ifdef _MD2_TINY_MODE2_
            
            		BaseOn64#mp@tinyrender[64]
            
            	#else
            
            		mp@tinyrender[8],
            
            	#endif
            }
            
            
            #define mp@keymap_h		mp@keymap + 1
            
            #define mp_baseadr_l		mp_baseadr
            #define mp_baseadr_h		mp_baseadr+1
            #define mp@baseadr_l		mp_baseadr
            #define mp@baseadr_h		mp_baseadr+1
            
            #define	mp@ch0@RR		mp + MC_RR
            #define mp@ch0@FLTG		mp + MC_FLTG
            #define mp@ch0@FLTP		mp + MC_FLTP
            #define mp@ch0@insloop_l	mp + MC_INSLOOP_L
            #define mp@ch0@midich		mp + MC_MIDICH
            #define mp@ch7@insloop_l	mp + (MC_SIZEOF * 7) + MC_INSLOOP_L
            
            #define mp@insbase_l		mp@insbase
            #define mp@insbase_h		mp@insbase + 1
            
            #define mp@songhdr_l		mp@songhdr
            #define mp@songhdr_h		mp@songhdr + 1
            
            #define mp@kmapbase_l		mp@kmapbase
            #define mp@kmapbase_h		mp@kmapbase + 1
            
            #define mp@note_l		mp@note
            #define mp@note_h		mp@note + 1
            
            #define mp@PlayInfo_l		mp@PlayInfo
            #define mp@PlayInfo_h		mp@PlayInfo + 1
            
            #define mp@PlayChannel_l	mp@PlayChannel
            #define mp@PlayChannel_h	mp@PlayChannel + 1
            
            #define mp@ReleaseInfo_l	mp@ReleaseInfo
            #define mp@ReleaseInfo_h	mp@ReleaseInfo + 1
            
            #define mp@ReleaseCh_l		mp@ReleaseCh
            #define mp@ReleaseCh_h		mp@ReleaseCh + 1
            
            #define mp@lpadrl		mp@lpadr
            #define mp@lpadrh		mp@lpadr + 1
            
            #define mp@ofsevent_l		mp@ofsevent
            #define mp@ofsevent_h		mp@ofsevent + 1
            
            
            
            #define ICH0	mp + MC_MIDICH + (MC_SIZEOF * 0)
            #define ICH1	mp + MC_MIDICH + (MC_SIZEOF * 1)
            #define ICH2	mp + MC_MIDICH + (MC_SIZEOF * 2)
            #define ICH3	mp + MC_MIDICH + (MC_SIZEOF * 3)
            #define ICH4	mp + MC_MIDICH + (MC_SIZEOF * 4)
            #define ICH5	mp + MC_MIDICH + (MC_SIZEOF * 5)
            #define ICH6	mp + MC_MIDICH + (MC_SIZEOF * 6)
            #define ICH7	mp + MC_MIDICH + (MC_SIZEOF * 7)
            #define ICH8	mp + MC_MIDICH + (MC_SIZEOF * 8)
            #define ICH9	mp + MC_MIDICH + (MC_SIZEOF * 9)
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ShareVar = {
            
            	mp@endevent_l = mp@note_l
            	mp@endevent_h = mp@note_h
            
            	mp_insbase = mp@insbase
            	mp_songhdr = mp@songhdr
            	mp_kmapbase = mp@kmapbase
            	mp_flags = mp@flags
            	mp_extev = mp@extev
            	mp_note = mp@note
            	mp_PlayInfo = mp@PlayInfo
            	mp_PlayChannel = mp@PlayChannel
            	mp_ReleaseInfo = mp@ReleaseInfo
            	mp_ReleaseCh = mp@ReleaseCh
            	mp_BaseTimer = mp@BaseTimer
            	mp_EventTimer = mp@EventTimer
            	mp_lpadr = mp@lpadr
            	mp_mchmask = mp@mchmask
            	mp_okmask = mp@okmask
            	mp_endevent = mp@note
            
            	mp@baseadr_l = mp_baseadr_l,
            	mp@baseadr_h = mp_baseadr_h,
            
            	; mp.songcnt
            	mp@songcnt = mp_songcnt,
            
            	; mp.tinsbank
            	mp@tinsbank = mp_tinsbank,
            
            	; mp.occupyopr
            	mp@occupyopr = mp_occupyopr,
            
            	; mp.inbuf
            	mp@inbuf = mp_inbuf
            
            	; mp.outbuf
            	mp@outbuf = mp_outbuf
            
            	; mp.tempo		; ~~ 2 (0x7FFF) ~ 0.5 (0x2000)
            	mp@tempo = mp_tempo
            
            	; mp.vol;
            	mp@vol = mp_vol
            
            	; mp.lop;
            	mp@lop = mp_lop
            	mp@ctlev = mp_ctlev
            	mp@pitch = mp_pitch
            }
            
            
            ; +-++-+
            
            
            ; ~.~---------------------------------------------------------------
            ; bool md2DoEvent(void)
            ;
            ; in:
            ;    none
            ;
            ; out:
            ;    Z		- true
            ;    NZ		- false
            ;
            ; affect registers:
            ;    AR, AX, BX, CX, DX, I0, I1, R0, R1, R2, R3
            ;
            ; meaning registers:
            ;
            ;
            ; special request:
            ;
            ;
            ; ------------------------------------------------------------------
            md2DoEvent:
            ; {
            	; if(mp.BaseTimer)
00573:      		I1=		mp@BaseTimer
00575:      		AR=		rm[I1]
00576:      		if ZR jmp	@md2de_label_1054
            	; {
            		; return true;
00577:      			set		Z
00578:      			rets
            	; }
            	@md2de_label_1054:
            
            	; if(mp.note == 0)
00579:      		I1=		mp@note_l
0057B:      		AR=		rm[I1++]
0057C:      		AX=		rm[I1]
0057D:      		AR=		AR | AX
0057E:      		if NZ jmp	@md2de_label_1624
            	; {
            		; return true;
0057F:      			set		Z
00580:      			rets
            	; }
            	@md2de_label_1624:
            
            @md2de_loop_1841:
            	; mp.EventTimer = 0;
00581:      		I1=		mp@EventTimer
00583:      		AR=		0
00584:      		rm[I1]=		AR
            
            	; sfContReadStart(HIADR(&mp.note));
00585:      		I1=		mp@note_h
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00587:      AR= rm[I1 -- ] 
00588:      P1 = rm[I1] 
00589:      sra AR 1 
0058A:      src P1 1 
0058B:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            	; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
0058C:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
0058D:      		AX=		AR
            
            	; mp.extev = AX.N1;
0058E:      		I1=		mp@extev
00590:      		sra		AR, 2
00591:      		sra		AR, 2
00592:      		AR=		AR & 0x0F
00593:      		rm[I1]=		AR
            
            	; if(mp.ExtEV & 0x08)
00594:      		test		AR.b3
00595:      		if ZR jmp	@md2de_label_1157
            	; {
            		; ~~ control message
            
            		; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00596:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            		; mp.ctlev = vXCHG(AX);
00597:      			AR=		AX
00598:      			I1=		mp@ctlev
0059A:      			xchg		AR
0059B:      			rm[I1]=		AR
            
            	#ifdef MD2_CTLEV_CALLBACK
            
            		; md2CtlEvCallback();
            			PCH=		md2CtlEvCallback
            			lcall		md2CtlEvCallback
            
            	#endif
            
            		; mp->note += 2;
0059C:      			I1=		mp@note_l
0059E:      			AR=		rm[I1]
0059F:      			AR=		AR + 2
005A0:      			rm[I1++]=	AR
005A1:      			AR=		rm[I1]
005A2:      			AR=		AR + 0 + C
005A3:      			rm[I1]=		AR
            
            		; spiContReadStart(mp->note, &mp->md2);
005A4:      			I1=		mp@note_h
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
005A6:      AR= rm[I1 -- ] 
005A7:      P1 = rm[I1] 
005A8:      sra AR 1 
005A9:      src P1 1 
005AA:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            
            		; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
005AB:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
005AC:      			AX=		AR
            
            		; mp.extev = (unsigned long)AX.N1;
005AD:      			I1=		mp@extev
005AF:      			sra		AR, 2
005B0:      			sra		AR, 2
005B1:      			AR=		AR & 0x0F
005B2:      			rm[I1]=		AR
            	; }
            	@md2de_label_1157:
            
            
            	; switch(mp.extev & 3)
005B3:      		AR=		AR & 0x03
005B4:      		if ZR jmp	@md2de_caseT_case0
005B5:      		SF=		AR - 1
005B6:      		if EQ jmp	@md2de_caseT_case1
005B7:      		SF=		AR - 2
005B8:      		if EQ jmp	@md2de_caseT_case2
005B9:      		jmp		@md2de_caseT_case3
            	; {
            		; case 0:
            		@md2de_caseT_case0:
            		; {
            			; ~~ +------+------------------------+--------+
            			; ~~ |4-bit | event type = 0         |        |    N1
            			; ~~ +------+------------------------+ byte 0 |  L
            			; ~~ |4-bit | event timer high 4-bit |        |    N0
            			; ~~ +------|                        +--------+
            			; ~~ |8-bit |             low 8-bit  | byte 1 |  H
            			; ~~ +------+------------------------+--------+
            
            			; mp.EventTimer = ((unsigned short)AX.N0) << 8;
005BA:      				I1=		mp@EventTimer
005BC:      				AR=		0xFF0F
005BE:      				AR=		AR & AX
005BF:      				xchg		AR
            
            			; mp.EventTimer |= (unsigned short)AX.H;
005C0:      				rm[I1]=		AR
            
            			; mp.note += 2;
005C1:      				I1=		mp@note_l
005C3:      				AR=		rm[I1]
005C4:      				AR=		AR + 2
005C5:      				rm[I1++]=	AR
005C6:      				AR=		rm[I1]
005C7:      				AR=		AR + 0 + C
005C8:      				rm[I1]=		AR
            
            			; break;
005C9:      				jmp		@md2de_label_1759
            		; }
            
            		; case 1:
            		@md2de_caseT_case1:
            		; {
            			; ~~ +------+-------------------------+--------+
            			; ~~ |4-bit | event type = 1          |        |    N1
            			; ~~ +------+-------------------------+ byte 0 |  L
            			; ~~ |4-bit | play channel [19:16]    |        |    N0
            			; ~~ +------+-------------------------+--------+
            			; ~~ |4-bit | play channel [15:12]    |        |    N3
            			; ~~ +------+-------------------------+ byte 1 |  H
            			; ~~ |4-bit | play channel [11:8]     |        |    N2
            			; ~~ +------+-------------------------+--------+
            			; ~~ |8-bit | play channel [7:0]      | byte 2 |  L
            			; ~~ +------+-------------------------+--------+
            			; ~~ |8-bit | event timer             | byte 3 |  H
            			; ~~ +------+-------------------------+--------+
            
            			; mp.PlayInfo = ((unsigned long)AX.N0) << 16;
005CA:      				I1=		mp@PlayInfo_h
005CC:      				AR=		0x0F
005CD:      				rm[I1--]=	AR & AX
            
            			; mp.PlayInfo |= ((unsigned long)AX.H) << 8;
005CE:      				AR=		0xFF00
005D0:      				AX=		AX & AR
            
            			; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
005D1:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
005D2:      				push		AR
            
            			; mp.PlayInfo |= ((unsigned long)AX.L);
005D3:      				AH=		0
005D4:      				rm[I1]=		AR | AX
            
            			; mp.EventTimer = 0x0F00 | (unsigned short)AX.H;
005D5:      				pop		AR
005D6:      				xchg		AR
005D7:      				AH=		0x0F
005D8:      				I1=		mp@EventTimer
005DA:      				rm[I1]=		AR
            
            			; mp.note += 4;
005DB:      				I1=		mp@note_l
005DD:      				AR=		rm[I1]
005DE:      				AR=		AR + 4
005DF:      				rm[I1++]=	AR
005E0:      				AR=		rm[I1]
005E1:      				AR=		AR + 0 + C
005E2:      				rm[I1]=		AR
            
            			; Debug("case 1: EventTimer=%04X\n", (int)mp->EventTimer);
            			; Debug("        PlayInfo=%08X\n", (int)mp->PlayInfo);
            
            			; break;
005E3:      				jmp		@md2de_label_1759
            		; }
            
            		; case 2:
            		@md2de_caseT_case2:
            		; {
            			; ~~ +------+-------------------------+--------+
            			; ~~ |4-bit | event type = 2          |        |    N1
            			; ~~ +------+-------------------------+ byte 0 |  L
            			; ~~ |4-bit | release channel [19:16] |        |    N0
            			; ~~ +------+-------------------------+--------+
            			; ~~ |4-bit | release channel [15:12] |        |    N3
            			; ~~ +------+-------------------------+ byte 1 |  H
            			; ~~ |4-bit | release channel [11:8]  |        |    N2
            			; ~~ +------+-------------------------+--------+
            			; ~~ |8-bit | release channel [7:0]   | byte 2 |  L
            			; ~~ +------+-------------------------+--------+
            			; ~~ |8-bit |            event timer  | byte 3 |  H
            			; ~~ +------+-------------------------+--------+
            
            			; mp.ReleaseInfo = ((unsigned long)AX.N0) << 16;
005E4:      				I1=		mp@ReleaseInfo_h
005E6:      				AR=		0x000F
005E7:      				rm[I1--]=	AR & AX
            
            			; mp.ReleaseInfo |= ((unsigned long)AX.H) << 8;
005E8:      				AR=		0xFF00
005EA:      				AX=		AX & AR
            
            			; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
005EB:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
005EC:      				push		AR
            
            			; mp.ReleaseInfo |= ((unsigned long)AX.L);
005ED:      				AH=		0
005EE:      				rm[I1]=		AR | AX
            
            			; mp.EventTimer = 0x0F00 | (unsigned short)AX.H;
005EF:      				pop		AR
005F0:      				xchg		AR
005F1:      				AH=		0x0F
005F2:      				I1=		mp@EventTimer
005F4:      				rm[I1]=		AR
            
            			; mp.note += 4;
005F5:      				I1=		mp@note_l
005F7:      				AR=		rm[I1]
005F8:      				AR=		AR + 4
005F9:      				rm[I1++]=	AR
005FA:      				AR=		rm[I1]
005FB:      				AR=		AR + 0 + C
005FC:      				rm[I1]=		AR
            
            			; Debug("case 2: EventTimer=%04X\n", (int)mp->EventTimer);
            			; Debug("        ReleaseInfo=%08X\n", (int)mp->ReleaseInfo);
            
            			; break;
005FD:      				jmp		@md2de_label_1759
            		; }
            
            		; case 3:
            		@md2de_caseT_case3:
            		; {
            			; ~~ +------+------------------------+--------+
            			; ~~ |4-bit | event type = 3         |        |   N1
            			; ~~ +------+------------------------+ byte 0 | L
            			; ~~ |4-bit | play channel [19:16]   |        |   N0
            			; ~~ +------+------------------------+--------|
            			; ~~ |8-bit | play channel [15:8]    | byte 1 | H
            			; ~~ +------+------------------------+--------|
            			; ~~ |8-bit | play channel [7:0]     | byte 2 | L
            			; ~~ +------+------------------------+--------+
            			; ~~ |8-bit |release channel [19:12] | byte 3 | H
            			; ~~ +------+------------------------+--------|
            			; ~~ |8-bit |release channel [11:4]  | byte 4 | L
            			; ~~ +------+------------------------+--------+
            			; ~~ |4-bit |release channel [3:0]   |        |   N3
            			; ~~ +------+------------------------| byte 5 + H
            			; ~~ |4-bit | event timer            |        |   N2
            			; ~~ +------+------------------------+--------+
            
            			; mp.PlayInfo = ((unsigned long)AX.N0) << 16;
005FE:      				I1=		mp@PlayInfo_h
00600:      				AR=		0x000F
00601:      				rm[I1--]=	AR & AX
            
            			; mp.PlayInfo |= ((unsigned long)AX.H) << 8;
00602:      				AR=		0xFF00
00604:      				AX=		AX & AR
            
            			; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00605:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00606:      				push		AR
            
            			; mp.PlayInfo |= ((unsigned long)AX.L);
00607:      				AH=		0
00608:      				rm[I1]=		AR | AX
            
            			; mp.ReleaseInfo = ((unsigned long)AX.H) << 12;
00609:      				I1=		mp@ReleaseInfo_h
            
            			; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
0060B:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
0060C:      				xchg		AR
0060D:      				AX=		AR
0060E:      				BX=		AR
            
            			; mp.ReleaseInfo |= ((unsigned long)AX.L) << 4;
0060F:      				pop		AR
00610:      				xchg		AR
00611:      				AH=		0
00612:      				sra		AR, 2
00613:      				src		AX, 2
00614:      				sra		AR, 2
00615:      				src		AX, 2
00616:      				rm[I1--]=	AR
            
            			; mp.ReleaseInfo |= ((unsigned long)AX.N3);
00617:      				rm[I1]=		AX
            
            			; mp.EventTimer = 0x0FF0 | (unsigned short)AX.N2;
00618:      				BX.h=		0
00619:      				AR=		0x0FF0
0061B:      				I1=		mp@EventTimer
0061D:      				rm[I1]=		AR | BX
            
            			; mp.note += 6;
0061E:      				I1=		mp@note_l
00620:      				AR=		rm[I1]
00621:      				AR=		AR + 6
00622:      				rm[I1++]=	AR
00623:      				AR=		rm[I1]
00624:      				AR=		AR + 0 + C
00625:      				rm[I1]=		AR
            
            			; Debug("case 3: EventTimer=%04X\n", (int)mp->EventTimer);
            			; Debug("        PlayInfo=%08X\n", (int)mp->PlayInfo);
            			; Debug("        ReleaseCh=%08X\n", (int)mp->ReleaseInfo);
            
            			; break;
00626:      				jmp		@md2de_label_1759
            		; }
            
            		; default:
            		@md2de_case_default:
            		; {
            			; Debug("Fatal: undefined event %d\n", AX.L & 0x0F);
            			; return false;
00627:      				clr		Z
00628:      				rets
            		; }
            	; }
            	@md2de_label_1759:
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00629:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; if(mp.EventTimer == 0)
0062A:      		I1=		mp@EventTimer
0062C:      		AR=		rm[I1]
0062D:      		if NZ jmp	@md2de_label_1104
            	; {
            		; mp.note = mp.lpadr;
0062E:      			AX=		0
0062F:      			I1=		mp@lpadrh
00631:      			AR=		rm[I1--]
00632:      			push		AR
00633:      			AR=		rm[I1]
00634:      			I1=		mp@note_l
00636:      			rm[I1++]=	AR
00637:      			AX=		AX | AR
00638:      			pop		AR
00639:      			rm[I1]=		AR
0063A:      			AX=		AX | AR
            
            		; if(mp.note)
0063B:      			AR=		AX
0063C:      			if ZR jmp	@md2de_label_1849
            		; {
            			; goto __md2de_loop_1841;
0063D:      				jmp		@md2de_loop_1841
            		; }
            
            		@md2de_label_1849:
            
            		; mp.occupyopr = 0;
0063E:      			rm[mp_occupyopr]=AR
            
            		; return true;
0063F:      			set		Z
00640:      			rets
            	; }
            	@md2de_label_1104:
            
            	; ~~ processing release
            
            	; ~~ offset aware
            	;      mp.ReleaseInfo, mp.note,
            
            	; ~~ meaning registers:
            	; ------------------------------------
            	; ~~     AX:BX = 1 << i
            	; ~~     CX    = i
            	; ~~     DX    = note count
            	; ~~     R1:R0 = mp.ReleaseInfo
            	; ~~     R2    = AX
            	; ~~     I0    = pch (pch->RR)
            	; ~~     I1    = mp.??
            
            	; if(mp.ReleaseInfo)
00641:      		I1=		mp@ReleaseInfo_l
00643:      		R0=		rm[I1++]
00644:      		AR=		rm[I1]
00645:      		AR=		AR | R0
00646:      		if ZR jmp	@md2de_label_1705
00647:      		R1=		rm[I1]
            	; {
            		; pch = mp.ch;
00648:      			I0=		mp@ch0@RR
            
            		; sfContReadStart(HIADR(&mp.note));
0064A:      			I1=		mp@note_h
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
0064C:      AR= rm[I1 -- ] 
0064D:      P1 = rm[I1] 
0064E:      sra AR 1 
0064F:      src P1 1 
00650:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            		; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00651:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00652:      			R2=		AR
            
            		; for(i = 0; (i < 20) && mp.ReleaseInfo; i++)
00653:      			io[ClrWDT]=	AR
00654:      			CX=		19
00655:      			BX=		1
00656:      			AX=		0
00657:      			DX=		0
            		@md2de_loop_1114:
00658:      			AR=		R0
00659:      			AR=		AR | R1
0065A:      			if ZR jmp	@md2de_label_1114
            		; {
            			; if(mp->ReleaseInfo & 1)
0065B:      				sra		R1, 1
0065C:      				src		R0, 1
0065D:      				if NC jmp	@md2de_label_1117
            			; {
            				; pch->RR = (unsigned long)AX.U;
0065E:      					rm[I0]=		R2
            
            				; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
0065F:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00660:      					R2=		AR
            
            				; mp->note += 2;
00661:      					DX++
00662:      					DX++
            
            				; mp.ReleaseCh |= (1 << i);
00663:      					I1=		mp@ReleaseCh_l
00665:      					AR=		rm[I1]
00666:      					rm[I1++]=	AR | BX
00667:      					AR=		rm[I1]
00668:      					rm[I1]=		AR | AX
            			; }
            			@md2de_label_1117:
            
            			; mp.ReleaseInfo >>= 1;
00669:      				slz		BX, 1
0066A:      				slc		AX, 1
            
            			; pch++;
0066B:      				AR=		MC_SIZEOF
0066C:      				I0=		I0 + AR
            
0066D:      			loop		@md2de_loop_1114
            		; }
            		@md2de_label_1114:
            			; ~~ write back --> mp.ReleaseInfo, mp.note
0066E:      			I1=		mp@ReleaseInfo_l
00670:      			rm[I1++]=	R0
00671:      			rm[I1]=		R1
00672:      			I1=		mp@note_l
00674:      			AR=		rm[I1]
00675:      			rm[I1++]=	AR + DX
00676:      			AR=		rm[I1]
00677:      			AR=		AR + 0 + C
00678:      			rm[I1]=		AR
            
            		; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00679:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            		; Debug("release final %08X\n", (int)mp->note);
            	; }
            	@md2de_label_1705:
            
            
            	; mp.BaseTimer = (0x1000 - mp.EventTimer) * 8 * tempo;
0067A:      		I1=		mp@EventTimer
0067C:      		AR=		0x1000
0067E:      		AX=		rm[I1]
0067F:      		AX=		AR - AX
00680:      		slz		AX, 2
00681:      		slz		AX, 1
00682:      		I1=		mp_tempo
            
            		; ~~ simulate 90nm Speech
            
            ;;<<System message ======  Macro. mMULSS,4633,4638,PartA,PartB,,,,,,,,,,,,,,  strat ======
00683:      AR = rm[I1] 
00684:      MX = AR 
00685:      AR = AX 
00686:      MR = MX * AR 
            ;; System message>>====== Macro. mMULSS end ======
            
            	#ifdef _MSPEECHDSP_
            		AR=		MR0		; ~~ load answer and store
            		AX=		AR
            		AR=		MR1
            	#else
00687:      		AR=		MR0
00688:      		AX=		AR
00689:      		AR=		MR1
            	#endif
            
            		; ~~ --------------------
            
0068A:      		slz		AX, 2
0068B:      		slc		AR, 2
            
            	#ifdef _MD2_TINY_MODE2_
            
            		; 500us per tick (1 / 4ms)
0068C:      		slz		AX, 1
0068D:      		slc		AR, 1
            
            	#else
            		; 125us per tick (1 / 8 ms)
            		slz		AX, 2
            		slc		AR, 2
            		slz		AX, 1
            		slc		AR, 1
            	#endif
            
0068E:      		I1=		mp@BaseTimer
00690:      		rm[I1]=		AR
            
            	; EnableInterrupt(INT2);
            		; ena		INT2
            
            	; return true;
00691:      		set		Z
00692:      		rets
            ; }
            
            
            
            ; ~.~---------------------------------------------------------------
            ; void md2SetInstrument(void)
            ;
            ; in:
            ;    none
            ;
            ; out:
            ;    none
            ;
            ;
            ; affect registers:
            ;    AR, AX, BX, CX, DX, I0, I1, R0, R1, R2, R3
            ;
            ; meaning registers:
            ;    AX:BX	- (1 << i)
            ;    CX		- i
            ;    DX		- next pch
            ;    I0		- pch
            ;    I1		- mp.??
            ;    R1:R0	- mp.PlayInfo
            ;    R2		- AX
            ;    R3		- BX
            ;
            ; special request:
            ;
            ;
            ; ------------------------------------------------------------------
            md2SetInstrument:
            ; {
            	; md2Channel *pch;
            	; DSP16 AX, BX;
            	; int i, temp;
            
            	; if(mp.PlayInfo)
00693:      		I1=		mp@PlayInfo_l
00695:      		R0=		rm[I1++]
00696:      		AR=		rm[I1]
00697:      		AR=		AR | R0
00698:      		if ZR jmp	@md2si_label_1645
00699:      		R1=		rm[I1]
            	; {
            		; // Debug("\n");
            
            		; pch = mp.ch;
0069A:      			I0=		mp
            
            		; sfContReadStart(HIADR(&mp.note));
0069C:      			I1=		mp@note_h
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
0069E:      AR= rm[I1 -- ] 
0069F:      P1 = rm[I1] 
006A0:      sra AR 1 
006A1:      src P1 1 
006A2:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            		; ~~ offset aware
            		;       verify mp struct offset if modified.
            
            		; for(i = 0; (i < 20) && (mp.PlayInfo); i++)
006A3:      			io[ClrWDT]=	AR
006A4:      			CX=		19
006A5:      			BX=		1
006A6:      			AX=		0
            		@md2si_loop_1344:
006A7:      			DX=		0
006A8:      			AR=		R0
006A9:      			AR=		AR | R1
006AA:      			if ZR jmp	@md2si_label_1340
            		; {
            			; if(mp.PlayInfo & 1)
006AB:      				sra		R1, 1
006AC:      				src		R0, 1
006AD:      				if NC jmp	@__md2si_label_0328
            			; {
            				; ~~ clear FIFO
            
            				; memset(pch->FLTI, 0, sizeof(pch->FLTI));
006AE:      					I1=		MC_FLTI
006AF:      					AR=		I0
006B0:      					I1=		I1 + AR
006B1:      					AR=		0
006B2:      					rm[I1++]=	AR
006B3:      					rm[I1++]=	AR
006B4:      					rm[I1++]=	AR
006B5:      					rm[I1++]=	AR
            					; rm[I1++]=	AR
            					; rm[I1++]=	AR
            					; rm[I1++]=	AR
            					; rm[I1++]=	AR
            
            				; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
006B6:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
006B7:      					R3=		AR
            					; mask Scale area
006B8:      					clr		R3.b13
006B9:      					clr		R3.b12
            
            				; mp.note += 2;
006BA:      					DX++
006BB:      					DX++
            
            				; CX = (AX & 0x3000) >> 12;
006BC:      					slc		AR, 2		; ~~ drop 2-bit
006BD:      					slc		AR, 2
006BE:      					P0=		#md2ScaleTable
006C1:      					AR=		0
006C2:      					slc		AR, 2
006C3:      					P0=		P0 + AR
            
            				; mp.skip = 1 << CX;
006C4:      					I1=		MC_SAMPLE_SKIP
006C5:      					AR=		I0
006C6:      					I1=		I1 + AR
006C7:      					rm[I1++]=	pm[P0]
            				; mp.skipre = mp.skip;
006C8:      					rm[I1++]=	pm[P0]
            
            
            				; ~~ Initial Volume Setting (only support V2 15-bit volume)
            
            
            				; if(BX.b15)
006C9:      					test		R3.b15
006CA:      					if ZR jmp	@md2si_label_1355
            				; {
            					; BX.U = BX.U & 0x7FFF;
006CB:      						clr		R3.b15
            
            					; AX = sfContReadWord();
006CC:      						I1=		MC_FLTG
006CD:      						AR=		I0
006CE:      						I1=		I1 + AR
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
006CF:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            					; pch->FLTG = AX;	; ~~ Volume 16-bit
006D0:      						rm[I1]=		AR
            
            					; mp.note += 2;
006D1:      						DX++
006D2:      						DX++
            
            
            					; ~~ compare at 8-bit
            
            					; if(pch->FLTG == 0)
006D3:      						if NZ jmp	@md2si_label_1355
            					; {
            						; ~~ cancel this channel if Volume == 0
            
            						; mp.PlayChannel &= ~(1 << i);
006D4:      							I1=		mp@PlayChannel_l
006D6:      							AR=		rm[I1]
006D7:      							AR=		AR ^ 0xFF
006D8:      							AR=		AR | BX
006D9:      							AR=		AR ^ 0xFF
006DA:      							rm[I1++]=	AR
006DB:      							AR=		rm[I1]
006DC:      							AR=		AR ^ 0xFF
006DD:      							AR=		AR | AX
006DE:      							AR=		AR ^ 0xFF
006DF:      							rm[I1]=		AR
            
            						; goto __md2si_label_0328;
006E0:      							I1=		mp@note_l
006E2:      							AR=		rm[I1]
006E3:      							rm[I1++]=	AR + DX
006E4:      							AR=		rm[I1]
006E5:      							AR=		AR + 0 + C
006E6:      							rm[I1]=		AR
006E7:      							jmp		@__md2si_label_0328
            					; }
            				; }
            				@md2si_label_1355:
            
            
            				; ~~ PAN control
            
            				; if(BX.b14)
006E8:      					test		R3.b14
006E9:      					if ZR jmp	@md2si_label_1827
            				; {
            					; BX.U = BX.U & 0xBFFF;
006EA:      						clr		R3.b14
            
            					; mp.note += 2;
006EB:      						DX++
006EC:      						DX++
            
            					; AX = sfContReadWord();
006ED:      						I1=		MC_LEFT_VOL
006EE:      						AR=		I0
006EF:      						I1=		I1 + AR
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
006F0:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            					; mp.Stereo.L = 0x007F | (AL << 7);
006F1:      						push		AR
006F2:      						xchg		AR
006F3:      						AL=		0xFF
006F4:      						clr		C
006F5:      						src		AR, 1
006F6:      						rm[I1++]=	AR
            
            					; mp.Stereo.R = 0x007F | (AH << 7);
006F7:      						pop		AR
006F8:      						AL=		0xFF
006F9:      						clr		C
006FA:      						src		AR, 1
006FB:      						rm[I1++]=	AR
            				; }
            				@md2si_label_1827:
            
            				; ~~ FLTP
            
            				; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
006FC:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
006FD:      					R2=		AR
            
            				; if(pch->FLTP & 0x8000)
006FE:      					test		R2.b15
006FF:      					if ZR jmp	@md2si_label_1044
            				; {
            					; mp.midich = AX.U & 0x000F;
00700:      						I1=		MC_MIDICH
00701:      						AR=		I0
00702:      						I1=		I1 + AR
00703:      						AR=		0x0F
00704:      						AR=		AR & R2
00705:      						rm[I1]=		AR
            
            					; AX.U &= ~0x800F;
00706:      						AR=		0x7FF0
00708:      						R2=		R2 & AR
            				; }
            				@md2si_label_1044:
            
            
            				; pch->FLTP = AX.U;
00709:      					I1=		MC_FLTP
0070A:      					AR=		I0
0070B:      					I1=		I1 + AR
0070C:      					rm[I1]=		R2
            
            				; mp.note += 2;
0070D:      					DX++
0070E:      					DX++
            
            				; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
0070F:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            
            				; ~~ Debug("FLTP=%04X\n", AX.U);
            
            				; ~~ instrument address
            
            
            				; ~~ don't broken these register
            				;    AX:BX	- (1 << i)
            				;    CX		- i
            				;    DX		- next pch
            				;    I0		- pch
            				;    R1:R0	- mp.PlayInfo
            
            				; ~~ P1 is already safe to use it
            
            
            				; if(BX.U == DSP_INSBANK_NUM)
00710:      					AR=		DSP_INSBANK_NUM
00712:      					SF=		AR - R3
00713:      					if NE jmp	@md2si_label_1624
            				; {
            
            					; +-----+-----+-----------+-----------+
            					; | b15 | b14 | b13 - b12 | b11 - b0  |
            					; +-----+-----+-----------+-----------+
            					; |  0	|  0  |	 scale	  | INS index |
            					; +-----+-----+-----------+-----------+
            
            					; +-----+------------+
            					; | b15 | b14  - b0  |
            					; +-----+------------+
            					; |  0	|    FLTP    |
            					; +-----+------------+
            
            					; ~~ auto setup midi channel to 0
            					; ~~ because midi channel always 0 when instrument is DSP_INSBANK_NUM
            
            					; mp.midich = 0;
00714:      						I1=		MC_MIDICH
00715:      						AR=		I0
00716:      						I1=		I1 + AR
00717:      						AR=		0
00718:      						rm[I1]=		AR
            
            					; ~~ get address
            
            					; spiContReadStart(mp->keymap + (pch->FLTP * 4), &mp->md2);
00719:      						I1=		mp@keymap
0071B:      						slz		R2, 2
0071C:      						AR=		rm[I1++]
0071D:      						R2=		AR + R2
0071E:      						AR=		rm[I1]
0071F:      						AR=		AR + 0 + C
00720:      						push		AR
00721:      						push		R2
00722:      						AR=		BP
00723:      						AR=		AR + 2
00724:      						I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00725:      AR= rm[I1 -- ] 
00726:      P1 = rm[I1] 
00727:      sra AR 1 
00728:      src P1 1 
00729:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
0072A:      						pop		AR
0072B:      						pop		AR
            
            					; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
0072C:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            					; BX = AX & 0x0FFF;
0072D:      						R3=		AR		; INS
0072E:      						clr		R3.b13
0072F:      						clr		R3.b12
00730:      						slc		AR, 2
00731:      						slc		AR, 2
            
            					; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00732:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00733:      						R2=		AR		; FLTP
            
            					; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00734:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            					; CX = (BX & 0x3000) >> 12;
00735:      						P1=		#md2ScaleTable	; code
00738:      						AR=		0
00739:      						slc		AR, 2
0073A:      						P1=		P1 + AR
            
            					; mp.skip = 1 << CX;
0073B:      						I1=		MC_SAMPLE_SKIP
0073C:      						AR=		I0
0073D:      						I1=		I1 + AR
0073E:      						rm[I1++]=	pm[P1]
            
            					; mp.skipre = mp.skip;
0073F:      						rm[I1]=		pm[P1]
            
            					; pch->FLTP = AX.U;
00740:      						I1=		MC_FLTP
00741:      						AR=		I0
00742:      						I1=		I1 + AR
00743:      						rm[I1]=		R2
            
            				; }
            				@md2si_label_1624:
            
            
            				; ~~ shift
            
            				; if(pch->midich != 9)
00744:      					I1=		MC_MIDICH
00745:      					AR=		I0
00746:      					I1=		I1 + AR
00747:      					AR=		rm[I1]
00748:      					SF=		AR - 9
00749:      					if EQ jmp	@md2si_label_1041
            				; {
            					; __sub_md2Pitch();
0074A:      						call		__sub_md2Pitch
            				; }
            				@md2si_label_1041:
            
            
            
            				; BX.U = BX.U * mp->SizeInsIndex;
0074B:      					MX=		18
0074C:      					AR=		R3
            				#ifdef _MSPEECHDSP_
            					MULSS
            				#else
0074D:      					MR=		MX * AR
            				#endif
            
            				; temp = (mp.insbase + BX.U);
0074E:      					I1=		mp@insbase_l
00750:      					AR=		rm[I1++]
00751:      					MR0=		MR0 + AR
00752:      					AR=		rm[I1]
00753:      					AR=		AR + MR1 + C
00754:      					push		AR
00755:      					push		MR0
            
            				; ~~ Debug("table adr=%08X\n", temp);
            
            
            				; ~~ get instrument address
            
            
            				; sfContReadStart(HIADR(&temp));
00756:      					AR=		BP
00757:      					AR=		AR + 2
00758:      					I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00759:      AR= rm[I1 -- ] 
0075A:      P1 = rm[I1] 
0075B:      sra AR 1 
0075C:      src P1 1 
0075D:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
0075E:      					pop		AR
0075F:      					pop		AR
            
            				; BX = sfContReadWord();		// low
00760:      					push		AX
00761:      					push		BX
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00762:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00763:      					BX=		AR
            
            				; AX = sfContReadWord();		// high
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00764:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00765:      					AX=		AR
            
            				; pch->insadr = mp.baseadr + ((unsigned long)AX << 16) | (unsigned long)BX;
00766:      					I1=		mp_baseadr_l
00767:      					R2=		rm[I1++]
00768:      					R3=		rm[I1]
00769:      					I1=		MC_INSADR_L
0076A:      					AR=		I0
0076B:      					I1=		AR + I1
0076C:      					AR=		R2
0076D:      					rm[I1++]=	AR + BX
0076E:      					AR=		R3
0076F:      					rm[I1]=		AR + AX + C
00770:      					pop		BX
00771:      					pop		AX
            
            
            				; Debug("inst adr=%08X\n", (int)pch->insadr);
            
            
            				; ~~ direct read ADSR parameters (right behind address)
            
            
            				; sfContRead4Word();
            
            				; pch->ADSR.VOL = sfContReadWord();
00772:      					I1=		MC_ADSR_VOL
00773:      					AR=		I0
00774:      					I1=		I1 + AR
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00775:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00776:      					rm[I1++]=	AR
            
            				; pch->ADSR.lpAttack = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00777:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00778:      					rm[I1++]=	AR
            
            				; pch->ADSR.sAttack = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00779:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
0077A:      					rm[I1++]=	AR
            
            				; pch->ADSR.lpDecay = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
0077B:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
0077C:      					rm[I1++]=	AR
            
            				; pch->ADSR.sDecay = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
0077D:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
0077E:      					rm[I1++]=	AR
            
            				; pch->ADSR.lpSustain = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
0077F:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00780:      					rm[I1++]=	AR
            
            				; pch->ADSR.sSustain = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00781:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00782:      					rm[I1++]=	AR
            
            				; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00783:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            
            				; sfContReadStart(HIADR(&pch->insadr));
00784:      					I1=		MC_INSADR_H
00785:      					AR=		I0
00786:      					I1=		AR + I1
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00787:      AR= rm[I1 -- ] 
00788:      P1 = rm[I1] 
00789:      sra AR 1 
0078A:      src P1 1 
0078B:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            				; ~~ loop address
            
            				; if(mp.flags.ADPCM)
0078C:      					push		AX
0078D:      					push		BX
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
0078E:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
0078F:      					BX=		AR		; ~~ loop address
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00790:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00791:      					AX=		AR
            					; ~
00792:      					I1=		mp@flags
00794:      					AR=		rm[I1]
00795:      					test		AR.b5
00796:      					if NZ jmp	@__md2si_label_1015
00797:      					test		AR.b3
00798:      					if ZR jmp	@__md2si_label_1411
            				@__md2si_label_1015:
            				; {
            					; tmp = SPI_DAT;
            
            					; sfContReadWord();
            
            					; ~~ ADPCM uses byte address to indicate odd frame
            
            					; pch->insloop = mp.baseadr + (tmp | (SPI_DAT << 16));
00799:      						I1=		mp_baseadr_l
0079A:      						R2=		rm[I1++]
0079B:      						R3=		rm[I1]
0079C:      						I1=		MC_INSLOOP_L
0079D:      						AR=		I0
0079E:      						I1=		I1 + AR
0079F:      						AR=		R2
007A0:      						rm[I1++]=	AR + BX
007A1:      						AR=		R3
007A2:      						rm[I1]=		AR + AX + C
            
            					; pch->TASPAD.HD = 0;
007A3:      						I1=		MC_ADPCM_HD
007A4:      						AR=		I0
007A5:      						I1=		I1 + AR
007A6:      						AR=		0
007A7:      						rm[I1++]=	AR
            
            					; pch->TASPAD.S0 = 0;
007A8:      						rm[I1++]=	AR
            
            					; pch->TASPAD.S1 = 0;
007A9:      						rm[I1++]=	AR
            
            					; pch->TASPAD.CNT = 0;
007AA:      						rm[I1++]=	AR
            
            					; ~~ cache first word of ADPCM data
            
            
            					; spiContReadStart(pch->insadr, &mp->md2);
            						; ~~ optimize out
            
            					; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
007AB:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            					; pch->TASPAD.BUF = AX.S;
007AC:      						rm[I1++]=	AR
            
            					; spiContReadStop();
            						; mSfContReadStop	; ~~ optimize out
            
            					; pch->insadr += 6;	; ~~ skip loop point + first word data
007AD:      						I1=		MC_INSADR_L
007AE:      						AR=		I0
007AF:      						I1=		I1 + AR
007B0:      						AR=		rm[I1]
007B1:      						AR=		AR + 6
007B2:      						rm[I1++]=	AR
007B3:      						AR=		rm[I1]
007B4:      						AR=		AR + 0 + C
007B5:      						rm[I1]=		AR
            
007B6:      					jmp		@__md2si_label_1411_1
            				; }
            				; else
            				@__md2si_label_1411:
            				; {
            					; ~~ PCM uses word address
            
            					; pch->insloop = mp.baseadr + (AX | (BX << 16));
007B7:      						I1=		mp_baseadr_l
007B8:      						R2=		rm[I1++]
007B9:      						R3=		rm[I1]
007BA:      						I1=		MC_INSLOOP_L
007BB:      						AR=		I0
007BC:      						I1=		I1 + AR
007BD:      						AR=		R2
007BE:      						rm[I1++]=	AR + BX
007BF:      						AR=		R3
007C0:      						rm[I1]=		AR + AX + C
            
            					; pch->insadr += 4;		// skip loop point
007C1:      						I1=		MC_INSADR_L
007C2:      						AR=		I0
007C3:      						I1=		I1 + AR
007C4:      						AR=		rm[I1]
007C5:      						AR=		AR + 4
007C6:      						rm[I1++]=	AR
007C7:      						AR=		rm[I1]
007C8:      						AR=		AR + 0 + C
007C9:      						rm[I1]=		AR
            				; }
            				@__md2si_label_1411_1:
007CA:      					pop		BX
007CB:      					pop		AX
            
            				; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
007CC:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            				; Debug("loop adr=%08X\n", (int)pch->insloop);
            
            
            				; chmask = mp.mchmask & (1 << pch->midich);
007CD:      					P1.hh=		0			; ~~ for FDSP
007CE:      					P1=		#@md2chmask_table
007D1:      					I1=		MC_MIDICH
007D2:      					AR=		I0
007D3:      					I1=		I1 + AR
007D4:      					AR=		rm[I1]			; ~~ pch->midich
007D5:      					P1=		P1 + AR
007D6:      					I1=		mp@mchmask
007D8:      					R2=		rm[I1]
007D9:      					AR=		pm[P1]
007DA:      					AR=		AR & R2
            
            				; if(chmask)
007DB:      					if ZR jmp	@__md2si_label_1644
            				; {
            					; ~~ channel enable
            
            					; mp.PlayChannel |= (1 << i);
007DC:      						I1=		mp@PlayChannel_l
007DE:      						AR=		rm[I1]
007DF:      						rm[I1++]=	AR | BX
007E0:      						AR=		rm[I1]
007E1:      						rm[I1]=		AR | AX
            
            					; mp.ReleaseCh &= ~(1 << i);
007E2:      						I1=		mp@ReleaseCh_l
007E4:      						AR=		rm[I1]
007E5:      						AR=		AR ^ 0xFF
007E6:      						AR=		AR | BX
007E7:      						AR=		AR ^ 0xFF
007E8:      						rm[I1++]=	AR
007E9:      						AR=		rm[I1]
007EA:      						AR=		AR ^ 0xFF
007EB:      						AR=		AR | AX
007EC:      						AR=		AR ^ 0xFF
007ED:      						rm[I1]=		AR
            
007EE:      					jmp		@__md2si_label_1644_1
            				; }
            				; else
            				@__md2si_label_1644:
            				; {
            					; ~~ channel mask
            
            					; mp.PlayChannel &= ~(1 << i);
007EF:      						I1=		mp@PlayChannel_l
007F1:      						AR=		rm[I1]
007F2:      						AR=		AR ^ 0xFF
007F3:      						AR=		AR | BX
007F4:      						AR=		AR ^ 0xFF
007F5:      						rm[I1++]=	AR
007F6:      						AR=		rm[I1]
007F7:      						AR=		AR ^ 0xFF
007F8:      						AR=		AR | AX
007F9:      						AR=		AR ^ 0xFF
007FA:      						rm[I1]=		AR
            
            					; mp.ReleaseCh &= ~(1 << i);
007FB:      						I1=		mp@ReleaseCh_l
007FD:      						AR=		rm[I1]
007FE:      						rm[I1++]=	AR | BX
007FF:      						AR=		rm[I1]
00800:      						rm[I1]=		AR | AX
            				; }
            				@__md2si_label_1644_1:
            
            
            				; sfContReadStart(HIADR(&mp.note));
00801:      					I1=		mp@note_l
00803:      					AR=		rm[I1]
00804:      					rm[I1++]=	AR + DX
00805:      					AR=		rm[I1]
00806:      					AR=		AR + 0 + C
00807:      					rm[I1]=		AR
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00808:      AR= rm[I1 -- ] 
00809:      P1 = rm[I1] 
0080A:      sra AR 1 
0080B:      src P1 1 
0080C:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            			; }
            			@__md2si_label_0328:
            		; __md2si_label_0328:
            
            			; mp.PlayInfo >>= 1;
0080D:      				slz		BX, 1
0080E:      				slc		AX, 1
            
            			; pch++;
0080F:      				AR=		MC_SIZEOF
00810:      				I0=		I0 + AR
            
00811:      			loop		@md2si_loop_1344
            		; }
            	; }
            	@md2si_label_1340:
00812:      		I1=		mp@PlayInfo_l
00814:      		rm[I1++]=	R0
00815:      		rm[I1]=		R1
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00816:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	@md2si_label_1645:
            	; ~~ Debug("PlayChannel=%08X\n", mp->PlayChannel);
            
00817:      	rets
            
            	; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            md2ScaleTable:
            @md2chmask_table:
00818:      	DW 0x0001
00819:      	DW 0x0002
0081A:      	DW 0x0004
0081B:      	DW 0x0008
0081C:      	DW 0x0010
0081D:      	DW 0x0020
0081E:      	DW 0x0040
0081F:      	DW 0x0080
00820:      	DW 0x0100
00821:      	DW 0x0200
00822:      	DW 0x0400
00823:      	DW 0x0800
00824:      	DW 0x1000
00825:      	DW 0x2000
00826:      	DW 0x4000
00827:      	DW 0x8000
            ; }
            
            
00828:      	DW 0x2000, 0x21E8, 0x23EC, 0x260E, 0x2852, 0x2AB8, 0x2D42, 0x2FF3, 0x32CC, 0x35D2, 0x3905, 0x3C69	; -12 ~ -1
            @md2shift_table:
00834:      	DW 0x4000												; 0
00835:      	DW 0x43CF, 0x47D7, 0x4C1C, 0x50A3, 0x556F, 0x5A83, 0x5FE5, 0x6598, 0x6BA3, 0x7209, 0x78D1, 0x8000	; 1 ~ 12
            
            
            
            ; ~.~---------------------------------------------------------------
            ; void md2ExtEvent(void)
            ;
            ; in:
            ;    none
            ;
            ; out:
            ;    none
            ;
            ;
            ; affect registers:
            ;    AR, AX, BX, CX, DX, I0, I1, R0, R1, R2, R3
            ;
            ; meaning registers:
            ;    AX:BX	- (1 << i)
            ;    CX		- i
            ;    DX		- next pch
            ;    I0		- pch
            ;    I1		- mp.??
            ;    R1:R0	- mp.PlayInfo
            ;    R2		- AX
            ;    R3		- BX
            ;
            ; special request:
            ;
            ;
            ; ------------------------------------------------------------------
            md2ExtEvent:
            ; {
            	; md2Channel *pch;
            	; DSP16 AX, BX;
            	; int i;
            
            	; if(mp.extev & 0x04)
00841:      		I1=		mp@extev
00843:      		AR=		rm[I1]
00844:      		test		AR.b2
00845:      		if ZR jmp	@md2extev_label_1428
            	; {
            		; ~~ extend event 4-bit
            
            		; ~~ +-----------+---------------+--------------+
            		; ~~ | ext event | event channel | control data |
            		; ~~ | 4-bit     |    20-bit     |    n bytes   |
            		; ~~ +-----------+---------------+--------------+
            
            		; sfContReadStart(HIADR(&mp.note));
00846:      			I1=		mp@note_h
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00848:      AR= rm[I1 -- ] 
00849:      P1 = rm[I1] 
0084A:      sra AR 1 
0084B:      src P1 1 
0084C:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            		; // +-------------------+
            		; // |  Channel [19:16]  |  N0
            		; // +-------------------+       L
            		; // |       ExtEV       |  N1
            		; // +-------------------+
            		; // |  Channel [11:8]   |  N2
            		; // +-------------------+       H
            		; // |  Channel [15:12]  |  N3
            		; // +-------------------+
            
            		; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
0084D:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
0084E:      			R0=		AR
            
            		; mp.extev = AX.N1;
0084F:      			I1=		mp@extev
00851:      			sra		AR, 2
00852:      			sra		AR, 2
00853:      			AR=		AR & 0x0F
00854:      			rm[I1]=		AR
            
            		; ~~ volume control
            
            		; if(mp.extev & 0x01)
00855:      			test		AR.b0
00856:      			if ZR jmp	@md2extev_label_1542
            		; {
            			; mp.PlayInfo = (((unsigned long)AX.N0) << 16) |
            					; ((unsigned long)AX.H << 8);
00857:      				AR=		0x0F
00858:      				AR=		AR & R0
00859:      				R1=		AR
0085A:      				AR=		0xFF00
0085C:      				R0=		R0 & AR
            
            			; // +-------------------+
            			; // |                   |  N0
            			; // |  Channel [7:0]    |       L
            			; // |                   |  N1
            			; // +-------------------+
            			; // |                   |  N2
            			; // |     Data 0        |       H
            			; // |                   |  N3
            			; // +-------------------+
            
            			; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
0085D:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            			; ~~ mp.note += 4;
            				; I1=		mp@note_l
            				; AR=		rm[I1]
            				; AR=		AR + 2
            				; rm[I1++]=	AR
            				; AR=		rm[I1]
            				; AR=		AR + 0 + C
            				; rm[I1]=		AR
            
            			; mp.PlayInfo |= (unsigned long)AX.L;
0085E:      				AX=		AR
0085F:      				AH=		0
00860:      				R0=		R0 | AR
            
            			; c = 4;
00861:      				DX=		4
            
            			; for(i = 0; (i < 20) && (mp->PlayInfo); i++)
00862:      				io[ClrWDT]=	AR
00863:      				CX=		19
00864:      				I1=		mp@ch0@FLTG
            			@md2extev_loop_1807:
00866:      				AR=		R0
00867:      				AR=		AR | R1
00868:      				if ZR jmp	@md2extev_label_1808
            			; {
            				; if(mp->PlayInfo & 0x01)
00869:      					sra		R1, 1
0086A:      					src		R0, 1
0086B:      					if NC jmp	@md2extev_label_1808_1
            				; {
            					; BX.L = AX.H
0086C:      						AR=		AX
0086D:      						xchg		AR
0086E:      						AH=		0
0086F:      						BX=		AR
            
            					; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00870:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            					; BX.H = AX.L
00871:      						AX=		AR
00872:      						xchg		AR
00873:      						AL=		0
            
            					; mp.ch[i].FLTG = BX.U;
00874:      						rm[I1]=		BX | AR
            
            					; c += 2;
00875:      						DX++
00876:      						DX++
            				; }
            				@md2extev_label_1808_1:
            
            				; mp->PlayInfo >>= 1;
00877:      					AR=		MC_SIZEOF
00878:      					I1=		I1 + AR
            
00879:      				loop		@md2extev_loop_1807
            			; }
            			@md2extev_label_1808:
            
            			; mp.note += c;
0087A:      				I1=		mp@note_l
0087C:      				AR=		rm[I1]
0087D:      				rm[I1++]=	AR + DX
0087E:      				AR=		rm[I1]
0087F:      				AR=		AR + 0 + C
00880:      				rm[I1]=		AR
            
            			; ~~ stop continue function and restart it again
            			; ~~ for align reason.
            
            			; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00881:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            			; sfContReadStart(HIADR(&mp.note));
00882:      				I1=		mp@note_h
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00884:      AR= rm[I1 -- ] 
00885:      P1 = rm[I1] 
00886:      sra AR 1 
00887:      src P1 1 
00888:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            			; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00889:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
0088A:      				R0=		AR
            		; }
            		@md2extev_label_1542:
            
            		; // pitch bend
            
            		; if(mp.extev & 0x02)
0088B:      			I1=		mp@extev
0088D:      			AR=		rm[I1]
0088E:      			test		AR.b1
0088F:      			if ZR jmp	@md2extev_label_1846
            		; {
            			; // +-------------------+
            			; // |  Channel [19:16]  |  N0
            			; // +-------------------+       L
            			; // |       Dummy       |  N1
            			; // +-------------------+
            			; // |  Channel [11:8]   |  N2
            			; // +-------------------+       H
            			; // |  Channel [15:12]  |  N3
            			; // +-------------------+
            
            			; mp->PlayInfo = (((unsigned long)AX.N0) << 16) |
            					; ((unsigned long)AX.H << 8);
00890:      				AR=		0x0F
00891:      				AR=		AR & R0
00892:      				R1=		AR
00893:      				AR=		0xFF00
00895:      				R0=		R0 & AR
            
            			; // +-------------------+
            			; // |                   |  N0
            			; // |  Channel [7:0]    |       L
            			; // |                   |  N1
            			; // +-------------------+
            			; // |                   |  N2
            			; // |     FLTP [7:0]    |       H
            			; // |                   |  N3
            			; // +-------------------+
            
            			; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00896:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            			; ~~ mp->note += 3;
            				; I1=		mp@note_l
            				; AR=		rm[I1]
            				; AR=		AR + 3
            				; rm[I1++]=	AR
            				; AR=		rm[I1]
            				; AR=		AR + 0 + C
            				; rm[I1]=		AR
            
            			; mp->PlayInfo |= (unsigned long)AX.L;
00897:      				AX=		AR
00898:      				AH=		0
00899:      				R0=		R0 | AR
            
            			; for(i = 0; (i < 20) && (mp->PlayInfo); i++)
0089A:      				io[ClrWDT]=	AR
0089B:      				CX=		19
0089C:      				I1=		mp@ch0@FLTP
0089E:      				DX=		4
            			@md2extev_loop_1850:
0089F:      				AR=		R0
008A0:      				AR=		AR | R1
008A1:      				if ZR jmp	@md2extev_label_1850
            			; {
            				; if(mp->PlayInfo & 0x01)
008A2:      					sra		R1, 1
008A3:      					src		R0, 1
008A4:      					if NC jmp	@md2extev_label_1850_1
            				; {
            					; mp->note += 2;
008A5:      						DX++
008A6:      						DX++
            
            					; BX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
008A7:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            					; mp->ch[i].FLTP = (unsigned long)BX.U;
008A8:      						rm[I1]=		AR
            				; }
            				@md2extev_label_1850_1:
            
            				; mp->PlayInfo >>= 1;
008A9:      					AR=		MC_SIZEOF
008AA:      					I1=		I1 + AR
            
008AB:      				loop		@md2extev_loop_1850
            			; }
            			@md2extev_label_1850:
            
            			; ~~ write back
008AC:      				I1=		mp@note_l
008AE:      				AR=		rm[I1]
008AF:      				rm[I1++]=	AR + DX
008B0:      				AR=		rm[I1]
008B1:      				AR=		AR + 0 + C
008B2:      				rm[I1]=		AR
            		; }
            		@md2extev_label_1846:
            
            		; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
008B3:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            		; mp.PlayInfo = 0;
            		; mp.ExtEV = 0;
008B4:      			I1=		mp@extev
008B6:      			AR=		0
008B7:      			rm[I1]=		AR
            	; }
            	@md2extev_label_1428:
            
008B8:      	rets
            ; }
            
            
            ; ~.~---------------------------------------------------------------
            ; void md2DoADSR(void)
            ;
            ; in:
            ;    none
            ;
            ; out:
            ;    none
            ;
            ;
            ; affect registers:
            ;    AR, AX, BX, CX, DX, I0, I1, R0, R1, R2
            ;
            ; meaning registers:
            ;    AX:BX	- ~(1 << i)
            ;    CX		- i
            ;    DX		- next pch
            ;    I0		- pch (pch->FLTG)
            ;    I1		- mp.??
            ;    R1:R0	- ch
            ;    R2		- j
            ;
            ; special request:
            ;
            ;
            ; ------------------------------------------------------------------
            md2DoADSR:
            ; {
            	; md2Channel *pch;
            	; int ch;
            	; int i, j;
            
            	; if(!(mp->ReleaseCh & mask))
008B9:      		I1=		mp@ReleaseCh_l
008BB:      		AR=		BX
008BC:      		AR=		AR ^ 0xFF
008BD:      		DX=		rm[I1++]
008BE:      		AR=		AR & DX
008BF:      		if NZ jmp	@md2drc_label_1904
008C0:      		AR=		AX
008C1:      		AR=		AR ^ 0xFF
008C2:      		DX=		rm[I1]
008C3:      		AR=		AR & DX
008C4:      		if NZ jmp	@md2drc_label_1904
            	; {
            		; ~~ do ADSR if not in release mode.
            
            		; ~~ offset aware !!!
            		; pch->ADSR
            
            		; if(pch->ADSR.lpAttack)
008C5:      			I1=		MC_ADSR_LPATTACK
008C6:      			AR=		I0
008C7:      			I1=		I1 + AR
008C8:      			AR=		rm[I1]
008C9:      			if ZR jmp	@md2drc_label_1646
            		; {
            			; pch->ADSR.lpAttack--;
008CA:      				AR--
008CB:      				rm[I1++]=	AR
            
            			; pch->ADSR.VOL += pch->ADSR.sAttack;
008CC:      				DX=		rm[I1]
008CD:      				I1=		MC_ADSR_VOL
008CE:      				AR=		I0
008CF:      				I1=		I1 + AR
008D0:      				AR=		rm[I1]
008D1:      				rm[I1]=		AR + DX
            
008D2:      			jmp		@md2drc_label_1646_1
            		; }
            		; else
            		@md2drc_label_1646:
            		; {
            			; if(pch->ADSR.lpDecay)
008D3:      				I1=		MC_ADSR_LPDECAY
008D4:      				AR=		I0
008D5:      				I1=		I1 + AR
008D6:      				AR=		rm[I1]
008D7:      				if ZR jmp	@md2drc_label_1647
            			; {
            				; pch->ADSR.lpDecay--;
008D8:      					AR--
008D9:      					rm[I1++]=	AR
            
            				; pch->ADSR.VOL += pch->ADSR.sDecay;
008DA:      					DX=		rm[I1]
008DB:      					I1=		MC_ADSR_VOL
008DC:      					AR=		I0
008DD:      					I1=		I1 + AR
008DE:      					AR=		rm[I1]
008DF:      					rm[I1]=		AR + DX
            
008E0:      				jmp		@md2drc_label_1646_1
            			; }
            			; else
            			@md2drc_label_1647:
            			; {
            				; if(pch->ADSR.lpSustain)
008E1:      					I1=		MC_ADSR_LPSUSTAIN
008E2:      					AR=		I0
008E3:      					I1=		I1 + AR
008E4:      					AR=		rm[I1]
008E5:      					if ZR jmp	@md2drc_label_1744
            				; {
            					; pch->ADSR.lpSustain--;
008E6:      						AR--
008E7:      						rm[I1++]=	AR
            
            					; pch->ADSR.VOL += pch->ADSR.sSustain;
008E8:      						DX=		rm[I1]
008E9:      						I1=		MC_ADSR_VOL
008EA:      						AR=		I0
008EB:      						I1=		I1 + AR
008EC:      						AR=		rm[I1]
008ED:      						rm[I1]=		AR + DX
008EE:      					jmp		@md2drc_label_1646_1
            				; }
            				; else
            				@md2drc_label_1744:
            				; {
008EF:      					I1=		MC_ADSR_VOL
008F0:      					AR=		I0
008F1:      					I1=		I1 + AR
008F2:      					jmp		@md2drc_label_1837
            				; }
            			; }
            		; }
            		@md2drc_label_1646_1:
            
            
            		; if(pch->ADSR.VOL > 32767)
008F3:      			if AV jmp	@md2drc_label_1406
008F4:      			jmp		@md2drc_label_1406_1
            		@md2drc_label_1406:
            		; {
            			; pch->ADSR.VOL = 32767;
008F5:      				AR=		0x7FFF
008F7:      				rm[I1]=		AR
008F8:      			jmp		@md2drc_label_1837
            		; }
            		@md2drc_label_1406_1:
            
            		; if(pch->ADSR.VOL < 0)
008F9:      			AR=		rm[I1]
008FA:      			if GE jmp	@md2drc_label_1837
            		; {
            			; pch->ADSR.VOL = 0;
008FB:      				AR=		0
008FC:      				rm[I1]=		AR
008FD:      				jmp		@md2drc_label_1825
            		; }
            		@md2drc_label_1837:
            
            
            		; MX = (pch->FLTG * pch->VOL) >> 15;
            
            		#ifdef _MSPEECHDSP_
            			AR=		rm[I1]		; ~~ offset aware - pch->ADSR.VOL
            			MX=		AR
            			I1=		MC_FLTG
            			AR=		I0
            			I1=		I1 + AR
            			AR=		rm[I1]
            			MULSS
            
            			slz		MR0, 1
            			slc		MR1, 1
            			AR=		MR1
            		@md2drc_label_1825:
            			P0=		AR		; ~~ MX
            		#else
            			#ifdef _MSPEECHDSP2_ && MIDIPCMDEC
008FE:      				AR=		rm[I1]		; ~~ offset aware - pch->ADSR.VOL
008FF:      				MX=		AR
00900:      				I1=		MC_FLTG
00901:      				AR=		I0
00902:      				I1=		I1 + AR
00903:      				AR=		rm[I1]
00904:      				MR=		MX * AR
00905:      				slz		MR0, 1
00906:      				slc		MR1, 1
00907:      				AR=		MR1
00908:      				MX=		AR
            
            				; assistance vol
            
00909:      				AR=		rm[mp_vol]
0090A:      				AR=		AR & 0x3F
0090B:      				xchg		AR
0090C:      				AL=		0xFF
0090D:      				MR=		MX * AR
0090E:      				slz		MR0, 2
0090F:      				slc		MR1, 2
00910:      				AR=		MR1
            			@md2drc_label_1825:
00911:      				P0=		AR
00912:      				set		AR.b15
00913:      				FLTG=		AR
            			#else
            				AR=		rm[I1]		; ~~ offset aware - pch->ADSR.VOL
            				MX=		AR
            				I1=		MC_FLTG
            				AR=		I0
            				I1=		I1 + AR
            				AR=		rm[I1]
            				MR=		MX * AR
            
            				slz		MR0, 1
            				slc		MR1, 1
            				AR=		MR1
            			@md2drc_label_1825:
            				P0=		AR		; ~~ MX
            			#endif
            		#endif
            
00914:      		jmp		@md2drc_label_1018
            	; }
            	@md2drc_label_1904:
            
            
            	; j = (int)(pch->ADSR.VOL - pch->GainFade);
            		; ~~ offset aware
            		; ~~ pch->ADSR.VOL
00915:      		I1=		MC_RR
00916:      		AR=		I0
00917:      		I1=		I1 + AR
00918:      		DX=		rm[I1]
            		; I1=		MC_ADSR_VOL
            		; AR=		I0
            		; I1=		I1 + AR
00919:      		AR=		MC_ADSR_VOL - MC_RR
0091A:      		I1=		I1 + AR
0091B:      		AR=		rm[I1]
0091C:      		AR=		AR - DX
            
            	; if(j <= 0)
0091D:      		if LE jmp	@md2drc_label_1853
0091E:      		jmp		@md2drc_label_1853_1
            	@md2drc_label_1853:
            	; {
            		; pch->ADSR.VOL = 0;
0091F:      			AR=		0
00920:      			rm[I1]=		AR
            
            		; MX = 0;
00921:      			P0=		0
            
            		; mp->ReleaseCh &= (~mask);
00922:      			I1=		mp@ReleaseCh_l
00924:      			AR=		rm[I1]
00925:      			rm[I1++]=	AR & BX
00926:      			AR=		rm[I1]
00927:      			rm[I1++]=	AR & AX
            
            		; mp->PlayChannel &= (~mask);
00928:      			I1=		mp@PlayChannel_l
0092A:      			AR=		rm[I1]
0092B:      			rm[I1++]=	AR & BX
0092C:      			AR=		rm[I1]
0092D:      			rm[I1]=		AR & AX
            
            		; return false;
0092E:      			clr		Z
0092F:      			rets
            	; }
            	; else
            	@md2drc_label_1853_1:
            	; {
            		; pch->ADSR.VOL = j;
00930:      			rm[I1]=		AR
            	; }
            
            
            	; MX = (pch->FLTG * pch->ADSR.VOL) >> 15;
00931:      		MX=		AR
00932:      		I1=		MC_FLTG
00933:      		AR=		I0
00934:      		I1=		I1 + AR
00935:      		AR=		rm[I1]
            
            	#ifdef _MSPEECHDSP_
            		MULSS
            		slz		MR0, 1
            		slc		MR1, 1
            		AR=		MR1
            		P0=		AR		; ~~ MX
            	#else
            
            		#ifdef _MSPEECHDSP2_ && MIDIPCMDEC
00936:      			MR=		MX * AR
00937:      			slz		MR0, 1
00938:      			slc		MR1, 1
00939:      			AR=		MR1
0093A:      			MX=		AR
            
            			; assistance vol
            
0093B:      			AR=		rm[mp_vol]
0093C:      			AR=		AR & 0x3F
0093D:      			xchg		AR
0093E:      			AL=		0xFF
0093F:      			MR=		MX * AR
00940:      			slz		MR0, 2
00941:      			slc		MR1, 2
00942:      			AR=		MR1
00943:      			P0=		AR		; ~~ always needed
00944:      			set		AR.b15
00945:      			FLTG=		AR
            		#else
            			MR=		MX * AR
            			slz		MR0, 1
            			slc		MR1, 1
            			AR=		MR1
            			P0=		AR		; ~~ MX
            		#endif
            
            	#endif
            
            	@md2drc_label_1018:
00946:      		I1=		MC_LEFT_VOL
00947:      		AR=		I0
00948:      		I1=		I1 + AR
00949:      		rm[I1]=		P0
            
            	; return true;
0094A:      		set		Z
0094B:      		rets
            ; }
            
            
            
            
            
            ; ~~ DO channel here
            
            
            
            __RAMFUNC_SEGMENT_START:
            
            
            
            ; ~.~-----------------------------------------------------
            ; bool md2DoChannelSub(WORD count, WORD *prender, LONG mask)
            ;
            ; in:
            ;    CX		- count
            ;    I0		- point to Channel
            ;    I1		- *prender
            ;    AX:BX	- mask
            ;
            ; out:
            ;    Z		- continue
            ;    NZ		- stop
            ;
            ; affect registers:
            ;
            ;
            ; meaning registers:
            ;
            ;
            ; --------------------------------------------------------
            
            
            #ifdef SOFTADPDEC
            
            
            ; ~.~-----------------------------------------------------
            ; bool md2DoChannelSub(WORD count, WORD *prender, LONG mask)
            
            md2DoChannelAdpcmSub:
            ; {
            	; for(i = 0; i < count; i++)
            		push		R0
            	@md2dcsadp_loop_1039_1:
            	; {
            		push		I1
            		I1=		MC_SAMPLE_SKIP
            		AR=		I0
            		I1=		I1 + AR
            		AR=		rm[I1]
            		R0=		AR
            	#ifdef __RAMFUNC_ENABLE__
            
            	#else
            		PCH=		NextSampleAdpcm
            	#endif
            
            		; if(!FLTP)
            			AR=		FLTP
            			if NZ jmp	@md2dcsadp_label_1435
            		; {
            			; do
            			@md2dcsadp_loop_1436:
            			; {
            				; if(!NextSampleAdpcm())
            				#ifdef __RAMFUNC_ENABLE__
            					call		NextSampleAdpcmFast
            				#else
            					; PCH=		NextSampleAdpcm
            					lcall		NextSampleAdpcm
            				#endif
            					if ZR jmp	@md2dcsadp_label_1437
            				; {
            					; return false;
            						pop		I1
            						pop		R0
            						rets
            				; }
            				@md2dcsadp_label_1437:
            
            			; } while(mp[i].skip--);
            				R0--
            				if ZR jmp	@md2dcsadp_label_1438
            				jmp		@md2dcsadp_loop_1436
            
            				; push		I1
            				; AR=		MC_SAMPLE_SKIP
            				; AR=		I0 + AR
            				; I1=		AR
            				; AR=		rm[I1]
            				; AR--
            				; rm[I1++]=	AR
            				; if ZR jmp	@md2dcsadp_label_1438
            				; pop		I1
            				; jmp		@md2dcsadp_loop_1436
            			@md2dcsadp_label_1438:
            
            				AR=		P0
            
            				#ifdef _MSPEECHDSP_
            					MULSS
            				#else
            					MR=		MX * AR
            				#endif
            					slz		MR0, 1
            					slc		MR1, 1
            
            				AR=		MR1
            				MX=		AR
            
            				; assistance vol
            
            				AR=		rm[mp_vol]
            				AR=		AR & 0x3F
            				xchg		AR
            				AL=		0xFF
            
            
            				#ifdef _MSPEECHDSP_
            					MULSS
            				#else
            					MR=		MX * AR
            				#endif
            
            					slz		MR0, 2
            					slc		MR1, 2
            
            				AR=		MR1
            				MX=		AR
            
            
            
            			jmp		@md2dcsadp_label_1435_1
            		; }
            		; else
            		@md2dcsadp_label_1435:
            		; {
            			; do
            			@md2dcsadp_loop_1039:
            			; {
            				; if(FIFORDY)
            					if FA jmp	@md2dcsadp_label_1732
            				; {
            					; if(!NextSampleAdpcm())
            					#ifdef __RAMFUNC_ENABLE__
            						call		NextSampleAdpcmFast
            					#else
            						; PCH=		NextSampleAdpcm
            						lcall		NextSampleAdpcm
            					#endif
            						if ZR jmp	@md2dcsadp_label_1520
            					; {
            						; return false;
            							pop		I1
            							pop		R0
            							rets
            					; }
            					@md2dcsadp_label_1520:
            
            
            					AR=		P0
            
            					#ifdef _MSPEECHDSP_
            						MULSS
            					#else
            						MR=		MX * AR
            					#endif
            						slz		MR0, 1
            						slc		MR1, 1
            
            					AR=		MR1
            
            					; FLTI = Sample;
            						FLTI=		AR
            				; }
            				@md2dcsadp_label_1732:
            
            			; } while(mp[i].skip--);
            				AR=		FLTO	; ~~ fetch FLTO
            				MX=		AR
            				R0--
            				if ZR jmp	@md2dcsadp_label_1618
            				jmp		@md2dcsadp_loop_1039
            				; AR=		FLTO	; ~~ fetch FLTO
            				; MX=		AR
            				; push		I1
            				; AR=		MC_SAMPLE_SKIP
            				; AR=		I0 + AR
            				; I1=		AR
            				; AR=		rm[I1]
            				; AR--
            				; rm[I1++]=	AR
            				; if ZR jmp	@md2dcsadp_label_1618
            				; pop		I1
            				; jmp		@md2dcsadp_loop_1039
            			@md2dcsadp_label_1618:
            		; }
            		@md2dcsadp_label_1435_1:
            
            		; mp[i].skip = mp[i].skipre;
            			; AR=		rm[I1--]
            			; rm[I1]=		AR
            
            		; sample = ((LONG)FLTO * MX) >> 15;
            
            		#ifdef _MSPEECHDSP_
            			AR=		1			; ~~ Volume
            			MULSS
            		#else
            			MR=		MX * 1
            		#endif
            
            
            		@md2dcsadp_label_1723:
            			pop		I1
            			DX=		rm[I1]
            			AR=		MR0
            			rm[I1++]=	AR + DX
            			AR=		MR1
            			DX=		rm[I1]
            			rm[I1++]=	AR + DX + C
            
            		loop		@md2dcsadp_loop_1039_1
            	; }
            	@md2dcsadp_label_1335:
            
            	; return true;
            		pop		R0
            		set		Z
            		rets
            
            
            ; }
            
            
            #else
            
            
            #ifdef MIDIPCMDEC
            
            
            md2DoChannelMidpcmSub:
            ; {
            	; for(i = 0; i < count; i++)
            	@md2dcsmip_loop_1039_1:
            	; {
0094C:      		push		I1
0094D:      		I1=		MC_SAMPLE_SKIP
0094E:      		AR=		I0
0094F:      		I1=		I1 + AR
00950:      		P0=		rm[I1]
00951:      		PCH=		NextSampleMidpcm
            		; pop		I1
            
            		; if(!FLTP)
00952:      			AR=		FLTP
00953:      			if NZ jmp	@md2dcsmip_label_1435
            		; {
            			; do
            			@md2dcsmip_loop_1436:
            			; {
            				; if(!NextSampleAdpcm())
            				#ifdef __RAMFUNC_ENABLE__
            					call		NextSampleAdpcmFast
            				#else
            					; PCH=		NextSampleMidpcm
00954:      					lcall		NextSampleMidpcm
            				#endif
00955:      					if ZR jmp	@md2dcsmip_label_1437
            				; {
            					; return false;
00956:      						pop		I1
00957:      						rets
            				; }
            				@md2dcsmip_label_1437:
            
            			; } while(mp[i].skip--);
00958:      				AR=		FLTO
            				; MX=		AR
00959:      				P0--
0095A:      				if ZR jmp	@md2dcsmip_label_1618
0095B:      				jmp		@md2dcsmip_loop_1436
            			; @md2dcsmip_label_1438:
            
            				; AR=		P0
            
            				; #ifdef _MSPEECHDSP_
            					; MULSS
            				; #else
            					; MR=		MX * AR
            				; #endif
            					; slz		MR0, 1
            					; slc		MR1, 1
            
            				; AR=		MR1
            				; MX=		AR
            
0095C:      			jmp		@md2dcsmip_label_1435_1
            		; }
            		; else
            		@md2dcsmip_label_1435:
            		; {
            			; do
            			@md2dcsmip_loop_1039:
            			; {
            				; if(FIFORDY)
0095D:      					if FA jmp	@md2dcsmip_label_1732
            				; {
            					; if(!NextSampleAdpcm())
            					#ifdef __RAMFUNC_ENABLE__
            						call		NextSampleAdpcmFast
            					#else
            						; PCH=		NextSampleMidpcm
0095E:      						lcall		NextSampleMidpcm
            					#endif
0095F:      						if ZR jmp	@md2dcsmip_label_1520
            					; {
            						; return false;
00960:      							pop		I1
00961:      							rets
            					; }
            					@md2dcsmip_label_1520:
            				; }
            				@md2dcsmip_label_1732:
            
            			; } while(mp[i].skip--);
00962:      				AR=		FLTO	; ~~ fetch FLTO
            				; MX=		AR
00963:      				P0--
00964:      				if ZR jmp	@md2dcsmip_label_1618
00965:      				jmp		@md2dcsmip_loop_1039
            			@md2dcsmip_label_1618:
00966:      				MX=		AR
            		; }
            		@md2dcsmip_label_1435_1:
            
            		; mp[i].skip = mp[i].skipre;
            			; AR=		rm[I1--]
            			; rm[I1]=		AR
            
            		; sample = ((LONG)FLTO * MX) >> 15;
            
            		#ifdef _MSPEECHDSP_
            			AR=		1			; ~~ Volume
            			MULSS
            		#else
00967:      			MR=		MX * 1
            		#endif
            
            
            		@md2dcsmip_label_1723:
00968:      			pop		I1
00969:      			DX=		rm[I1]
0096A:      			AR=		MR0
0096B:      			rm[I1++]=	AR + DX
0096C:      			AR=		MR1
0096D:      			DX=		rm[I1]
0096E:      			rm[I1++]=	AR + DX + C
            
0096F:      		loop		@md2dcsmip_loop_1039_1
            	; }
            	@md2dcsmip_label_1335:
            
            	; return true;
00970:      		set		Z
00971:      		rets
            
            
            ; }
            
            
            #else
            
            
            ; -------------------------------------
            ; bool NextSamplePCM(*pch, ChannelBit, Offset)
            ; -------------------------------------
            ; input:
            ;    AX:BX      - channel mask bit
            ;    P1         - ADPCM data address
            ;    I0 	- pch
            ;    R3		- Offset
            ;
            ; -------------------------------------
            ; return:
            ;    Z          - decode OK
            ;    NZ         - decode stop
            ;    AR		- decode Sample
            ;    R3		- Offset
            ; -------------------------------------
            ; protected:
            ;    I0, I1, DX
            
            NextSamplePCM:
            ; {
            	; AX = SPI_DAT;
            		mSfContReadWord
            
            	; if(AX.U == 0x8000)
            		R2=		0x8000
            		SF=		AR - R2
            		if NE jmp	@md2dc_label_1318
            	; {
            		; sfContReadStop();
            			mSfContReadStop
            
            		; if(pch->insloop == mp.baseadr)
            			; ~~ offset aware - pch->insloop
            			push		I1
            			push		DX
            			I1=		mp_baseadr_l
            			DX=		rm[I1++]
            			R2=		rm[I1]
            			AR=		I0
            			I1=		AR
            			AR=		rm[I1++]
            			DX=		DX - AR
            			AR=		rm[I1]
            			AR=		R2 - AR + C - 1
            			AR=		AR | DX
            			if NZ jmp	@md2dc_label_1323
            		; {
            			; ~~ disable this channel if not loop
            
            			; mp.PlayChannel &= ~(1 << i);
            				I1=		mp@PlayChannel_l
            				AR=		rm[I1]
            				rm[I1++]=	AR & BX
            				AR=		rm[I1]
            				rm[I1]=		AR & AX
            
            			; return false;
            				pop		DX
            				pop		I1
            				clr		Z
            				rets
            		; }
            		@md2dc_label_1323:
            
            
            		; pch->insadr = pch->insloop;
            			; ~~ offset aware -
            			;       pch->insloop
            			;       pch->insadr
            			AR=		I0
            			I1=		AR
            			AR=		rm[I1++2]
            			rm[I1--]=	AR
            			AR=		rm[I1++2]
            			rm[I1]=		AR
            
            		; Offset.U = 0;
            			R3=		0
            
            		; sfContReadStart(HIADR(&pch->insadr));
            			; ~~ offset aware -
            			;	pch->insadr
            			mSfContReadStart
            
            		; AX = sfContReadWord();
            			mSfContReadWord
            			pop		DX
            			pop		I1
            	; }
            	@md2dc_label_1318:
            
            	; Offset.U++;
            		R3++
            
            	; return true;
            		MX=		AR
            		set		Z
            		rets
            ; }
            
            
            ; ~.~-----------------------------------------------------
            ; bool md2DoChannelSub(WORD count, WORD *prender, LONG mask)
            ;
            ; in:
            ;    CX		- count
            ;    I0		- point to Channel
            ;    I1		- *prender
            ;    AX:BX	- mask
            ;
            ; out:
            ;    Z		- continue
            ;    NZ		- stop
            ;
            ; affect registers:
            ;
            ;
            ; meaning registers:
            ;
            ;
            ; --------------------------------------------------------
            md2DoChannelSubPCM:
            ; {
            	; for(i = 0; i < count; i++)
            	@md2dcs_loop_1039_1:
            		push		I1
            		I1=		MC_SAMPLE_SKIP
            		AR=		I0
            		I1=		I1 + AR
            		DX=		rm[I1]
            		pop		I1
            	; {
            		; if(!FLTP)
            			AR=		FLTP
            			if NZ jmp	@md2dcs_label_1423
            		; {
            			; do
            			@md2dcs_loop_1424:
            			; {
            				; if(!NextSamplePCM())
            					call		NextSamplePCM
            					if ZR jmp	@md2dcs_label_1425
            				; {
            					; return false;
            						rets
            				; }
            				@md2dcs_label_1425:
            
            
            			; } while(mp[i].skip--);
            				DX--
            				if NZ jmp	@md2dcs_loop_1424
            
            				AR=		P0
            
            				#ifdef _MSPEECHDSP_
            					MULSS
            				#else
            					MR=		MX * AR
            				#endif
            					slz		MR0, 1
            					slc		MR1, 1
            
            				AR=		MR1
            				MX=		AR
            
            				; assistance vol
            
            				AR=		rm[mp_vol]
            				AR=		AR & 0x3F
            				xchg		AR
            				AL=		0xFF
            
            
            				#ifdef _MSPEECHDSP_
            					MULSS
            				#else
            					MR=		MX * AR
            				#endif
            
            					slz		MR0, 2
            					slc		MR1, 2
            
            				AR=		MR1
            				MX=		AR
            
            			jmp		@md2dcs_label_1423_1
            		; }
            		; else
            		@md2dcs_label_1423:
            		; {
            			; do
            			@md2dcs_loop_1039:
            			; {
            				; if(FIFORDY)
            					if FA jmp	@md2dc_label_1151
            				; {
            					; if(!NextSamplePCM())
            						call		NextSamplePCM
            						if ZR jmp	@md2dc_label_1520
            					; {
            						; return false;
            							rets
            					; }
            					@md2dc_label_1520:
            
            
            					AR=		P0
            
            					#ifdef _MSPEECHDSP_
            						MULSS
            					#else
            						MR=		MX * AR
            					#endif
            						slz		MR0, 1
            						slc		MR1, 1
            
            					AR=		MR1
            
            					; FLTI = AX;
            						FLTI=		AR
            				; }
            				@md2dc_label_1151:
            
            			; } while(mp[i].skip--);
            				AR=		FLTO	; ~~ fetch FLTO
            				MX=		AR
            				DX--
            				if NZ jmp	@md2dcs_loop_1039
            		; }
            		@md2dcs_label_1423_1:
            
            
            		; mp[i].skip = mp[i].skipre;
            			; nop
            
            		; sample = ((LONG)FLTO * MX) >> 15;
            
            		#ifdef _MSPEECHDSP_
            			AR=		1
            			MULSS
            		#else
            			MR=		MX * 1
            		#endif
            
            		; ~~ stereo plug-in
            
            
            
            		; *(prender++) += sample;
            		@md2dc_label_1501:
            			; pop		I1
            			DX=		rm[I1]
            			AR=		MR0
            			rm[I1++]=	AR + DX
            			AR=		MR1
            			DX=		rm[I1]
            			rm[I1++]=	AR + DX + C
            
            		loop		@md2dcs_loop_1039_1
            	; }
            	@md2dc_label_1335:
            
            	; return true;
            		set		Z
            		rets
            
            
            	; ~~ Stereo
            
            ; }
            
            
            #endif
            
            
            #endif
            
            
            
            
            
            
            
            
            
            ; ~.~---------------------------------------------------------------
            ; void md2DoChannel(void)
            ;
            ; in:
            ;    none
            ;
            ; out:
            ;    none
            ;
            ;
            ; affect registers:
            ;    AR, AX, BX, CX, DX, I0, I1, R0, R1, R2, R3
            ;
            ; meaning registers:
            ;    AX:BX	- ~(1 << i)
            ;    CX		- i, k
            ;    DX		- next pch
            ;    I0		- pch
            ;    I1		- mp.??, RENDERBUF
            ;    R1:R0	- ch
            ;    R2		- AX
            ;    R3		- BX
            ;
            ; special request:
            ;
            ;
            ; ------------------------------------------------------------------
            #ifdef __RAMFUNC_ENABLE__
            __md2DoChannel:
            	P1.hh=		0
            #else
            md2DoChannel:
            #endif
            ; {
            	; memset(mp.tinyrender, 0, sizeof(mp.tinyrender));
            
            	#ifdef _MD2_TINY_MODE2_
            
            		; if((mp.inbuf & 0x20) == (mp.outbuf & 0x20))
00972:      			AX=		rm[mp_inbuf]
00973:      			AR=		rm[mp_outbuf]
00974:      			AR=		AR ^ AX
00975:      			test		AR.b5		; ~~ long address
00976:      			if ZR jmp	@md2dc_label_1125
            		; {
            			; return;
            		; }
            
            		; memset(&RENDERBUF[mp.inbuf], 0, sizeof(long) * 32);
00977:      			CX=		7
00978:      			I1=		rm[mp_inbuf]
00979:      			AR=		0
            		@dochannel_loop_1351:
0097A:      			rm[I1++]=	AR
0097B:      			rm[I1++]=	AR
0097C:      			rm[I1++]=	AR
0097D:      			rm[I1++]=	AR
0097E:      			loop		@dochannel_loop_1351
            
            	#else
            		; _MD2_TINY_MODE1_
            
            			I1=		mp@tinyrender
            			AR=		0
            			rm[I1++]=	AR
            			rm[I1++]=	AR
            			rm[I1++]=	AR
            			rm[I1++]=	AR
            			rm[I1++]=	AR
            			rm[I1++]=	AR
            			rm[I1++]=	AR
            			rm[I1++]=	AR
            	#endif
            
            
            	; ~~ initialize render buffer
            
            	; FLTG = mp.vol;
0097F:      		AR=		rm[mp_vol]
00980:      		FLTG=		AR
            
            	; set		io[PortB].b3
            
            	; ~~
            
            	; pch = mp->ch;
00981:      		I0=		mp@ch0@insloop_l
            
            	; ch = mp->PlayChannel;
00983:      		I1=		mp@PlayChannel_l
00985:      		R0=		rm[I1++]
00986:      		AR=		rm[I1]
            
            	; if(ch)
00987:      		AR=		R0
00988:      		if ZR jmp	@md2dc_label_1619
00989:      		R1=		rm[I1]
            	; {
            		; for(i = 0; (i < 20) && ch; i++)
0098A:      			io[ClrWDT]=	AR
0098B:      			CX=		rm[mp_lop]
0098C:      			BX=		0xFFFE
0098E:      			AX=		0xFFFF
            		@md2dc_loop_1622:
00990:      			AR=		R0
00991:      			if ZR jmp	@md2dc_label_1619
            		; {
            			; if(ch & 1)
00992:      				clr		C
00993:      				src		R0, 1
00994:      				if NC jmp	@md2dc_label_1550
            			; {
            				; sfContReadStartNoWait(HIADR(&pch->insadr));
00995:      					push		CX
            				#ifdef SOFTADPDEC || MIDIPCMDEC
00996:      					I1=		MC_INSADR_L
00997:      					AR=		I0
00998:      					I1=		I1 + AR
00999:      					DX=		rm[I1]
0099A:      					AR=		DX
0099B:      					clr		AR.b0
0099C:      					rm[I1++]=	AR
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
0099D:      AR= rm[I1 -- ] 
0099E:      P1 = rm[I1] 
0099F:      sra AR 1 
009A0:      src P1 1 
009A1:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
009A2:      					rm[I1]=		DX
            
            					; AR=		MC_INSADR_H
            					; AR=		AR + I0
            					; I1=		AR
            					; AR=		rm[I1--]
            					; push		AR
            					; AR=		rm[I1]
            					; clr		AR.b0
            					; push		AR
            					; AR=		BP
            					; AR=		AR + 2
            					; I1=		AR
            					; mSfContReadStart
            					; pop		AR
            					; pop		AR
            				#else
            					AR=		MC_INSADR_H
            					AR=		AR + I0
            					I1=		AR
            					mSfContReadStart
            				#endif
            
            				; FLTI = pch->FLTI[0];
009A3:      					AR=		MC_FLTI
009A4:      					AR=		AR + I0
009A5:      					I1=		AR
009A6:      					FLTI=		rm[I1++]
            				; FLTI = pch->FLTI[1];
009A7:      					FLTI=		rm[I1++]
            				; FLTI = pch->FLTI[2];
009A8:      					FLTI=		rm[I1++]
            				; FLTI = pch->FLTI[3];
009A9:      					FLTI=		rm[I1++]
            
            				; FLTA = pch->FLTA;
009AA:      					AR=		MC_FLTA
009AB:      					AR=		AR + I0
009AC:      					I1=		AR
009AD:      					FLTA=		rm[I1++]
            
            				; FLTP = pch->FLTP;
            					; ~~ offset aware --> pch->FLTP, pch->FLTG
009AE:      					FLTP=		rm[I1++]
            
            				; temp = FLTO;				; ~~ reset state machine
009AF:      					AR=		FLTO
            
            				; BX.U = 0;
009B0:      					R3=		0
            
            				; sfWaitSPIOK();
            
            				; sfContRead4Word();
            
            
            			#ifdef _MD2_TINY_MODE2_
            
            				; if(0 == (mp.adsrcnt & 0x03))
009B1:      					I1=		mp@adsrcnt
009B3:      					AR=		rm[I1]
            				#ifdef _MD2_HALF_ADSR_
            					AR=		AR & 0x03
            				#else
009B4:      					AR=		AR & 0x01
            				#endif
009B5:      					if NZ jmp	@md2dc_label_1602
            				; {
            					; if(!md2DoADSR())
009B6:      						PCH=		md2DoADSR
009B7:      						lcall		md2DoADSR
009B8:      						if NZ jmp	@md2dc_label_1031
            					; {
            						; goto __md2dc_label_1031;
            					; }
            
009B9:      					jmp		@md2dc_label_1624
            				; }
            				; else
            				@md2dc_label_1602:
            				; {
            					; ADSRVOL = mp->lvol;
009BA:      						I1=		MC_LEFT_VOL
009BB:      						AR=		I0
009BC:      						I1=		I1 + AR
            
            					#ifdef _MSPEECHDSP2_
009BD:      						AR=		rm[I1]
009BE:      						P0=		AR
009BF:      						set		AR.b15
009C0:      						FLTG=		AR
            					#else
            						P0=		rm[I1]
            					#endif
            				; }
            				@md2dc_label_1624:
            
            
            				; if(!md2DoChannelSub(16, prender, mask))
009C1:      					CX=		15
009C2:      					I1=		rm[mp_inbuf]
            
            			#else
            
            				; _MD2_TINY_MODE1_
            
            				; if(0 == (mp.adsrcnt & 0x07))
            					I1=		mp@adsrcnt
            					AR=		rm[I1]
            				#ifdef _MD2_HALF_ADSR_
            					AR=		AR & 0x0F
            				#else
            					AR=		AR & 0x07
            				#endif
            					if NZ jmp	@md2dc_label_1602
            				; {
            
            					; if(!md2DoADSR())
            						PCH=		md2DoADSR
            						lcall		md2DoADSR
            						if NZ jmp	@md2dc_label_1031
            					; {
            						; goto __md2dc_label_1031;
            					; }
            
            					jmp		@md2dc_label_1624
            				; }
            				@md2dc_label_1602:
            				; else
            				; {
            					; ADSRVOL = mp->lvol;
            						I1=		MC_LEFT_VOL
            						AR=		I0
            						I1=		I1 + AR
            					#ifdef _MSPEECHDSP2_
            						AR=		rm[I1]
            						P0=		AR
            						set		AR.b15
            						FLTG=		AR
            					#else
            						P0=		rm[I1]
            					#endif
            				; }
            				@md2dc_label_1624:
            
            
            				; if(!md2DoChannelSub(4, prender, mask))
            					CX=		3
            					I1=		mp@tinyrender
            			#endif
            
            
            			#ifdef SOFTADPDEC
            					call		md2DoChannelAdpcmSub
            			#else
            				#ifdef MIDIPCMDEC
009C3:      					call		md2DoChannelMidpcmSub
            				#else
            					call		md2DoChannelSubPCM
            				#endif
            			#endif
009C4:      					if NZ jmp	@md2dc_label_1031
            				; {
            					; goto __md2dc_label_1031;
            				; }
            
            
            			; __md2dc_label_1031:
            				@md2dc_label_1031:
            
            				; sfContReadStop();
            
            				; pch->insadr += (int)(BX.U << 1);
009C5:      					slz		R3, 1
009C6:      					I1=		MC_INSADR_L
009C7:      					AR=		I0
009C8:      					I1=		I1 + AR
009C9:      					AR=		rm[I1]
009CA:      					AR=		AR + R3
009CB:      					rm[I1++]=	AR
009CC:      					AR=		rm[I1]
009CD:      					AR=		AR + 0 + C
009CE:      					rm[I1]=		AR
            
            				; ~~ backup all registers
            
            				; pch->FLTI[0] = FLTI;
009CF:      					AR=		MC_FLTI
009D0:      					AR=		AR + I0
009D1:      					I1=		AR
            				; pch->FLTI[4] = FLTI;
009D2:      					rm[I1++]=	FLTI
            				; pch->FLTI[5] = FLTI;
009D3:      					rm[I1++]=	FLTI
            				; pch->FLTI[6] = FLTI;
009D4:      					rm[I1++]=	FLTI
            				; pch->FLTI[7] = FLTI;
009D5:      					rm[I1++]=	FLTI
            
            				; pch->FLTA = FLTA;
            					; AR=		MC_FLTA
            					; AR=		AR + I0
            					; I1=		AR
009D6:      					AR=		MC_ADSR_VOL - MC_FLTA
009D7:      					I1=		I1 - AR
009D8:      					rm[I1]=		FLTA
009D9:      					pop		CX
            			; }
            			@md2dc_label_1550:
            
            			; ch >>= 1;
009DA:      				set		C
009DB:      				slc		BX, 1
            				; slc		AX, 1
            
            			; pch++;
009DC:      				AR=		MC_SIZEOF
009DD:      				I0=		I0 + AR
            
            
009DE:      			loop		@md2dc_loop_1622
            		; }
            	; }
            	@md2dc_label_1619:
            
            
            	; if(mp.BaseTimer >= 1)
009DF:      		I1=		mp@BaseTimer
009E1:      		AR=		rm[I1]
009E2:      		SF=		AR - 1
009E3:      		if AN jmp	@md2dc_label_1354
            	; {
            		; mp.BaseTimer--;
009E4:      			AR--
009E5:      		jmp		@md2dc_label_1354_1
            	; }
            	; else
            	@md2dc_label_1354:
            	; {
            		; mp.BaseTimer = 0;
009E6:      			AR=		0
            	; }
            	@md2dc_label_1354_1:
009E7:      		rm[I1]=		AR
            
            
            	; mp.adsrcnt++;
009E8:      		I1=		mp@adsrcnt
009EA:      		AR=		rm[I1]
009EB:      		AR++
009EC:      		rm[I1]=		AR
            
            
            
            @md2dc_label_1125:
009ED:      	P1.hh=		0
009EE:      	rets
            ; }
            
            
            NextSampleAdpcmFast:
            
            
            __RAMFUNC_SEGMENT_END:
            
            
            
            
            ; ~~ wrap function
            
            #ifdef __RAMFUNC_ENABLE__
            
            md2DoChannel:
            	AR=		#__RAMFUNC_SEGMENT_START
            	P1=		#__md2DoChannel
            	P1=		P1 - AR
            	AR=		MD2_PRAM_START_BASE
            	P1=		P1 + AR
            	P1.hh=		RAMBANK
            	fjmp		pm[P1]
            
            #endif
            
            
            
            ; +++++++++++++++++++++
            
            
            
            ; ~.~---------------------------------------------------
            ; bool md2DoRoutine(void)
            ;
            ; in:
            ;    none
            ;
            ; out:
            ;    Z		- true	(music playing)
            ;    NZ		- false	(music stop)
            ;
            ; affect registers:
            ;
            ;
            ; meaning registers:
            ;
            ;
            ; special request:
            ;
            ;
            ; -------------------------------------------------------------
            md2DoRoutine:
            ; {
            	; set		io[PortA].b0
            
            	; if(md2DoEvent())
            		; MACOP=		0
009EF:      		I1=		mp@okmask
009F1:      		AR=		rm[I1]
009F2:      		if NZ jmp	@md2dr_label_1355
009F3:      		PCH=		md2DoEvent
009F4:      		lcall		md2DoEvent
009F5:      		if NZ jmp	@md2dr_label_1355
            	; {
            		; md2SetInstrument();
            
009F6:      			PCH=		md2SetInstrument
009F7:      			lcall		md2SetInstrument
            
            		; md2ExtEvent();
009F8:      			PCH=		md2ExtEvent
009F9:      			lcall		md2ExtEvent
            	; }
            	@md2dr_label_1355:
            
            	; md2DoChannel();
009FA:      		PCH=		md2DoChannel
009FB:      		lcall		md2DoChannel
009FC:      	P1.hh=		0
009FD:      	rets
            ; }
            
            ; ----
            
            
            ; ~.~------------------------------------------------------------
            ; bool md2SelectIns(short index)
            ;
            ; in:
            ;    AX			- index
            ;
            ; out:
            ;    Z			- true
            ;    NZ			- false
            ;
            ; affect registers:
            ;    All
            ;
            ; meaning registers:
            ;    AX:BX		- flashadr
            ;
            ; special request:
            ;   none
            ;
            ; -------------------------------------------------------------
            md2SelectIns:
            ; {
            	; if(!mp.flags.INSBank)
009FE:      		I1=		mp@flags
00A00:      		AR=		rm[I1]
00A01:      		test		AR.b2
00A02:      		if ZR jmp	@md2selectins_label_1541
            	; {
            		; return false;
            	; }
            
            	; if(index >= mp.tinsbank)
00A03:      		AR=		rm[mp_tinsbank]
00A04:      		SF=		AR - AX
00A05:      		if LE jmp	@md2selectins_label_1541
00A06:      		jmp		@md2selectins_label_1541_1
            	@md2selectins_label_1541:
            	; {
            		; return false;
00A07:      			clr		Z
00A08:      			rets
            	; }
            	@md2selectins_label_1541_1:
            
            
            	; mp.keymap = mp.kmapbase + (index * 512);
00A09:      		MX=		0x0200
00A0B:      		AR=		AX
            	#ifdef _MSPEECHDSP_
            		MULSS
            	#else
00A0C:      		MACOP=		0
00A0D:      		MR=		MX * AR
            	#endif
00A0E:      		I1=		mp@kmapbase_l
00A10:      		AR=		rm[I1++]
00A11:      		MR0=		MR0 + AR
00A12:      		AR=		rm[I1]
00A13:      		MR1=		MR1 + AR + C
00A14:      		I1=		mp@keymap
00A16:      		AR=		MR0
00A17:      		rm[I1++]=	AR
00A18:      		AR=		MR1
00A19:      		rm[I1]=		AR
            
            	; return true;
00A1A:      		set		Z
00A1B:      		rets
            ; }
            
            
            ; ~.~------------------------------------------------------------
            ; bool md2PlaySong(short index)
            ;
            ; in:
            ;    AX			- index
            ;
            ; out:
            ;    none
            ;
            ; affect registers:
            ;    All
            ;
            ; meaning registers:
            ;
            ;
            ; special request:
            ;   none
            ;
            ; -------------------------------------------------------------
            md2PlaySong:
            ; {
            	; if(index >= mp.songcnt)
00A1C:      		AR=		rm[mp_songcnt]
00A1D:      		SF=		AR - AX
00A1E:      		if LE jmp	@md2playsong_label_1541
00A1F:      		jmp		@md2playsong_label_1541_1
            	@md2playsong_label_1541:
            	; {
            		; return false;
00A20:      			clr		Z
00A21:      			rets
            	; }
            	@md2playsong_label_1541_1:
            
            
            	; mp.extev = 0;
00A22:      		I1=		mp@extev
00A24:      		AR=		0
00A25:      		rm[I1]=		AR
            
            
            	; mp.note = mp.songhdr + (index * sizeof(long))
00A26:      		I1=		mp@songhdr_l
00A28:      		BX=		rm[I1++]
00A29:      		DX=		rm[I1]
00A2A:      		I1=		mp@note_l
00A2C:      		AR=		AX
00A2D:      		slz		AR, 2
00A2E:      		rm[I1++]=	BX + AR
00A2F:      		AR=		0
00A30:      		rm[I1]=		DX + AR + C
            
            
            	; if(mp.flags.INSBank)
00A31:      		I1=		mp@flags
00A33:      		AR=		rm[I1]
00A34:      		test		AR.b2
00A35:      		if ZR jmp	@md2playsong_label_1612
            	; {
            		; sfContReadStart(mp.baseadr + sizeof(MD2Header) + sizeof(DSPChannelMap) + (index * sizeof(short)));
00A36:      			BX=		rm[mp_baseadr_l]
00A37:      			DX=		rm[mp_baseadr_h]
00A38:      			AR=		20		; sizeof(MD2Header) + sizeof(DSPChannelMap)
00A39:      			BX=		BX + AR
00A3A:      			AR=		0
00A3B:      			DX=		DX + AR + C
00A3C:      			AR=		AX		; index
00A3D:      			slz		AR, 1
00A3E:      			BX=		BX + AR
00A3F:      			AR=		0
00A40:      			AR=		AR + DX + C
00A41:      			push		AR
00A42:      			push		BX
00A43:      			AR=		2
00A44:      			AR=		AR + BP
00A45:      			I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00A46:      AR= rm[I1 -- ] 
00A47:      P1 = rm[I1] 
00A48:      sra AR 1 
00A49:      src P1 1 
00A4A:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
00A4B:      			pop		AR
00A4C:      			pop		AR
            
            		; mp.occupyopr = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00A4D:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00A4E:      			I1=		mp_occupyopr
00A4F:      			rm[I1]=		AR
            
            		; sfContReadStop
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00A50:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
00A51:      		jmp		@md2playsong_label_1612_1
            	; }
            	; else
            	@md2playsong_label_1612:
            	; {
            		; mp.occupyopr = mp.lop;
00A52:      			AR=		rm[mp@lop]
00A53:      			rm[mp@occupyopr]=AR
            	; }
            	@md2playsong_label_1612_1:
            
            	; ~~ needs to clear channel indicator
            
            	; for(i = 0; i < mp.occupyopr; i++)
00A54:      		I1=		mp@ReleaseCh
00A56:      		AR=		rm[I1++]
00A57:      		R0=		AR
00A58:      		BX=		mp
00A5A:      		CX=		rm[mp@occupyopr]
00A5B:      		clr		CX.b15
00A5C:      		jmp		@md2playsong_label_1155
            	@md2playsong_loop_1155:
            	; {
            		; if(mp.ReleaseCh & (1 << i))
00A5D:      			test		R0.b0
00A5E:      			if NZ jmp	@md2playsong_label_1820
            		; {
            			; mp.ch[i].FLTG = 0x64CA;	// 100
00A5F:      				AR=		MC_FLTG
00A60:      				AR=		AR + BX
00A61:      				I1=		AR
00A62:      				AR=		0x64CA
00A64:      				rm[I1]=		AR
            		; }
            		@md2playsong_label_1820:
            
            		; mp.ch[i].midich = 0;
00A65:      			AR=		MC_MIDICH
00A66:      			AR=		AR + BX
00A67:      			I1=		AR
00A68:      			AR=		0
00A69:      			rm[I1]=		AR
            
00A6A:      			AR=		MC_SIZEOF
00A6B:      			BX=		BX + AR
            
00A6C:      			clr		C
00A6D:      			src		R0, 1
            	@md2playsong_label_1155:
00A6E:      		loop		@md2playsong_loop_1155
            
            
            	; sfContReadStart(HIADR(&mp.note));
00A6F:      		I1=		mp@note_h
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00A71:      AR= rm[I1 -- ] 
00A72:      P1 = rm[I1] 
00A73:      sra AR 1 
00A74:      src P1 1 
00A75:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            	; sfContRead2Word();
            
            	; mp.note = mp.baseadr + (SPI_DAT + (SPI_DAT << 16));
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00A76:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00A77:      		BX=		AR
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00A78:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00A79:      		DX=		AR
00A7A:      		I1=		mp_baseadr_l
00A7B:      		AR=		rm[I1++]
00A7C:      		BX=		BX + AR
00A7D:      		AR=		rm[I1]
00A7E:      		DX=		DX + AR + C
00A7F:      		I1=		mp@note_l
00A81:      		rm[I1++]=	BX
00A82:      		rm[I1]=		DX
            
            
            	; ~~ check filter mode
            
            
            	; switch(mp.note & 0xC0000000)
00A83:      		AR=		DX
00A84:      		slz		AR, 2
00A85:      		slc		AR, 2
00A86:      		AR=		AR & 0x03
00A87:      		if ZR jmp	@md2playsong_case_0_1340
00A88:      		SF=		AR - 1
00A89:      		if EQ jmp	@md2playsong_case_0_1340
00A8A:      		SF=		AR - 2
00A8B:      		if EQ jmp	@md2playsong_case_2_1340
00A8C:      		jmp		@md2playsong_case_default_1340
            	; {
            		; case 0:
            		; case 1:
            		@md2playsong_case_0_1340:
            		; {
            			; ~~ turn on filter
            
            			; mp.vol &= 0x3F;
00A8D:      				AR=		rm[mp_vol]
00A8E:      				AR=		AR & 0x3F
00A8F:      				rm[mp_vol]=	AR
            
            			; FLTG = mp.vol;
00A90:      				FLTG=		AR
            
            			; break;
00A91:      				jmp		@md2playsong_case_default_1340
            		; }
            		; case 2:
            		@md2playsong_case_2_1340:
            		; {
            			; ~~ turn off filter
            
            			; mp.vol |= 0x80;
00A92:      				AR=		rm[mp_vol]
00A93:      				set		AR.b7
00A94:      				rm[mp_vol]=	AR
            
            			; FLTG = mp.vol;
00A95:      				FLTG=		AR
            
            			; break;
00A96:      				jmp		@md2playsong_case_default_1340
            		; }
            		; default:
            		; {
            			; break;
            		; }
            	; }
            	@md2playsong_case_default_1340:
            
            
            	; mp.note &= 0x3FFFFFFF;
00A97:      		AR=		rm[I1]
00A98:      		clr		AR.b15
00A99:      		clr		AR.b14
00A9A:      		rm[I1]=		AR
            
            
            	; sfContReadStop
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00A9B:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; mp.BaseTimer = 1;
00A9C:      		AR=		1
00A9D:      		I1=		mp@BaseTimer
00A9F:      		rm[I1++]=	AR
            	; mp.EventTimer = 0x0FFF;
00AA0:      		AR=		0x0FFF
00AA2:      		rm[I1++]=	AR
            
            	; mp.lpadr = 0;
00AA3:      		AR=		0
00AA4:      		I1=		mp@lpadrl
00AA6:      		rm[I1++]=	AR
00AA7:      		rm[I1]=		AR
            
            	; md2StartBGServe();
00AA8:      		PCH=		md2StartBGServe
00AA9:      		lcall		md2StartBGServe
            
            	; return true;
00AAA:      		set		Z
00AAB:      		rets
            ; }
            
            
            ; ~.~------------------------------------------------------------
            ; bool md2PlayRhythmLoop(short index)
            ;
            ; in:
            ;    AX			- index
            ;
            ; out:
            ;    none
            ;
            ; affect registers:
            ;    All
            ;
            ; meaning registers:
            ;
            ;
            ; special request:
            ;   none
            ;
            ; -------------------------------------------------------------
            md2PlayRhythmLoop:
            ; {
            	; md2PlaySong(index);
00AAC:      		call		md2PlaySong
00AAD:      		if ZR jmp	@md2prl_label_1123
00AAE:      		rets
            	@md2prl_label_1123:
            	; mp.lpadr = mp.note;
00AAF:      		I1=		mp@note_h
00AB1:      		AR=		rm[I1--]
00AB2:      		push		AR
00AB3:      		AR=		rm[I1]
00AB4:      		I1=		mp@lpadrl
00AB6:      		rm[I1++]=	AR
00AB7:      		pop		AR
00AB8:      		rm[I1]=		AR
            
00AB9:      	rets
            ; }
            
            
            ; ~.~------------------------------------------------------------
            ; void md2StopSong(void)
            ;
            ; in:
            ;    none
            ;
            ; out:
            ;    none
            ;
            ; affect registers:
            ;    All
            ;
            ; meaning registers:
            ;
            ;
            ; special request:
            ;   none
            ;
            ; -------------------------------------------------------------
            md2StopSong:
            ; {
            	; if(md2ChkSongEnd())
00ABA:      		PCH=		md2ChkSongEnd
00ABB:      		lcall		md2ChkSongEnd
00ABC:      		if NZ jmp	@md2ss_label_1548
            	; {
            		; return;
00ABD:      			rets
            	; }
            	@md2ss_label_1548:
            
            
            	; mp.note = 0;
00ABE:      		I1=		mp@note_l
00AC0:      		AR=		0
00AC1:      		rm[I1++]=	AR
00AC2:      		rm[I1]=		AR
            
            	; __md2ReleaseOccupy();
00AC3:      		call		__md2ReleaseOccupy
            
            	; mp.occupyopr = 0;
00AC4:      		AR=		0
00AC5:      		rm[mp_occupyopr]=AR
            
00AC6:      	rets
            ; }
            
            
            ; ---------------------------------------------------------------------------
            
            __md2ReleaseOccupy:
            ; {
            	; mask = 1;
00AC7:      		AX=		0
00AC8:      		BX=		1
            
            	; for(i = 0; i < mp.occupyopr & 0x7FFF; i++)
00AC9:      		CX=		rm[mp_occupyopr]
00ACA:      		clr		CX.b15
00ACB:      		I0=		mp
00ACD:      		jmp		@md2roc_label_1555
            	@md2roc_loop_1552:
            	; {
            		; mp[i].RR = 64;
00ACE:      			AR=		MC_RR
00ACF:      			AR=		AR + I0
00AD0:      			I1=		AR
00AD1:      			AR=		64
00AD2:      			rm[I1]=		AR
            
            		; mp.ReleaseCh |= mask;
00AD3:      			I1=		mp@ReleaseCh_l
00AD5:      			AR=		rm[I1]
00AD6:      			rm[I1++]=	AR | BX
00AD7:      			AR=		rm[I1]
00AD8:      			rm[I1]=		AR | AX
            
            		; mask <<= 1;
00AD9:      			slz		BX, 1
00ADA:      			slc		AX, 1
00ADB:      			AR=		MC_SIZEOF
00ADC:      			I0=		I0 + AR
            
            	@md2roc_label_1555:
00ADD:      		loop		@md2roc_loop_1552
            	; }
            
00ADE:      	rets
            ; }
            
            
            
            
            ; -------------------------------------------------------------------
            
            md2StartOkon:
            ; {
            	; if(md2ChkSongEnd())
00ADF:      		PCH=		md2ChkSongEnd
00AE0:      		lcall		md2ChkSongEnd
00AE1:      		if NZ jmp	@md2roc_label_1548
            	; {
            		; return;
00AE2:      			rets
            	; }
            	@md2roc_label_1548:
            
            
            	; __md2ReleaseOccupy();
00AE3:      		call		__md2ReleaseOccupy
            
            	; mp.okmask = 1;
00AE4:      		AR=		1
00AE5:      		I1=		mp@okmask
00AE7:      		rm[I1]=		AR
            
            	; if((mp.lop - 2) < mp.occupyopr)
00AE8:      		AR=		rm[mp@lop]
00AE9:      		AX=		rm[mp@occupyopr]
00AEA:      		clr		AX.b15
00AEB:      		AR=		AR - 2
00AEC:      		SF=		AR - AX
00AED:      		if GE jmp	@md2sokon_label_1345
            	; {
            		; mp.occupyopr = mp.lop - 2;
00AEE:      			rm[mp@occupyopr]=AR
            	; }
            	@md2sokon_label_1345:
            
00AEF:      	rets
            ; }
            
            
            ; -------------------------------------------------------------------
            
            md2LeaveOkon:
            ; {
            	; if(mp.ofsevent)
00AF0:      		I1=		mp@ofsevent_l
00AF2:      		AX=		rm[I1++]
00AF3:      		AR=		rm[I1--]
00AF4:      		AR=		AR | AX
00AF5:      		if ZR jmp	@md2lok_label_1454
            	; {
            		; mp.note = mp.ofsevent;
            			; AX=		rm[I1++]
            			; AR=		rm[I1]
            			; I1=		mp@note_l
            			; rm[I1++]=	AX
            			; rm[I1]=		AR
            
            		; mp.ofsevent = 0;
00AF6:      			I1=		mp@ofsevent_l
00AF8:      			AR=		0
00AF9:      			rm[I1++]=	AR
00AFA:      			rm[I1]=		AR
            
            
            		; mp.BaseTimer = 1;
00AFB:      			I1=		mp@BaseTimer
00AFD:      			AR=		1
00AFE:      			rm[I1]=		AR
            	; }
            	@md2lok_label_1454:
            
            	; mp.okmask = 0;
00AFF:      		AR=		0
00B00:      		I1=		mp@okmask
00B02:      		rm[I1]=		AR
            
00B03:      	rets
            ; }
            
            
            
            
            
            
            ; ~.~------------------------------------------------------------
            ; bool md2ChkSongEnd(void)
            ;
            ; in:
            ;    none
            ;
            ; out:
            ;    Z			- true
            ;    NZ			- false
            ;
            ; affect registers:
            ;    All
            ;
            ; meaning registers:
            ;
            ;
            ; special request:
            ;   none
            ;
            ; -------------------------------------------------------------
            md2ChkSongEnd:
            ; {
            	; if(mp.note == 0)
00B04:      		I1=		mp@note_l
00B06:      		AR=		rm[I1++]
00B07:      		AX=		rm[I1]
00B08:      		AR=		AR | AX
            	; {
            		; return true;
            	; }
            
            	; return false;
00B09:      		rets
            ; }
            
            
            ; ---------------------------------------------------
            ; I0 -- pch
            ; R2 -- FLTP
            ; P1    must safe to use
            
            __sub_md2Pitch:
            ; {
            	; if(mp.pitch)
00B0A:      		AR=		rm[mp@pitch]
00B0B:      		if ZR jmp	@submd2p_label_1632
            	; {
            		; ~~ P1 is safe to use
            
            		; temp = (FLTP == 0) ? 0x8000 : FLTP;
00B0C:      			AR=		R2		; FLTP
00B0D:      			if NZ jmp	@md2si_label_1509
00B0E:      			set		AR.b15
            		@md2si_label_1509:
00B0F:      			MX=		AR
            
            		; nFLTP = (temp * md2shift_table[mp.pitch]) / 16384;
00B10:      			P1=		#@md2shift_table
00B13:      			AR=		rm[mp@pitch]
00B14:      			P1=		P1 + AR
00B15:      			AR=		pm[P1]
            		#ifdef _MSPEECHDSP_
            			MULUU
            		#else
00B16:      			MACOP=		3
00B17:      			MR=		MX * AR
00B18:      			MACOP=		0
            		#endif
00B19:      			slz		MR0, 2
00B1A:      			slc		MR1, 2
            
            		; if(nFLTP >= 0x8000)
00B1B:      			if AC jmp	@md2si_label_1556
00B1C:      			test		MR1.b15
00B1D:      			if ZR jmp	@md2si_label_1513
            		@md2si_label_1556:
            		; {
            			; nFLTP = nFLTP >> 1;
00B1E:      				clr		C
00B1F:      				src		MR1, 1
            
            			; pch->skipre <<= 1;
00B20:      				I1=		MC_SAMPLE_SKIPRE
00B21:      				AR=		I0
00B22:      				I1=		I1 + AR
00B23:      				AR=		rm[I1]
00B24:      				slz		AR, 1
00B25:      				rm[I1--]=	AR		; ~~ SKIPRE
            
            			; pch->skip = pch->skipre;
00B26:      				rm[I1]=		AR		; ~~ SKIP
            
            		; }
            		@md2si_label_1513:
            
            		; pch->FLTP = nFLTP;
00B27:      			I1=		MC_FLTP
00B28:      			AR=		I0
00B29:      			I1=		I1 + AR
00B2A:      			AR=		MR1
00B2B:      			rm[I1++]=	AR
            	; }
            	@submd2p_label_1632:
            
00B2C:      	rets
            ; }
            
            
            
            ; ----------------------------------
            ;    AX (BX)    - index
            ;    DX         - FLTG
            ;    CX         - i
            ;    R1:R0      - mask
            ;    R2         - FLTP
            ;    R3         - INS
            ;    I0         - pch
            ; ----------------------------------
            __sub_md2PlayNote:
            ; {
            	; ~~ get note info
            
            	; spiContReadStart(mp->keymap + (index * 4), &mp->md2);
00B2D:      		AR=		AX
00B2E:      		BX=		AR
00B2F:      		clr		AX.b15
00B30:      		I1=		mp@keymap
00B32:      		slz		AX, 2
00B33:      		AR=		rm[I1++]
00B34:      		AX=		AX + AR
00B35:      		AR=		rm[I1]
00B36:      		AR=		AR + 0 + C
00B37:      		push		AR
00B38:      		push		AX
00B39:      		AR=		BP
00B3A:      		AR=		AR + 2
00B3B:      		I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00B3C:      AR= rm[I1 -- ] 
00B3D:      P1 = rm[I1] 
00B3E:      sra AR 1 
00B3F:      src P1 1 
00B40:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
00B41:      		pop		AR
00B42:      		pop		AR
            
            	; INS = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00B43:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00B44:      		R3=		AR
            
            	; FLTP = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00B45:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00B46:      		R2=		AR
            
            	; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00B47:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            
            __sub_md2PlayNote_nomap:
            
            	; ~~ clear FIFO
            
            	; memset(pch->FLTI, 0, sizeof(pch->FLTI));
00B48:      		I1=		MC_FLTI
00B49:      		AR=		I0
00B4A:      		I1=		I1 + AR
00B4B:      		AR=		0
00B4C:      		rm[I1++]=	AR
00B4D:      		rm[I1++]=	AR
00B4E:      		rm[I1++]=	AR
00B4F:      		rm[I1++]=	AR
            
            
            	; if(INS < 0 || FLTP < 0)
00B50:      		AR=		R2
00B51:      		AR=		AR | R3
00B52:      		if AN jmp	@__md2pn_label_1435
            	; {
            		; return false;
            	; }
            
            
            	; ~.~-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            
            	; BX = INS & 0x0FFF;
00B53:      		AR=		R3
00B54:      		clr		R3.b13
00B55:      		clr		R3.b12
00B56:      		slc		AR, 2
00B57:      		slc		AR, 2
            
            	; CX = (INS & 0x3000) >> 12;
00B58:      		P1=		#md2ScaleTable	; code
00B5B:      		AR=		0
00B5C:      		slc		AR, 2
00B5D:      		P1=		P1 + AR
            
            	; mp.skip = 1 << CX;
00B5E:      		I1=		MC_SAMPLE_SKIP
00B5F:      		AR=		I0
00B60:      		I1=		I1 + AR
00B61:      		rm[I1++]=	pm[P1]
            
            	; mp.skipre = mp.skip;
00B62:      		rm[I1]=		pm[P1]
            
            
            	; pch->FLTP = FLTP;
00B63:      		I1=		MC_FLTP
00B64:      		AR=		I0
00B65:      		I1=		I1 + AR
00B66:      		rm[I1++]=	R2
            
            
            	; __sub_md2Pitch();
00B67:      		call		__sub_md2Pitch
            
            	; mp.ch[i].FLTG = DX;
            		; ~~ offset aware
00B68:      		rm[I1]=		DX
            
            
            	; BX.U = BX.U * mp->SizeInsIndex;
00B69:      		MX=		18
00B6A:      		AR=		R3
            	#ifdef _MSPEECHDSP_
            		MULSS
            	#else
00B6B:      		MACOP=		0
00B6C:      		MR=		MX * AR
            	#endif
            
            
            	; ~~ get entry & ADSR info
            
            	; temp = (mp.insbase + BX.U);
00B6D:      		I1=		mp@insbase_l
00B6F:      		AR=		rm[I1++]
00B70:      		MR0=		MR0 + AR
00B71:      		AR=		rm[I1]
00B72:      		AR=		AR + MR1 + C
00B73:      		push		AR
00B74:      		push		MR0
            
            	; sfContReadStart(HIADR(&temp));
00B75:      		AR=		BP
00B76:      		AR=		AR + 2
00B77:      		I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00B78:      AR= rm[I1 -- ] 
00B79:      P1 = rm[I1] 
00B7A:      sra AR 1 
00B7B:      src P1 1 
00B7C:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
00B7D:      		pop		AR
00B7E:      		pop		AR
            
            
            	; BX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00B7F:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00B80:      		DX=		AR
            
            	; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00B81:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00B82:      		AX=		AR
            
            	; pch->insadr = mp.baseadr + ((unsigned long)AX << 16) | (unsigned long)BX;
00B83:      		I1=		mp_baseadr_l
00B84:      		R2=		rm[I1++]
00B85:      		R3=		rm[I1]
00B86:      		I1=		MC_INSADR_L
00B87:      		AR=		I0
00B88:      		I1=		AR + I1
00B89:      		AR=		R2
00B8A:      		rm[I1++]=	AR + DX
00B8B:      		AR=		R3
00B8C:      		rm[I1]=		AR + AX + C
            
            
            	; ~~ read ADSR parameters
            
            
            	; pch->ADSR.VOL = SPI_DAT;
00B8D:      		I1=		MC_ADSR_VOL
00B8E:      		AR=		I0
00B8F:      		I1=		I1 + AR
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00B90:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00B91:      		rm[I1++]=	AR
            
            	; pch->ADSR.lpAttack = SPI_DAT;
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00B92:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00B93:      		rm[I1++]=	AR
            
            	; pch->ADSR.sAttack = SPI_DAT;
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00B94:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00B95:      		rm[I1++]=	AR
            
            	; pch->ADSR.lpDecay = SPI_DAT;
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00B96:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00B97:      		rm[I1++]=	AR
            
            
            	; pch->ADSR.sDecay = SPI_DAT;
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00B98:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00B99:      		rm[I1++]=	AR
            
            	; pch->ADSR.lpSustain = SPI_DAT;
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00B9A:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00B9B:      		rm[I1++]=	AR
            
            	; pch->ADSR.sSustain = SPI_DAT;
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00B9C:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00B9D:      		rm[I1++]=	AR
            
            	; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00B9E:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            
            	; ~~ loop address
            
            
            	; sfContReadStart(HIADR(&pch->insadr));
00B9F:      		I1=		MC_INSADR_H
00BA0:      		AR=		I0
00BA1:      		I1=		AR + I1
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00BA2:      AR= rm[I1 -- ] 
00BA3:      P1 = rm[I1] 
00BA4:      sra AR 1 
00BA5:      src P1 1 
00BA6:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            	; BX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00BA7:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00BA8:      		DX=		AR	; ~~ loop address
            
            	; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00BA9:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00BAA:      		AX=		AR
            
            	; ~~ loop address
            
            	; if(mp.flags.ADPCM)
00BAB:      		I1=		mp@flags
00BAD:      		AR=		rm[I1]
00BAE:      		test		AR.b5
00BAF:      		if NZ jmp	@__md2pn_label_1017
00BB0:      		test		AR.b3
00BB1:      		if ZR jmp	@__md2pn_label_1411
            	@__md2pn_label_1017:
            	; {
            		; ~~ ADPCM uses byte address to indicate odd frame
            
            		; pch->insloop = mp.baseadr + (BX | (AX << 16));
00BB2:      			I1=		mp_baseadr_l
00BB3:      			R2=		rm[I1++]
00BB4:      			R3=		rm[I1]
00BB5:      			I1=		MC_INSLOOP_L
00BB6:      			AR=		I0
00BB7:      			I1=		I1 + AR
00BB8:      			AR=		R2
00BB9:      			rm[I1++]=	AR + DX
00BBA:      			AR=		R3
00BBB:      			rm[I1]=		AR + AX + C
            
            		; pch->TASPAD.HD = 0;
00BBC:      			I1=		MC_ADPCM_HD
00BBD:      			AR=		I0
00BBE:      			I1=		I1 + AR
00BBF:      			AR=		0
00BC0:      			rm[I1++]=	AR
            
            		; pch->TASPAD.S0 = 0;
00BC1:      			rm[I1++]=	AR
            
            		; pch->TASPAD.S1 = 0;
00BC2:      			rm[I1++]=	AR
            
            		; pch->TASPAD.CNT = 0;
00BC3:      			rm[I1++]=	AR
            
            
            		; spiContReadStart(pch->insadr, &mp->md2);
            			; ~~ optimize out
            
            		; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00BC4:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            		; pch->TASPAD.BUF = AX.S;
00BC5:      			rm[I1++]=	AR
            
            		; spiContReadStop();
            			; mSfContReadStop	; ~~ optimize out
            
            		; pch->insadr += 6;	; ~~ skip loop point + first word data
00BC6:      			I1=		MC_INSADR_L
00BC7:      			AR=		I0
00BC8:      			I1=		I1 + AR
00BC9:      			AR=		rm[I1]
00BCA:      			AR=		AR + 6
00BCB:      			rm[I1++]=	AR
00BCC:      			AR=		rm[I1]
00BCD:      			AR=		AR + 0 + C
00BCE:      			rm[I1]=		AR
            
00BCF:      		jmp		@__md2pn_label_1411_1
            	; }
            	; else
            	@__md2pn_label_1411:
            	; {
            		; ~~ PCM uses word address
            
            		; pch->insloop = mp.baseadr + (AX | (BX << 16));
00BD0:      			I1=		mp_baseadr_l
00BD1:      			R2=		rm[I1++]
00BD2:      			R3=		rm[I1]
00BD3:      			I1=		MC_INSLOOP_L
00BD4:      			AR=		I0
00BD5:      			I1=		I1 + AR
00BD6:      			AR=		R2
00BD7:      			rm[I1++]=	AR + DX
00BD8:      			AR=		R3
00BD9:      			rm[I1]=		AR + AX + C
            
            		; pch->insadr += 4;		// skip loop point
00BDA:      			I1=		MC_INSADR_L
00BDB:      			AR=		I0
00BDC:      			I1=		I1 + AR
00BDD:      			AR=		rm[I1]
00BDE:      			AR=		AR + 4
00BDF:      			rm[I1++]=	AR
00BE0:      			AR=		rm[I1]
00BE1:      			AR=		AR + 0 + C
00BE2:      			rm[I1]=		AR
            	; }
            	@__md2pn_label_1411_1:
            
            
            	; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00BE3:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            
            	; mp.PlayChannel |= mask;
00BE4:      		I1=		mp@PlayChannel_l
00BE6:      		AR=		rm[I1]
00BE7:      		AR=		AR | R0
00BE8:      		rm[I1++]=	AR
00BE9:      		AR=		rm[I1]
00BEA:      		AR=		AR | R1
00BEB:      		rm[I1]=		AR
            
            	; mp.ReleaseCh &= ~mask;
00BEC:      		I1=		mp@ReleaseCh_l
00BEE:      		AR=		-1
00BEF:      		R0=		R0 ^ AR
00BF0:      		R1=		R1 ^ AR
00BF1:      		AR=		rm[I1]
00BF2:      		AR=		AR & R0
00BF3:      		rm[I1++]=	AR
00BF4:      		AR=		rm[I1]
00BF5:      		AR=		AR & R1
00BF6:      		rm[I1]=		AR
            
            	; mp.keych[i] = index;
00BF7:      		AR=		rm[mp_occupyopr]
00BF8:      		clr		AR.b15
00BF9:      		AR=		AR + CX
00BFA:      		I1=		mp@keych
00BFC:      		I1=		I1 + AR
00BFD:      		rm[I1]=		BX
            
00BFE:      	set		Z
00BFF:      	rets
            
            
            @__md2pn_label_1435:
00C00:      	clr		Z
00C01:      	rets
            ; }
            
            
            __md2SetLopBit:
            ; {
00C02:      	P1=		#md2ScaleTable
00C05:      	AR=		rm[mp_lop]
00C06:      	SF=		AR - 16
00C07:      	if AN jmp	@md2pn_label_1555
00C08:      	AR=		AR - 16
00C09:      	R0=		0
00C0A:      	P1=		P1 + AR
00C0B:      	AR=		pm[P1]
00C0C:      	R1=		AR
00C0D:      	rets
            @md2pn_label_1555:
00C0E:      	R1=		0
00C0F:      	P1=		P1 + AR
00C10:      	AR=		pm[P1]
00C11:      	R0=		AR
            @md2pn_label_1555_1:
00C12:      	rets
            ;}
            
            
            
            __md2SetLopBase:
            ; {
00C13:      	MX=		MC_SIZEOF
00C14:      	AR=		rm[mp_lop]
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
00C15:      	MR=		MX * AR
            #endif
00C16:      	AR=		mp@ch0@insloop_l
00C18:      	AR=		AR + MR0
00C19:      	I0=		AR
00C1A:      	rets
            ; }
            
            
            
            __md2GetFreeOp:
            ; {
            	; mask = 0x00000080;		// bit 7
00C1B:      		call		__md2SetLopBit
            
            	; for(i = 7; i > mp_occupyopr & 0x7FFF; i--)
00C1C:      		call		__md2SetLopBase
00C1D:      		AR=		rm[mp_occupyopr]
00C1E:      		clr		AR.b15
00C1F:      		CX=		rm[mp_lop]
00C20:      		CX=		CX - AR
00C21:      		if AN jmp	@md2pn_label_1747
            	@md2pn_loop_1800:
            	; {
            		; if(mp.PlayChannel & mask)
00C22:      			I1=		mp@PlayChannel_h
00C24:      			AR=		rm[I1--]
00C25:      			AR=		AR & R1
00C26:      			BX=		AR
00C27:      			AR=		rm[I1]
00C28:      			AR=		AR & R0
00C29:      			AR=		AR | BX
00C2A:      			if NZ jmp	@md2pn_label_1803_1
            		@md2pn_label_1803:
            		; {
            			; return true;
00C2B:      				set		Z
00C2C:      				rets
            		; }
            		@md2pn_label_1803_1:
            
            		; mask >>= 1;
00C2D:      			sra		R1, 1
00C2E:      			src		R0, 1
00C2F:      			AR=		MC_SIZEOF
00C30:      			I0=		I0 - AR
            
            	@md2pn_loop_1800_1:
00C31:      		loop		@md2pn_loop_1800
            	; }
            	@md2pn_label_1747:
            
            	; return false;
00C32:      		clr		Z
00C33:      		rets
            ; }
            
            ; ~~
            
            __md2GetRecycleOp:
            ; {
            	; mask = 0x00080000;		// bit 19
00C34:      		call		__md2SetLopBit
            
            	; for(i = 19; i > mp@occupyopr & 0x7FFF; i--)
00C35:      		call		__md2SetLopBase
00C36:      		AR=		rm[mp@occupyopr]
00C37:      		clr		AR.b15
00C38:      		CX=		rm[mp_lop]
00C39:      		CX=		CX - AR
00C3A:      		if AN jmp	@md2gro_label_1747
            	@md2gro_loop_1800:
            	; {
            		; if(mp.ReleaseCh & mask)
00C3B:      			I1=		mp@ReleaseCh_h
00C3D:      			AR=		rm[I1--]
00C3E:      			AR=		AR & R1
00C3F:      			BX=		AR
00C40:      			AR=		rm[I1]
00C41:      			AR=		AR & R0
00C42:      			AR=		AR | BX
00C43:      			if ZR jmp	@md2gro_label_1803_1
            		@md2gro_label_1803:
            		; {
            			; AR=		-1
            			; R0=		R0 ^ AR
            			; R1=		R1 ^ AR
            
            			; I1=		mp@PlayChannel_h
            			; AR=		rm[I1]
            			; AR=		AR & R1
            			; rm[I1--]=	AR
            			; AR=		rm[I1]
            			; AR=		AR & R0
            			; rm[I1]=		AR
            
            			; return true;
00C44:      				set		Z
00C45:      				rets
            		; }
            		@md2gro_label_1803_1:
            
            
            		; mask >>= 1;
00C46:      			sra		R1, 1
00C47:      			src		R0, 1
00C48:      			AR=		MC_SIZEOF
00C49:      			I0=		I0 - AR
            
            	@md2gro_loop_1800_1:
00C4A:      		loop		@md2gro_loop_1800
            	; }
            	@md2gro_label_1747:
            
            
00C4B:      		call		__md2SetLopBit
00C4C:      		call		__md2SetLopBase
            
00C4D:      		set		Z
00C4E:      		rets
            
            
            
            
            
            
            
            	; return false;
00C4F:      		clr		Z
00C50:      		rets
            ; }
            
            
            
            
            ; ~.~------------------------------------------------------------
            ; bool md2PlayNote(short index, short FLTG)
            ;
            ; in:
            ;    AX			- index
            ;    DX                 - FLTG
            ;
            ; out:
            ;    Z			- true
            ;    NZ			- false
            ;
            ;
            ; affect registers:
            ;    All
            ;
            ; meaning registers:
            ;    R1:R0	- mask
            ;
            ;
            ; special request:
            ;   none
            ;
            ; -------------------------------------------------------------
            md2PlayNote:
            ; {
            	; if(!mp.flags.INSBank)
00C51:      		I1=		mp@flags
00C53:      		AR=		rm[I1]
00C54:      		test		AR.b2
00C55:      		if NZ jmp	@md2pn_label_1746
            	; {
            		; return false;
00C56:      			clr		Z
00C57:      			rets
            	; }
            	@md2pn_label_1746:
            
            
            	; if(__md2GetFreeOp())
00C58:      		call		__md2GetFreeOp
00C59:      		if NZ jmp	@md2pn_label_1743
            	; {
            
            		; __sub_md2PlayNote();
00C5A:      			call		__sub_md2PlayNote
            
            		; return true;
00C5B:      			set		Z
00C5C:      			rets
            	; }
            	; else
            	@md2pn_label_1743:
            	; {
            		; if(__md2GetRecycleOp())
00C5D:      			call		__md2GetRecycleOp
00C5E:      			if NZ jmp	@md2pn_label_1743_1
            		; {
            			; __sub_md2PlayNote();
00C5F:      				call		__sub_md2PlayNote
            
            			; return true;
00C60:      				set		Z
00C61:      				rets
            		; }
            	; }
            	@md2pn_label_1743_1:
            
            
            	; return false;
00C62:      		clr		Z
00C63:      		rets
            ; }
            
            
            ; ~.~------------------------------------------------------------
            ; bool md2PlayPercNote(short index)
            ;
            ; in:
            ;    AX			- index
            ;    DX                 - FLTG
            ;
            ; out:
            ;    Z			- true
            ;    NZ			- false
            ;
            ;
            ; affect registers:
            ;    All
            ;
            ; meaning registers:
            ;    R1:R0	- mask
            ;
            ;
            ; special request:
            ;   none
            ;
            ; -------------------------------------------------------------
            md2PlayPercNote:
            ; {
            	; if(!mp.flags.INSBank)
00C64:      		I1=		mp@flags
00C66:      		AR=		rm[I1]
00C67:      		test		AR.b2
00C68:      		if NZ jmp	@md2perc_label_1746
            	; {
            		; return false;
00C69:      			clr		Z
00C6A:      			rets
            	; }
            	@md2perc_label_1746:
            
            
            	; if(__md2GetFreeOp())
00C6B:      		call		__md2GetFreeOp
00C6C:      		if NZ jmp	@md2ppn_label_1743
            	; {
            		; temp = mp.keymap;
00C6D:      			I1=		mp@keymap
00C6F:      			AR=		rm[I1++]
00C70:      			push		AR
00C71:      			AR=		rm[I1]
00C72:      			push		AR
            
            		; ~~ perc table address ..... danger
            
            		; mp.keymap = mp.insbase - 512;
00C73:      			I1=		mp@insbase_l
00C75:      			BX=		rm[I1++]
00C76:      			AR=		0x0204
00C78:      			BX=		BX - AR
00C79:      			AR=		rm[I1]
00C7A:      			AR=		AR - 0 + C - 1
00C7B:      			I1=		mp@keymap
00C7D:      			rm[I1++]=	BX
00C7E:      			rm[I1]=		AR
            
            		; __sub_md2PlayNote();
00C7F:      			set		AX.b15
00C80:      			call		__sub_md2PlayNote
            
            
            		; temp = mp.keymap;
00C81:      			I1=		mp@keymap_h
00C83:      			pop		AR
00C84:      			rm[I1--]=	AR
00C85:      			pop		AR
00C86:      			rm[I1]=		AR
            
            		; return true;
00C87:      			set		Z
00C88:      			rets
            	; }
            	@md2ppn_label_1743:
            
            
            	; return false;
00C89:      		clr		Z
00C8A:      		rets
            ; }
            
            ; ~~
            
            
            ; ~.~------------------------------------------------------------
            ; bool md2ReleaseNote(short index, short RR)
            ;
            ; in:
            ;    AX			- index
            ;    DX                 - RR
            ;
            ; out:
            ;    Z			- true
            ;    NZ			- false
            ;
            ; affect registers:
            ;    All
            ;
            ; meaning registers:
            ;    R1:R0	- mask
            ;
            ;
            ; special request:
            ;   none
            ;
            ; -------------------------------------------------------------
            
            md2ReleasePercNote:
00C8B:      	set		AX.b15
            md2ReleaseNote:
            ; {
            	; if(!mp.flags.INSBank)
00C8C:      		I1=		mp@flags
00C8E:      		AR=		rm[I1]
00C8F:      		test		AR.b2
00C90:      		if NZ jmp	@md2rn_label_1746
            	; {
            		; return false;
00C91:      			clr		Z
00C92:      			rets
            	; }
            	@md2rn_label_1746:
            
            md2ReleaseNote_okon:
            	; mask = 0x00080000;		// bit 7
00C93:      		call		__md2SetLopBit
            
            	; for(i = 19; i < mp@occupyopr & 0x7FFF; i--)
00C94:      		call		__md2SetLopBase
00C95:      		CX=		rm[mp@occupyopr]
00C96:      		clr		CX.b15
00C97:      		AR=		rm[mp_lop]
00C98:      		CX=		AR - CX
00C99:      		I1=		mp@keych
00C9B:      		I1=		I1 + AR
            	@md2rn_loop_1800:
            	; {
            		; if(mp.keych[i] == index)
00C9C:      			AR=		rm[I1]
00C9D:      			SF=		AR - AX
00C9E:      			if NZ jmp	@md2rn_label_1913
            		; {
            			; mp.keych[i] = -1;
00C9F:      				AR=		-1
00CA0:      				rm[I1]=		AR
            
            			; mp.ch[i].RR = 64;
00CA1:      				AR=		MC_RR
00CA2:      				AR=		AR + I0
00CA3:      				I1=		AR
00CA4:      				rm[I1]=		DX
            
            			; mp.ReleaseCh |= mask;
00CA5:      				I1=		mp@ReleaseCh_l
00CA7:      				AR=		rm[I1]
00CA8:      				AR=		AR | R0
00CA9:      				rm[I1++]=	AR
00CAA:      				AR=		rm[I1]
00CAB:      				AR=		AR | R1
00CAC:      				rm[I1++]=	AR
            
            			; return true;
00CAD:      				set		Z
00CAE:      				rets
            		; }
            		@md2rn_label_1913:
            
            		; mask >>= 1;
00CAF:      			sra		R1, 1
00CB0:      			src		R0, 1
00CB1:      			AR=		MC_SIZEOF
00CB2:      			I0=		I0 - AR
00CB3:      			I1--
            
            	@md2rn_loop_1800_1:
00CB4:      		loop		@md2rn_loop_1800
            
            	; }
            
            	; return false;
00CB5:      		clr		Z
00CB6:      		rets
            ; }
            
            
            ; ----
            
            md2Reset:
            ; {
            	; memset(mp.ch, 0, sizeof(mp.ch));
00CB7:      		CX=		mp@insbase_l
00CB9:      		AR=		mp
00CBB:      		CX=		CX - AR
00CBC:      		CX--
00CBD:      		I1=		mp
00CBF:      		AR=		0
            	@md2fme_loop_1700:
00CC0:      		rm[I1++]=	AR
00CC1:      		loop		@md2fme_loop_1700
            
            	; mp.note = 0;
00CC2:      		I1=		mp@note_l
00CC4:      		AR=		0
00CC5:      		rm[I1++]=	AR
00CC6:      		rm[I1++]=	AR
            	; mp.PlayInfo = 0;
00CC7:      		rm[I1++]=	AR
00CC8:      		rm[I1++]=	AR
            	; mp.PlayChannel = 0;
00CC9:      		rm[I1++]=	AR
00CCA:      		rm[I1++]=	AR
            	; mp.ReleaseInfo = 0;
00CCB:      		rm[I1++]=	AR
00CCC:      		rm[I1++]=	AR
            	; mp.ReleaseCh = 0;
00CCD:      		rm[I1++]=	AR
00CCE:      		rm[I1++]=	AR
            	; mp.BaseTimer = 1;
00CCF:      		AR=		1
00CD0:      		rm[I1++]=	AR
            	; mp.EventTimer = 0x0FFF;
00CD1:      		AR=		0x0FFF
00CD3:      		rm[I1++]=	AR
            	; mp.tempo = 0x4000;
00CD4:      		AR=		0x4000
00CD6:      		I1=		mp_tempo
00CD7:      		rm[I1]=		AR
            
            	; for(i = 0; i < 8; i++)
00CD8:      		CX=		7
00CD9:      		I1=		mp@keych
00CDB:      		AR=		-1
            	@md2fme_loop_1867:
            	; {
            		; mp.keych[i] = -1;
00CDC:      			rm[I1++]=	AR
            
00CDD:      		loop		@md2fme_loop_1867
            	; }
            
            	; for(i = 0; i < 8; i++)
00CDE:      		CX=		7
00CDF:      		I1=		mp
00CE1:      		AR=		MC_LEFT_VOL
00CE2:      		I1=		I1 + AR
            	@md2play_loop_1124:
            	; {
            		; mp[i].Stereo.L = 0x7FFF;
00CE3:      			AR=		0x7FFF
00CE5:      			rm[I1++]=	AR
            		; mp[i].Stereo.R = 0x7FFF;
00CE6:      			rm[I1--]=	AR
00CE7:      			AR=		MC_SIZEOF
00CE8:      			I1=		I1 + AR
00CE9:      			loop		@md2play_loop_1124
            	; }
            
            	; mp.lop = 3;			// 4 operators
00CEA:      		AR=		3
00CEB:      		rm[mp_lop]=	AR
            
            
            	; mp.inbuf = 0;
00CEC:      		AR=		mp@tinyrender
00CEE:      		rm[mp_inbuf]=	AR
            
            	; mp.outbuf = 0;
00CEF:      		rm[mp_outbuf]=	AR
            
            
            	; ~.~ add your codes
            
            
            	; ~~ turn all midi channel on
            
            	; mp.mchmask = 0xFFFF;
00CF0:      		I1=		mp@mchmask
00CF2:      		AR=		-1
00CF3:      		rm[I1]=		AR
            
            	; mp.okmask = 0;
00CF4:      		I1=		mp@okmask
00CF6:      		AR=		0
00CF7:      		rm[I1]=		AR
            
00CF8:      	rets
            ; }
            
            
            
            
            
            
            
            
            
            ; ~.~---------------------------------------------------
            ; void md2InitParameters(void)
            ;
            ; in:
            ;    none
            ;
            ; out:
            ;    none
            ;
            ; affect registers:
            ;
            ;
            ; meaning registers:
            ;
            ;
            ; special request:
            ;
            ;
            ; -------------------------------------------------------------
            md2InitParameters:
            ; {
            	; md2Reset();
00CF9:      		call		md2Reset
            
            	; mp.lop = 7;
00CFA:      		AR=		7
00CFB:      		rm[mp@lop]=	AR
            
            	; mp.pitch = 0;
00CFC:      		AR=		0
00CFD:      		rm[mp@pitch]=	AR
            
            	; MACOP = 0;
00CFE:      		MACOP=		0
            
            	; ~~ copy ramfunc to pram area
            
            #ifdef __RAMFUNC_ENABLE__
            
            	; memcpy((__code *)0x20000, __RAMFUNC_SEGMENT_START, (__RAMFUNC_SEGMENT_END - __RAMFUNC_SEGMENT_START));
            		AR=		#__RAMFUNC_SEGMENT_START
            		CX=		#__RAMFUNC_SEGMENT_END
            		P0=		AR
            		P0.hh=		0
            		P1=		MD2_PRAM_START_BASE
            		P1.hh=		RAMBANK
            		CX=		CX - AR
            		jmp		@md2fme_label_1606
            	@md2fme_loop_1606:
            		AR=		pm[P0++]
            		pm[P1++]=	AR
            	@md2fme_label_1606:
            		loop		@md2fme_loop_1606
            
            
            	#ifdef SOFTADPDEC
            		; ~~ copy OBJ
            
            			AR=		#NextSampleAdpcm
            			CX=		#__NextSampleAdpcmEnd
            			P0=		AR
            			P0.hh=		0
            			; ~~ copy to P1
            			CX=		CX - AR
            			jmp		@md2fme_label_1507
            		@md2fme_loop_1508:
            			AR=		pm[P0++]
            			pm[P1++]=	AR
            		@md2fme_label_1507:
            			loop		@md2fme_loop_1508
            	#endif
            
            
            	#ifdef MIDIPCMDEC
            		; ~~ copy OBJ
            
            			AR=		#NextSampleMidpcm
            			CX=		#__NextSampleMidpcmEnd
            			P0=		AR
            			P0.hh=		0
            			; ~~ copy to P1
            			CX=		CX - AR
            			jmp		@md2fme_label_0942_1
            		@md2fme_loop_0942:
            			AR=		pm[P0++]
            			pm[P1++]=	AR
            		@md2fme_label_0942_1:
            			loop		@md2fme_loop_0942
            	#endif
            
            		P1.hh=		0
            
            #endif
            
            
00CFF:      	rets
            ; }
            
            
            
            
            ; ~.~---------------------------------------------------
            ; void md2StartBGServe(void)
            ;
            ; in:
            ;    none
            ;
            ; out:
            ;    none
            ;
            ; affect registers:
            ;
            ;
            ; meaning registers:
            ;
            ;
            ; special request:
            ;
            ;
            ; -------------------------------------------------------------
            md2StartBGServe:
            ; {
            	; ClearIntReq(INT0);
00D00:      		clr		io[INTREQ].b0
            
            	; EnableInterrupt(INT0);
00D01:      		ena		INT0
            
            	; EnableInterrupts();
00D02:      		eni
            
00D03:      	rets
            ; }
            
            
            ; ~.~---------------------------------------------------
            ; void md2StopBGServe(void)
            ;
            ; in:
            ;    none
            ;
            ; out:
            ;    none
            ;
            ; affect registers:
            ;
            ;
            ; meaning registers:
            ;
            ;
            ; special request:
            ;
            ;
            ; -------------------------------------------------------------
            md2StopBGServe:
            ; {
            	; DisableInterrupt(INT0);
00D04:      		dsi		INT0
            
            	; ClearIntReq(INT0);
00D05:      		clr		io[INTREQ].b0
            
00D06:      	rets
            ; }
            
            
            ; ~.~-----------------------------------------------------
            ; void md2Initilize(void)
            ;
            ; in:
            ;    none
            ;
            ; out:
            ;    none
            ;
            ; affect registers:
            ;    AR, CX, I1
            ;
            ; meaning registers:
            ;    none
            ;
            ; special request:
            ;    none
            ;
            ; -------------------------------------------------------------
            md2Initilize:
            md2Initialize:
            ; {
            	; memset(&mp, 0, sizeof(mp));
00D07:      		AR=		mp
00D09:      		CX=		AR
00D0A:      		I1=		AR
00D0B:      		AR=		mp@EventTimer
00D0D:      		CX=		AR - CX
00D0E:      		AR=		0
            	@md2play_loop_1534:
00D0F:      		rm[I1++]=	AR
00D10:      		loop		@md2play_loop_1534
            
            
00D11:      	rets
            ; }
            
            ; ~.~---------------------------------------------------
            ; bool md2FindMidiEntry(unsigned long flashadr)
            ;
            ; in:
            ;    AX:BX		- flashadr
            ;
            ; out:
            ;
            ;
            ; affect registers:
            ;
            ;
            ; meaning registers:
            ;
            ;
            ; special request:
            ;
            ;
            ; -------------------------------------------------------------
            md2FindMidiEntry:
            ; {
            	; DSP16 AX, BX;
            	; short i;
            
            	; mp.baseadr = flashadr;
00D12:      		I1=		mp_baseadr_l
            	#ifdef MD2_WORD_ADR
00D13:      		slz		BX, 1
00D14:      		slc		AX, 1
            	#endif
00D15:      		rm[I1++]=	BX
00D16:      		rm[I1]=		AX
            
            	; mp.songhdr = flashadr;
00D17:      		I1=		mp@songhdr_l
00D19:      		rm[I1++]=	BX
00D1A:      		rm[I1]=		AX
            
            	; sfContReadStart(HIADR(&mp.baseadr));
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00D1B:      AR= rm[I1 -- ] 
00D1C:      P1 = rm[I1] 
00D1D:      sra AR 1 
00D1E:      src P1 1 
00D1F:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            
            	; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00D20:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00D21:      		AX=		AR
            
            
            	; BX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00D22:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00D23:      		push		AR
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00D24:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
00D25:      		pop		AR
            
            
            	; if((AX == 0x444D) && (BX == 0x2032))
00D26:      		BX=		0x2032
00D28:      		SF=		AR - BX
00D29:      		if NZ jmp	@md2fme_label_1437
00D2A:      		AR=		0x444D
00D2C:      		SF=		AR - AX
00D2D:      		if NZ jmp	@md2fme_label_1437
            	; {
            		; ~~ header
            
            		; ~~ ignore HeaderSize, Version.....
            
            
            		; ~~ offset aware ~~ mp_baseadr_l
            
            		; ~~ read Entry (old header)
            
            		; sfContReadStart(mp.baseadr + 10);		// entry
00D2E:      			BX=		10
00D2F:      			AR=		rm[I1++]
00D30:      			BX=		BX + AR
00D31:      			AR=		rm[I1]
00D32:      			AR=		AR + 0 + C
00D33:      			push		AR
00D34:      			push		BX
00D35:      			AR=		BP
00D36:      			AR=		AR + 2
00D37:      			I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00D38:      AR= rm[I1 -- ] 
00D39:      P1 = rm[I1] 
00D3A:      sra AR 1 
00D3B:      src P1 1 
00D3C:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
00D3D:      			pop		AR
00D3E:      			pop		AR
            
            		; ~~ Entry is 16-bit offset
            
            		; mp.insbase = mp.baseadr + sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00D3F:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00D40:      			BX=		rm[mp_baseadr_l]
00D41:      			I1=		mp@insbase_l
00D43:      			rm[I1++]=	AR + BX
00D44:      			BX=		rm[mp_baseadr_h]
00D45:      			AR=		0
00D46:      			rm[I1]=		AR + BX + C
            
            		; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00D47:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            		; ~~ read Flags
            
            		; sfContReadStart(mp.baseadr + 8);
00D48:      			BX=		rm[mp_baseadr_l]
00D49:      			AR=		8
00D4A:      			BX=		BX + AR
00D4B:      			AR=		rm[mp_baseadr_h]
00D4C:      			AR=		AR + 0 + C
00D4D:      			push		AR
00D4E:      			push		BX
00D4F:      			AR=		2
00D50:      			AR=		AR + BP
00D51:      			I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00D52:      AR= rm[I1 -- ] 
00D53:      P1 = rm[I1] 
00D54:      sra AR 1 
00D55:      src P1 1 
00D56:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
00D57:      			pop		AR
00D58:      			pop		AR
            
            		; mp.flags = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00D59:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00D5A:      			I1=		mp@flags
00D5C:      			rm[I1]=		AR
00D5D:      			BX=		AR
            
            		; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00D5E:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            		; if(mp.flags.INSBank)
00D5F:      			test		BX.b2
00D60:      			if ZR jmp	@md2fme_label_1532
            		; {
            			; mp.kmapbase = mp.baseadr + sizeof(MD2Header);
00D61:      				BX=		rm[mp_baseadr_l]
00D62:      				AR=		16
00D63:      				BX=		BX + AR
00D64:      				AR=		rm[mp_baseadr_h]
00D65:      				AR=		AR + 0 + C
00D66:      				I1=		mp@kmapbase_l
00D68:      				rm[I1++]=	BX
00D69:      				rm[I1]=		AR
            
            			; sfContReadStart(HIADR(&mp.kmapbase));
            				; ~~ offset aware ~~ mp@kmapbase_l
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00D6A:      AR= rm[I1 -- ] 
00D6B:      P1 = rm[I1] 
00D6C:      sra AR 1 
00D6D:      src P1 1 
00D6E:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            			; ~~ TotalINSBank
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00D6F:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00D70:      				rm[mp_tinsbank]=AR
            
            			; ~~ TotalSong
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00D71:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00D72:      				rm[mp_songcnt]=	AR
            
            			; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00D73:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            			; mp.kmapbase += sizeof(DSPChannelMap) + (int)(pDCM->TotalSong	- 1) * sizeof(short);
00D74:      				AR=		rm[mp_songcnt]
00D75:      				slz		AR, 1
00D76:      				AR=		AR + 4		; sizeof(DSPChannelMap)
00D77:      				I1=		mp@kmapbase_l
00D79:      				BX=		rm[I1]
00D7A:      				rm[I1++]=	AR + BX
00D7B:      				AR=		rm[I1]
00D7C:      				AR=		AR + 0 + C
00D7D:      				rm[I1]=		AR
            
            			; mp.keymap = mp.kmapbase;
00D7E:      				BX=		rm[I1]
00D7F:      				I1=		mp@keymap
00D81:      				rm[I1++]=	BX
00D82:      				rm[I1]=		AR
            		; }
            		@md2fme_label_1532:
            
            
            		; sfContReadStart(HIADR(&mp.insbase));
00D83:      			I1=		mp@insbase_h
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00D85:      AR= rm[I1 -- ] 
00D86:      P1 = rm[I1] 
00D87:      sra AR 1 
00D88:      src P1 1 
00D89:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
00D8A:      		jmp		@md2fme_label_1437_1
            	; }
            	; else
            	@md2fme_label_1437:
            	; {
            		; mp.flags = 0;
00D8B:      			AR=		0
00D8C:      			I1=		mp@flags
00D8E:      			rm[I1]=		AR
            
            		; mp.insbase = mp.baseadr;
00D8F:      			AR=		rm[mp_baseadr_l]
00D90:      			I1=		mp@insbase_l
00D92:      			rm[I1++]=	AR
00D93:      			AR=		rm[mp_baseadr_h]
00D94:      			rm[I1]=		AR
            
            		; sfContReadStart(HIADR(&mp.baseadr));
00D95:      			I1=		mp_baseadr_h
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00D96:      AR= rm[I1 -- ] 
00D97:      P1 = rm[I1] 
00D98:      sra AR 1 
00D99:      src P1 1 
00D9A:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            	; }
            	@md2fme_label_1437_1:
            
            
            	; ~~ only new V2
            
            	; sfContRead2Word();
            
            	; BX = SPI_DAT;
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00D9B:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00D9C:      		BX=		AR
            
            	; AX = SPI_DAT;
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00D9D:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00D9E:      		AX=		AR
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00D9F:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            
            	; if(AX.b15)
00DA0:      		test		AX.b15
00DA1:      		if ZR jmp	@md2fme_label_1603
            	; {
            		; AX.b15 = 0;
00DA2:      			clr		AX.b15
            
            		; mp.insbase += sizeof(long);
00DA3:      			I1=		mp@insbase_l
00DA5:      			AR=		rm[I1]
00DA6:      			AR=		AR + 4
00DA7:      			rm[I1++]=	AR
00DA8:      			AR=		rm[I1]
00DA9:      			AR=		AR + 0 + C
00DAA:      			rm[I1]=		AR
            
            		; mp.songhdr = ((unsigned long)AX.U << 16) | (unsigned long)BX.U;
00DAB:      			I1=		mp@songhdr_l
00DAD:      			AR=		rm[I1]
00DAE:      			rm[I1++]=	AR + BX
00DAF:      			AR=		rm[I1]
00DB0:      			rm[I1]=		AR + AX + C
            
00DB1:      		jmp		@md2fme_label_1605
            	; }
            	; else
            	@md2fme_label_1603:
            	; {
            		; return false;
00DB2:      			clr		Z
00DB3:      			rets
            	; }
            	@md2fme_label_1605:
            
            
            	; ~~ read song count
            
            
            	; sfContReadStart(HIADR(&mp.songhdr));
00DB4:      		I1=		mp@songhdr_h
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00DB6:      AR= rm[I1 -- ] 
00DB7:      P1 = rm[I1] 
00DB8:      sra AR 1 
00DB9:      src P1 1 
00DBA:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            	; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00DBB:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00DBC:      		AX=		AR
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00DBD:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; mp.songhdr += 2;
00DBE:      		I1=		mp@songhdr_l
00DC0:      		AR=		rm[I1]
00DC1:      		AR=		AR + 2
00DC2:      		rm[I1++]=	AR
00DC3:      		AR=		rm[I1]
00DC4:      		AR=		AR + 0 + C
00DC5:      		rm[I1]=		AR
            
            	; mp.songcnt = (unsigned long)AX.U;
00DC6:      		I1=		mp_songcnt
00DC7:      		rm[I1]=		AX
            
            	; return true;
00DC8:      		set		Z
00DC9:      		rets
            ; }
            
            
            ; +-++-+
            
            
            ; ~.~---------------------------------------------------------------
            ; bool md2DoEvent_okon(void)
            ;
            ; in:
            ;    none
            ;
            ; out:
            ;    Z		- true
            ;    NZ		- false
            ;
            ; affect registers:
            ;    AR, AX, BX, CX, DX, I0, I1, R0, R1, R2, R3
            ;
            ; meaning registers:
            ;
            ;
            ; special request:
            ;
            ;
            ; ------------------------------------------------------------------
            md2DoEvent_okon:
            ; {
            	; if(mp.note == 0)
00DCA:      		I1=		mp@note_l
00DCC:      		AR=		rm[I1++]
00DCD:      		AX=		rm[I1]
00DCE:      		AR=		AR | AX
00DCF:      		if NZ jmp	@md2deokon_label_1624
            	; {
            		; return false;
00DD0:      			clr		Z
00DD1:      			rets
            	; }
            	@md2deokon_label_1624:
            
            
            @md2deokon_loop_1841:
            	; mp.EventTimer = 0;
00DD2:      		I1=		mp@EventTimer
00DD4:      		AR=		0
00DD5:      		rm[I1]=		AR
            
            	; mp.ofsevent = mp.note;
00DD6:      		I1=		mp@note_l
00DD8:      		AR=		rm[I1++]
00DD9:      		AX=		rm[I1]
00DDA:      		I1=		mp@ofsevent_l
00DDC:      		rm[I1++]=	AR
00DDD:      		rm[I1]=		AX
            
            
            	; sfContReadStart(HIADR(&mp.note));
00DDE:      		I1=		mp@note_h
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00DE0:      AR= rm[I1 -- ] 
00DE1:      P1 = rm[I1] 
00DE2:      sra AR 1 
00DE3:      src P1 1 
00DE4:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            	; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00DE5:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00DE6:      		AX=		AR
            
            	; mp.extev = AX.N1;
00DE7:      		I1=		mp@extev
00DE9:      		sra		AR, 2
00DEA:      		sra		AR, 2
00DEB:      		AR=		AR & 0x0F
00DEC:      		rm[I1]=		AR
            
            	; if(mp.ExtEV & 0x08)
00DED:      		test		AR.b3
00DEE:      		if ZR jmp	@md2deokon_label_1157
            	; {
            		; ~~ control message
            
            		; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00DEF:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            		; mp.ctlev = vXCHG(AX);
00DF0:      			AR=		AX
00DF1:      			I1=		mp@ctlev
00DF3:      			xchg		AR
00DF4:      			rm[I1]=		AR
            
            		; mp->note += 2;
00DF5:      			I1=		mp@note_l
00DF7:      			AR=		rm[I1]
00DF8:      			AR=		AR + 2
00DF9:      			rm[I1++]=	AR
00DFA:      			AR=		rm[I1]
00DFB:      			AR=		AR + 0 + C
00DFC:      			rm[I1]=		AR
            
            		; return true;
00DFD:      			set		Z
00DFE:      			rets
            	; }
            	@md2deokon_label_1157:
            
            
            	; switch(mp.extev & 3)
00DFF:      		AR=		AR & 0x03
00E00:      		if ZR jmp	@md2deokon_caseT_case0
00E01:      		SF=		AR - 1
00E02:      		if EQ jmp	@md2deokon_caseT_case1
00E03:      		SF=		AR - 2
00E04:      		if EQ jmp	@md2deokon_caseT_case2
00E05:      		jmp		@md2deokon_caseT_case3
            	; {
            		; case 0:
            		@md2deokon_caseT_case0:
            		; {
            			; ~~ +------+------------------------+--------+
            			; ~~ |4-bit | event type = 0	     |	      |	   N1
            			; ~~ +------+------------------------+ byte 0 |	 L
            			; ~~ |4-bit | event timer high 4-bit |	      |	   N0
            			; ~~ +------|			     +--------+
            			; ~~ |8-bit |		  low 8-bit  | byte 1 |	 H
            			; ~~ +------+------------------------+--------+
            
            			; mp.EventTimer = ((unsigned short)AX.N0) << 8;
00E06:      				I1=		mp@EventTimer
00E08:      				AR=		0xFF0F
00E0A:      				AR=		AR & AX
00E0B:      				xchg		AR
            
            			; mp.EventTimer |= (unsigned short)AX.H;
00E0C:      				rm[I1]=		AR
            
            			; mp.note += 2;
00E0D:      				I1=		mp@note_l
00E0F:      				AR=		rm[I1]
00E10:      				AR=		AR + 2
00E11:      				rm[I1++]=	AR
00E12:      				AR=		rm[I1]
00E13:      				AR=		AR + 0 + C
00E14:      				rm[I1]=		AR
            
            			; break;
00E15:      				jmp		@md2deokon_label_1759
            		; }
            
            		; case 1:
            		@md2deokon_caseT_case1:
            		; {
            			; ~~ +------+-------------------------+--------+
            			; ~~ |4-bit | event type = 1	      |	       |    N1
            			; ~~ +------+-------------------------+ byte 0 |  L
            			; ~~ |4-bit | play channel [19:16]    |	       |    N0
            			; ~~ +------+-------------------------+--------+
            			; ~~ |4-bit | play channel [15:12]    |	       |    N3
            			; ~~ +------+-------------------------+ byte 1 |  H
            			; ~~ |4-bit | play channel [11:8]     |	       |    N2
            			; ~~ +------+-------------------------+--------+
            			; ~~ |8-bit | play channel [7:0]      | byte 2 |  L
            			; ~~ +------+-------------------------+--------+
            			; ~~ |8-bit | event timer	      | byte 3 |  H
            			; ~~ +------+-------------------------+--------+
            
            			; mp.PlayInfo = ((unsigned long)AX.N0) << 16;
00E16:      				I1=		mp@PlayInfo_h
00E18:      				AR=		0x0F
00E19:      				rm[I1--]=	AR & AX
            
            			; mp.PlayInfo |= ((unsigned long)AX.H) << 8;
00E1A:      				AR=		0xFF00
00E1C:      				AX=		AX & AR
            
            			; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00E1D:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00E1E:      				push		AR
            
            			; mp.PlayInfo |= ((unsigned long)AX.L);
00E1F:      				AH=		0
00E20:      				rm[I1]=		AR | AX
            
            			; mp.EventTimer = 0x0F00 | (unsigned short)AX.H;
00E21:      				pop		AR
00E22:      				xchg		AR
00E23:      				AH=		0x0F
00E24:      				I1=		mp@EventTimer
00E26:      				rm[I1]=		AR
            
            			; mp.note += 4;
00E27:      				I1=		mp@note_l
00E29:      				AR=		rm[I1]
00E2A:      				AR=		AR + 4
00E2B:      				rm[I1++]=	AR
00E2C:      				AR=		rm[I1]
00E2D:      				AR=		AR + 0 + C
00E2E:      				rm[I1]=		AR
            
            			; break;
00E2F:      				jmp		@md2deokon_label_1759
            		; }
            
            		; case 2:
            		@md2deokon_caseT_case2:
            		; {
            			; ~~ +------+-------------------------+--------+
            			; ~~ |4-bit | event type = 2	      |	       |    N1
            			; ~~ +------+-------------------------+ byte 0 |  L
            			; ~~ |4-bit | release channel [19:16] |	       |    N0
            			; ~~ +------+-------------------------+--------+
            			; ~~ |4-bit | release channel [15:12] |	       |    N3
            			; ~~ +------+-------------------------+ byte 1 |  H
            			; ~~ |4-bit | release channel [11:8]  |	       |    N2
            			; ~~ +------+-------------------------+--------+
            			; ~~ |8-bit | release channel [7:0]   | byte 2 |  L
            			; ~~ +------+-------------------------+--------+
            			; ~~ |8-bit |		 event timer  | byte 3 |  H
            			; ~~ +------+-------------------------+--------+
            
            			; mp.ReleaseInfo = ((unsigned long)AX.N0) << 16;
00E30:      				I1=		mp@ReleaseInfo_h
00E32:      				AR=		0x000F
00E33:      				rm[I1--]=	AR & AX
            
            			; mp.ReleaseInfo |= ((unsigned long)AX.H) << 8;
00E34:      				AR=		0xFF00
00E36:      				AX=		AX & AR
            
            			; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00E37:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00E38:      				push		AR
            
            			; mp.ReleaseInfo |= ((unsigned long)AX.L);
00E39:      				AH=		0
00E3A:      				rm[I1]=		AR | AX
            
            			; mp.EventTimer = 0x0F00 | (unsigned short)AX.H;
00E3B:      				pop		AR
00E3C:      				xchg		AR
00E3D:      				AH=		0x0F
00E3E:      				I1=		mp@EventTimer
00E40:      				rm[I1]=		AR
            
            			; mp.note += 4;
00E41:      				I1=		mp@note_l
00E43:      				AR=		rm[I1]
00E44:      				AR=		AR + 4
00E45:      				rm[I1++]=	AR
00E46:      				AR=		rm[I1]
00E47:      				AR=		AR + 0 + C
00E48:      				rm[I1]=		AR
            
            			; break;
00E49:      				jmp		@md2deokon_label_1759
            		; }
            
            		; case 3:
            		@md2deokon_caseT_case3:
            		; {
            			; ~~ +------+------------------------+--------+
            			; ~~ |4-bit | event type = 3	     |	      |	  N1
            			; ~~ +------+------------------------+ byte 0 | L
            			; ~~ |4-bit | play channel [19:16]   |	      |	  N0
            			; ~~ +------+------------------------+--------|
            			; ~~ |8-bit | play channel [15:8]    | byte 1 | H
            			; ~~ +------+------------------------+--------|
            			; ~~ |8-bit | play channel [7:0]     | byte 2 | L
            			; ~~ +------+------------------------+--------+
            			; ~~ |8-bit |release channel [19:12] | byte 3 | H
            			; ~~ +------+------------------------+--------|
            			; ~~ |8-bit |release channel [11:4]  | byte 4 | L
            			; ~~ +------+------------------------+--------+
            			; ~~ |4-bit |release channel [3:0]   |	      |	  N3
            			; ~~ +------+------------------------| byte 5 + H
            			; ~~ |4-bit | event timer	     |	      |	  N2
            			; ~~ +------+------------------------+--------+
            
            			; mp.PlayInfo = ((unsigned long)AX.N0) << 16;
00E4A:      				I1=		mp@PlayInfo_h
00E4C:      				AR=		0x000F
00E4D:      				rm[I1--]=	AR & AX
            
            			; mp.PlayInfo |= ((unsigned long)AX.H) << 8;
00E4E:      				AR=		0xFF00
00E50:      				AX=		AX & AR
            
            			; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00E51:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00E52:      				push		AR
            
            			; mp.PlayInfo |= ((unsigned long)AX.L);
00E53:      				AH=		0
00E54:      				rm[I1]=		AR | AX
            
            			; mp.ReleaseInfo = ((unsigned long)AX.H) << 12;
00E55:      				I1=		mp@ReleaseInfo_h
            
            			; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00E57:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00E58:      				xchg		AR
00E59:      				AX=		AR
00E5A:      				BX=		AR
            
            			; mp.ReleaseInfo |= ((unsigned long)AX.L) << 4;
00E5B:      				pop		AR
00E5C:      				xchg		AR
00E5D:      				AH=		0
00E5E:      				sra		AR, 2
00E5F:      				src		AX, 2
00E60:      				sra		AR, 2
00E61:      				src		AX, 2
00E62:      				rm[I1--]=	AR
            
            			; mp.ReleaseInfo |= ((unsigned long)AX.N3);
00E63:      				rm[I1]=		AX
            
            			; mp.EventTimer = 0x0FF0 | (unsigned short)AX.N2;
00E64:      				BX.h=		0
00E65:      				AR=		0x0FF0
00E67:      				I1=		mp@EventTimer
00E69:      				rm[I1]=		AR | BX
            
            			; mp.note += 6;
00E6A:      				I1=		mp@note_l
00E6C:      				AR=		rm[I1]
00E6D:      				AR=		AR + 6
00E6E:      				rm[I1++]=	AR
00E6F:      				AR=		rm[I1]
00E70:      				AR=		AR + 0 + C
00E71:      				rm[I1]=		AR
            
            			; break;
00E72:      				jmp		@md2deokon_label_1759
            		; }
            
            		; default:
            		@md2deokon_case_default:
            		; {
            			; Debug("Fatal: undefined event %d\n", AX.L & 0x0F);
            			; return false;
00E73:      				clr		Z
00E74:      				rets
            		; }
            	; }
            	@md2deokon_label_1759:
            
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00E75:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            
            	; if(mp.EventTimer == 0)
00E76:      		I1=		mp@EventTimer
00E78:      		AR=		rm[I1]
00E79:      		if NZ jmp	@md2deokon_label_1104
            	; {
            		; mp.note = 0;
00E7A:      			I1=		mp@note_l
00E7C:      			AR=		0
00E7D:      			rm[I1++]=	AR
00E7E:      			rm[I1]=		AR
            
            		; return false;
00E7F:      			clr		Z
00E80:      			rets
            	; }
            	@md2deokon_label_1104:
            
            
            	; ~~ processing release skip
            
            	; ~~ offset aware
            	;      mp.ReleaseInfo, mp.note,
            
            	; ~~ meaning registers:
            	; ------------------------------------
            	; ~~	 AX:BX = 1 << i
            	; ~~	 CX    = i
            	; ~~	 DX    = note count
            	; ~~	 R1:R0 = mp.ReleaseInfo
            	; ~~	 R2    = AX
            	; ~~	 I0    = pch (pch->RR)
            	; ~~	 I1    = mp.??
            
            	; if(mp.ReleaseInfo)
00E81:      		I1=		mp@ReleaseInfo_l
00E83:      		R0=		rm[I1++]
00E84:      		AR=		rm[I1]
00E85:      		AR=		AR | R0
00E86:      		if ZR jmp	@md2deokon_label_1705
00E87:      		R1=		rm[I1]
            	; {
            		; for(i = 0; (i < 20) && mp.ReleaseInfo; i++)
00E88:      			io[ClrWDT]=	AR
00E89:      			CX=		19
00E8A:      			DX=		0
            		@md2deokon_loop_1114:
00E8B:      			AR=		R0
00E8C:      			AR=		AR | R1
00E8D:      			if ZR jmp	@md2deokon_label_1114
            		; {
            			; if(mp->ReleaseInfo & 1)
00E8E:      				sra		R1, 1
00E8F:      				src		R0, 1
00E90:      				if NC jmp	@md2deokon_label_1117
            			; {
            				; mp->note += 2;
00E91:      					DX++
00E92:      					DX++
            			; }
            			@md2deokon_label_1117:
            
            
00E93:      			loop		@md2deokon_loop_1114
            		; }
            		@md2deokon_label_1114:
            			; ~~ write back --> mp.ReleaseInfo, mp.note
00E94:      			I1=		mp@ReleaseInfo_l
00E96:      			rm[I1++]=	R0
00E97:      			rm[I1]=		R1
00E98:      			I1=		mp@note_l
00E9A:      			AR=		rm[I1]
00E9B:      			rm[I1++]=	AR + DX
00E9C:      			AR=		rm[I1]
00E9D:      			AR=		AR + 0 + C
00E9E:      			rm[I1]=		AR
            
            		; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00E9F:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            		; Debug("release final %08X\n", (int)mp->note);
            	; }
            	@md2deokon_label_1705:
            
            
            	; ~~ still setting basetimer in okon mode
            
            	; mp.BaseTimer = (0x1000 - mp.EventTimer) * 8 * tempo;
00EA0:      		I1=		mp@EventTimer
00EA2:      		AR=		0x1000
00EA4:      		AX=		rm[I1]
00EA5:      		AX=		AR - AX
00EA6:      		slz		AX, 2
00EA7:      		slz		AX, 1
00EA8:      		I1=		mp_tempo
            
            ;;<<System message ======  Macro. mMULSS,4633,4638,PartA,PartB,,,,,,,,,,,,,,  strat ======
00EA9:      AR = rm[I1] 
00EAA:      MX = AR 
00EAB:      AR = AX 
00EAC:      MR = MX * AR 
            ;; System message>>====== Macro. mMULSS end ======
            
            	#ifdef _MSPEECHDSP_
            		AR=		MR0		; ~~ load answer and store
            		AX=		AR
            		AR=		MR1
            	#else
00EAD:      		AR=		MR0
00EAE:      		AX=		AR
00EAF:      		AR=		MR1
            	#endif
            
            		; ~~ --------------------
            
00EB0:      		slz		AX, 2
00EB1:      		slc		AR, 2
00EB2:      		I1=		mp@BaseTimer
00EB4:      		rm[I1]=		AR
            
            
            	; return true;
00EB5:      		set		Z
00EB6:      		rets
            ; }
            
            
            
            ; ~.~---------------------------------------------------------------
            ; void md2SetInstrument_okon(void)
            ;
            ; in:
            ;    none
            ;
            ; out:
            ;    none
            ;
            ;
            ; affect registers:
            ;    AR, AX, BX, CX, DX, I0, I1, R0, R1, R2, R3
            ;
            ; meaning registers:
            ;    CX		- i
            ;    DX		- next pch
            ;    BX		- pch
            ;    I1		- mp.??
            ;    R1:R0	- mp.PlayInfo
            ;    R2		- AX
            ;    R3		- BX
            ;
            ; special request:
            ;
            ;
            ; ------------------------------------------------------------------
            md2SetInstrument_okon:
            ; {
            	; md2Channel *pch;
            	; DSP16 AX, BX;
            	; int i, temp;
            
            	; if(mp.PlayInfo)
00EB7:      		I1=		mp@PlayInfo_l
00EB9:      		R0=		rm[I1++]
00EBA:      		AR=		rm[I1]
00EBB:      		AR=		AR | R0
00EBC:      		if ZR jmp	@md2siokon_label_1645
00EBD:      		R1=		rm[I1]
            	; {
            		; // Debug("\n");
            
            		; pch = mp;
00EBE:      			BX=		mp
            
            		; pokon = mp.okon;
00EC0:      			I0=		mp@okon
            
            		; sfContReadStart(HIADR(&mp.note));
00EC2:      			I1=		mp@note_h
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00EC4:      AR= rm[I1 -- ] 
00EC5:      P1 = rm[I1] 
00EC6:      sra AR 1 
00EC7:      src P1 1 
00EC8:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            		; ~~ offset aware
            		;	verify mp struct offset if modified.
            
            		; for(i = 0; (i < 20) && (mp.PlayInfo); i++)
00EC9:      			io[ClrWDT]=	AR
00ECA:      			CX=		19
            		@md2siokon_loop_1344:
00ECB:      			DX=		0
00ECC:      			AR=		R0
00ECD:      			AR=		AR | R1
00ECE:      			if ZR jmp	@md2siokon_label_1340
            		; {
            			; if(mp.PlayInfo & 1)
00ECF:      				sra		R1, 1
00ED0:      				src		R0, 1
00ED1:      				if NC jmp	@__md2siokon_label_0328
            			; {
            				; ~~ clear FIFO
            
            
            				; S_INS = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00ED2:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00ED3:      					R3=		AR
            
            				; mp.note += 2;
00ED4:      					DX++
00ED5:      					DX++
            
            				; ~~ Initial Volume Setting (only support V2 15-bit volume)
            
            
            				; if(S_INS.b15)
00ED6:      					test		R3.b15
00ED7:      					if ZR jmp	@md2siokon_label_1355
            				; {
            					; ~~ skip vol
            
            					; S_INS.b15 = 0;
00ED8:      						clr		R3.b15
            
            					; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00ED9:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            					; mp.note += 2;
00EDA:      						DX++
00EDB:      						DX++
            
            					; if(AX == 0)
00EDC:      						if NZ jmp	@md2siokon_label_1355
            					; {
            						; ~~ cancel this channel if Volume == 0
            
            						; goto __md2siokon_label_0328;
00EDD:      							I1=		mp@note_l
00EDF:      							AR=		rm[I1]
00EE0:      							rm[I1++]=	AR + DX
00EE1:      							AR=		rm[I1]
00EE2:      							AR=		AR + 0 + C
00EE3:      							rm[I1]=		AR
00EE4:      							jmp		@__md2siokon_label_0328
            					; }
            				; }
            				@md2siokon_label_1355:
            
            
            				; ~~ skip PAN control
            
            				; if(S_INS.b14)
00EE5:      					test		R3.b14
00EE6:      					if ZR jmp	@md2siokon_label_1827
            				; {
            					; S_INS.b14 = 0;
00EE7:      						clr		R3.b14
            
            					; mp.note += 2;
00EE8:      						DX++
00EE9:      						DX++
            
            					; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00EEA:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
            				; }
            				@md2siokon_label_1827:
            
            				; ~~ FLTP
            
            				; S_FLTP = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00EEB:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00EEC:      					R2=		AR
            
            				; if(S_FLTP & 0x8000)
00EED:      					test		R2.b15
00EEE:      					if ZR jmp	@md2siokon_label_1044
            				; {
            					; mp.midich = AX.U & 0x000F;
00EEF:      						I1=		MC_MIDICH
00EF0:      						AR=		BX
00EF1:      						I1=		I1 + AR
00EF2:      						AR=		0x0F
00EF3:      						AR=		AR & R2
00EF4:      						rm[I1]=		AR
            
            					; S_FLTP &= ~0x800F;
00EF5:      						AR=		0x7FF0
00EF7:      						R2=		R2 & AR
            				; }
            				@md2siokon_label_1044:
            
            
            				; mp.note += 2;
00EF8:      					DX++
00EF9:      					DX++
            
            				; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00EFA:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            
            				; ~~ don't broken these register
            				;    CX		- i
            				;    DX		- next pch
            				;    BX		- pch
            				;    R1:R0	- mp.PlayInfo
            
            				; ~~ P1 is already safe to use it
            
            
            				; if(S_INS == DSP_INSBANK_NUM)
00EFB:      					AR=		DSP_INSBANK_NUM
00EFD:      					SF=		AR - R3
00EFE:      					if NE jmp	@md2siokon_label_1624
            				; {
            
            					; +-----+-----+-----------+-----------+
            					; | b15 | b14 | b13 - b12 | b11 - b0  |
            					; +-----+-----+-----------+-----------+
            					; |  0	|  0  |	 scale	  | INS index |
            					; +-----+-----+-----------+-----------+
            
            					; +-----+------------+
            					; | b15 | b14  - b0  |
            					; +-----+------------+
            					; |  0	|    FLTP    |
            					; +-----+------------+
            
            					; ~~ auto setup midi channel to 0
            					; ~~ because midi channel always 0 when instrument is DSP_INSBANK_NUM
            
            					; mp.midich = 0;
00EFF:      						I1=		MC_MIDICH
00F00:      						AR=		BX
00F01:      						I1=		I1 + AR
00F02:      						AR=		0
00F03:      						rm[I1]=		AR
            
            					; ~~ get address
            				/*
            					; spiContReadStart(mp->keymap + (pch->FLTP * 4), &mp->md2);
            						I1=		mp@keymap
            						slz		R2, 2
            						AR=		rm[I1++]
            						R2=		AR + R2
            						AR=		rm[I1]
            						AR=		AR + 0 + C
            						push		AR
            						push		R2
            						AR=		BP
            						AR=		AR + 2
            						I1=		AR
            						mSfContReadStart
            						pop		AR
            						pop		AR
            
            					; S_INS = spiContReadWord();
            						mSfContReadWord
            						R3=		AR		; INS
            
            					; S_FLTP = spiContReadWord();
            						mSfContReadWord
            						R2=		AR		; FLTP
            
            					; spiContReadStop();
            						mSfContReadStop
            				*/
            				; }
            				@md2siokon_label_1624:
            
            
            				; chmask = mp.okmask & (1 << pch->midich);
00F04:      					P1.hh=		0			; ~~ for FDSP
00F05:      					P1=		#@md2chmask_table
00F08:      					I1=		MC_MIDICH
00F09:      					AR=		BX
00F0A:      					I1=		I1 + AR
00F0B:      					AR=		rm[I1]			; ~~ pch->midich
00F0C:      					P1=		P1 + AR
00F0D:      					I1=		mp@okmask
00F0F:      					AR=		pm[P1]
00F10:      					P1=		rm[I1]
00F11:      					AR=		AR & P1
            
            				; if(chmask)
00F12:      					if ZR jmp	@md2siokon_label_2316
            				; {
            					; ~~ record this to okon
            
            					; okon->INS = S_INS;
00F13:      						rm[I0++]=	R3
            					; okon->FLTP = S_FLTP;
00F14:      						rm[I0++]=	R2
            				; }
            				@md2siokon_label_2316:
            
            
            				; sfContReadStart(HIADR(&mp.note));
00F15:      					I1=		mp@note_l
00F17:      					AR=		rm[I1]
00F18:      					rm[I1++]=	AR + DX
00F19:      					AR=		rm[I1]
00F1A:      					AR=		AR + 0 + C
00F1B:      					rm[I1]=		AR
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00F1C:      AR= rm[I1 -- ] 
00F1D:      P1 = rm[I1] 
00F1E:      sra AR 1 
00F1F:      src P1 1 
00F20:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            			; }
            			@__md2siokon_label_0328:
            		; __md2siokon_label_0328:
            
            			; pch++;
00F21:      				AR=		MC_SIZEOF
00F22:      				BX=		BX + AR
            
00F23:      			loop		@md2siokon_loop_1344
            		; }
            	; }
            	@md2siokon_label_1340:
00F24:      		I1=		mp@PlayInfo_l
00F26:      		rm[I1++]=	R0
00F27:      		rm[I1]=		R1
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00F28:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	@md2siokon_label_1645:
            
00F29:      	rets
            ; }
            
            
            
            
            ; ~.~---------------------------------------------------------------
            ; void md2ExtEvent(void)
            ;
            ; in:
            ;    none
            ;
            ; out:
            ;    none
            ;
            ;
            ; affect registers:
            ;    AR, AX, BX, CX, DX, I0, I1, R0, R1, R2, R3
            ;
            ; meaning registers:
            ;    AX:BX	- (1 << i)
            ;    CX		- i
            ;    DX		- next pch
            ;    I0		- pch
            ;    I1		- mp.??
            ;    R1:R0	- mp.PlayInfo
            ;    R2		- AX
            ;    R3		- BX
            ;
            ; special request:
            ;
            ;
            ; ------------------------------------------------------------------
            md2ExtEvent_okon:
            ; {
            	; md2Channel *pch;
            	; DSP16 AX, BX;
            	; int i;
            
            	; if(mp.extev & 0x04)
00F2A:      		I1=		mp@extev
00F2C:      		AR=		rm[I1]
00F2D:      		test		AR.b2
00F2E:      		if ZR jmp	@md2extevokon_label_1428
            	; {
            		; ~~ extend event 4-bit
            
            		; ~~ +-----------+---------------+--------------+
            		; ~~ | ext event | event channel | control data |
            		; ~~ | 4-bit	 |    20-bit	 |    n bytes	|
            		; ~~ +-----------+---------------+--------------+
            
            		; sfContReadStart(HIADR(&mp.note));
00F2F:      			I1=		mp@note_h
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00F31:      AR= rm[I1 -- ] 
00F32:      P1 = rm[I1] 
00F33:      sra AR 1 
00F34:      src P1 1 
00F35:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            		; // +-------------------+
            		; // |	Channel [19:16]	 |  N0
            		; // +-------------------+	 L
            		; // |	     ExtEV	 |  N1
            		; // +-------------------+
            		; // |	Channel [11:8]	 |  N2
            		; // +-------------------+	 H
            		; // |	Channel [15:12]	 |  N3
            		; // +-------------------+
            
            		; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00F36:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00F37:      			R0=		AR
            
            		; mp.extev = AX.N1;
00F38:      			I1=		mp@extev
00F3A:      			sra		AR, 2
00F3B:      			sra		AR, 2
00F3C:      			AR=		AR & 0x0F
00F3D:      			rm[I1]=		AR
            
            		; ~~ volume control
            
            		; if(mp.extev & 0x01)
00F3E:      			test		AR.b0
00F3F:      			if ZR jmp	@md2extevokon_label_1542
            		; {
            			; mp.PlayInfo = (((unsigned long)AX.N0) << 16) |
            					; ((unsigned long)AX.H << 8);
00F40:      				AR=		0x0F
00F41:      				AR=		AR & R0
00F42:      				R1=		AR
00F43:      				AR=		0xFF00
00F45:      				R0=		R0 & AR
            
            			; // +-------------------+
            			; // |			 |  N0
            			; // |	Channel [7:0]	 |	 L
            			; // |			 |  N1
            			; // +-------------------+
            			; // |			 |  N2
            			; // |	   Data 0	 |	 H
            			; // |			 |  N3
            			; // +-------------------+
            
            			; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00F46:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            
            			; mp.PlayInfo |= (unsigned long)AX.L;
00F47:      				AX=		AR
00F48:      				AH=		0
00F49:      				R0=		R0 | AR
            
            			; c = 4;
00F4A:      				DX=		4
            
            			; for(i = 0; (i < 20) && (mp->PlayInfo); i++)
00F4B:      				io[ClrWDT]=	AR
00F4C:      				CX=		19
            			@md2extevokon_loop_1807:
00F4D:      				AR=		R0
00F4E:      				AR=		AR | R1
00F4F:      				if ZR jmp	@md2extevokon_label_1808
            			; {
            				; if(mp->PlayInfo & 0x01)
00F50:      					sra		R1, 1
00F51:      					src		R0, 1
00F52:      					if NC jmp	@md2extevokon_label_1808_1
            				; {
            					; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00F53:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            					; c += 2;
00F54:      						DX++
00F55:      						DX++
            				; }
            				@md2extevokon_label_1808_1:
            
            				; mp->PlayInfo >>= 1;
            
00F56:      				loop		@md2extevokon_loop_1807
            			; }
            			@md2extevokon_label_1808:
            
            			; mp.note += c;
00F57:      				I1=		mp@note_l
00F59:      				AR=		rm[I1]
00F5A:      				rm[I1++]=	AR + DX
00F5B:      				AR=		rm[I1]
00F5C:      				AR=		AR + 0 + C
00F5D:      				rm[I1]=		AR
            
            			; ~~ stop continue function and restart it again
            			; ~~ for align reason.
            
            			; sfContReadStop();
            				; mSfContReadStop
            
            			; sfContReadStart(HIADR(&mp.note));
            				; I1=		mp@note_h
            				; mSfContReadStart
            
            			; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00F5E:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00F5F:      				R0=		AR
            		; }
            		@md2extevokon_label_1542:
            
            		; // pitch bend
            
            		; if(mp.extev & 0x02)
00F60:      			I1=		mp@extev
00F62:      			AR=		rm[I1]
00F63:      			test		AR.b1
00F64:      			if ZR jmp	@md2extevokon_label_1846
            		; {
            			; // +-------------------+
            			; // |	Channel [19:16]	 |  N0
            			; // +-------------------+	 L
            			; // |	     Dummy	 |  N1
            			; // +-------------------+
            			; // |	Channel [11:8]	 |  N2
            			; // +-------------------+	 H
            			; // |	Channel [15:12]	 |  N3
            			; // +-------------------+
            
            			; mp->PlayInfo = (((unsigned long)AX.N0) << 16) |
            					; ((unsigned long)AX.H << 8);
00F65:      				AR=		0x0F
00F66:      				AR=		AR & R0
00F67:      				R1=		AR
00F68:      				AR=		0xFF00
00F6A:      				R0=		R0 & AR
            
            			; // +-------------------+
            			; // |			 |  N0
            			; // |	Channel [7:0]	 |	 L
            			; // |			 |  N1
            			; // +-------------------+
            			; // |			 |  N2
            			; // |	   FLTP [7:0]	 |	 H
            			; // |			 |  N3
            			; // +-------------------+
            
            			; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00F6B:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            			; mp->PlayInfo |= (unsigned long)AX.L;
00F6C:      				AX=		AR
00F6D:      				AH=		0
00F6E:      				R0=		R0 | AR
            
            			; for(i = 0; (i < 20) && (mp->PlayInfo); i++)
00F6F:      				io[ClrWDT]=	AR
00F70:      				CX=		19
00F71:      				DX=		4
            			@md2extevokon_loop_1850:
00F72:      				AR=		R0
00F73:      				AR=		AR | R1
00F74:      				if ZR jmp	@md2extevokon_label_1850
            			; {
            				; if(mp->PlayInfo & 0x01)
00F75:      					sra		R1, 1
00F76:      					src		R0, 1
00F77:      					if NC jmp	@md2extevokon_label_1850_1
            				; {
            					; mp->note += 2;
00F78:      						DX++
00F79:      						DX++
            				; }
            				@md2extevokon_label_1850_1:
            
            				; mp->PlayInfo >>= 1;
            
00F7A:      				loop		@md2extevokon_loop_1850
            			; }
            			@md2extevokon_label_1850:
00F7B:      				I1=		mp@note_l
00F7D:      				AR=		rm[I1]
00F7E:      				rm[I1++]=	AR + DX
00F7F:      				AR=		rm[I1]
00F80:      				AR=		AR + 0 + C
00F81:      				rm[I1]=		AR
            		; }
            		@md2extevokon_label_1846:
            
            		; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00F82:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            		; mp.PlayInfo = 0;
            		; mp.ExtEV = 0;
00F83:      			I1=		mp@extev
00F85:      			AR=		0
00F86:      			rm[I1]=		AR
            	; }
            	@md2extevokon_label_1428:
            
00F87:      	rets
            ; }
            
            
            ; +++++++++++++++++++++
            
            
            md2FindNextOkon:
            ; {
            	; if(!mp.okmask)
00F88:      		I1=		mp@okmask
00F8A:      		AR=		rm[I1]
00F8B:      		if NZ jmp	@md2fnok_label_1603
            	; {
            		; return false;
00F8C:      			clr		Z
00F8D:      			rets
            	; }
            	@md2fnok_label_1603:
            
            
            	; memset(mp.okon, -1, sizeof(mp.okon);
00F8E:      		CX=		15
00F8F:      		I1=		mp@okon
00F91:      		AR=		-1
            	@md2fnok_loop_1117:
00F92:      		rm[I1++]=	AR
00F93:      		loop		@md2fnok_loop_1117
            
            	; while(mp@note && (mp.okon[0].INS == -1))
00F94:      		MACOP=		0
            	@md2fnok_loop_1122:
00F95:      		io[ClrWDT]=	AR
00F96:      		I1=		mp@note_l
00F98:      		AR=		rm[I1++]
00F99:      		AX=		rm[I1]
00F9A:      		AR=		AR | AX
00F9B:      		if ZR jmp	@md2fnok_label_1115
00F9C:      		I1=		mp@okon
00F9E:      		AR=		rm[I1]
00F9F:      		SF=		AR - 0xFF
00FA0:      		if NE jmp	@md2fnok_label_1115
            	; {
            		; md2DoEvent_okon();
00FA1:      			PCH=		md2DoEvent_okon
00FA2:      			lcall		md2DoEvent_okon
            
            		; md2SetInstrument_okon();
00FA3:      			PCH=		md2SetInstrument_okon
00FA4:      			lcall		md2SetInstrument_okon
            
            		; md2ExtEvent_okon();
00FA5:      			PCH=		md2ExtEvent_okon
00FA6:      			lcall		md2ExtEvent_okon
            
00FA7:      		jmp		@md2fnok_loop_1122
            	; }
            	@md2fnok_label_1115:
            
            
            	; return (mp.okon[0].INS == -1) ? false : true;
00FA8:      		I1=		mp@okon
00FAA:      		AR=		rm[I1]
00FAB:      		SF=		AR - 0xFF
00FAC:      		if EQ jmp	@md2fnok_label_1124
00FAD:      		set		Z
00FAE:      		rets
            	@md2fnok_label_1124:
00FAF:      		clr		Z
00FB0:      		rets
            ; }
            
            ; ~~
            
            
            ; ---------------------------------------------------------------------------
            
            md2PlayOkon:
            ; {
            	; if(!mp.okmask)
00FB1:      		I1=		mp@okmask
00FB3:      		AR=		rm[I1]
00FB4:      		if NZ jmp	@md2pokon_label_1603
            	; {
            		; return;
00FB5:      			rets
            	; }
            	@md2pokon_label_1603:
            
            
            md2PlayOkonAccomp:
            
            	; kindex = 0x0100;
00FB6:      		BX=		0x0100
            
            	; for(i = 0; i < mp.lop; i++)
00FB8:      		I1=		mp@okon
00FBA:      		CX=		7
            	@md2pokon_loop_1337:
            	; {
            		; if(mp.okon[i].INS == -1)
00FBB:      			AR=		rm[I1]
00FBC:      			SF=		AR - 0xFF
00FBD:      			if EQ jmp	@md2pokon_label_1338
            		; {
            			; break;
            		; }
            
            
            		; if(!__md2GetFreeOp())
00FBE:      			push		I1
00FBF:      			push		BX
00FC0:      			push		CX
            
00FC1:      			PCH=		__md2GetFreeOp
00FC2:      			lcall		__md2GetFreeOp
00FC3:      			push		CX
00FC4:      			pop		AX
            
00FC5:      			pop		CX
00FC6:      			pop		BX
00FC7:      			pop		I1
00FC8:      			if ZR jmp	@md2pokon_label_1754
            		; {
            			; if(!__md2GetRecycleOp())
00FC9:      				push		I1
00FCA:      				push		BX
00FCB:      				push		CX
            
00FCC:      				PCH=		__md2GetRecycleOp
00FCD:      				lcall		__md2GetRecycleOp
00FCE:      				push		CX
00FCF:      				pop		AX
            
00FD0:      				pop		CX
00FD1:      				pop		BX
00FD2:      				pop		I1
00FD3:      				if NZ jmp	@md2pokon_label_1338
            			; {
            				; break;
            			; }
            		; }
            		@md2pokon_label_1754:
            
            		; iINS = mp.okon[i].INS;
00FD4:      			R3=		rm[I1++]
            		; iFLTP = mp.okon[i].FLTP;
00FD5:      			R2=		rm[I1--]
            
            		; if(iINS == DSP_INSBANK_NUM)
00FD6:      			AR=		DSP_INSBANK_NUM
00FD8:      			SF=		AR - R3
00FD9:      			if NE jmp	@md2pokon_label_1347
            		; {
            
            			; ~~ get address
            
            			; spiContReadStart(mp->keymap + (pch->FLTP * 4), &mp->md2);
00FDA:      				push		I1
00FDB:      				push		BX
00FDC:      				push		CX
00FDD:      				push		AX
00FDE:      				I1=		mp@keymap
00FE0:      				slz		R2, 2
00FE1:      				AR=		rm[I1++]
00FE2:      				R2=		AR + R2
00FE3:      				AR=		rm[I1]
00FE4:      				AR=		AR + 0 + C
00FE5:      				push		AR
00FE6:      				push		R2
00FE7:      				AR=		BP
00FE8:      				AR=		AR + 2
00FE9:      				I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
00FEA:      AR= rm[I1 -- ] 
00FEB:      P1 = rm[I1] 
00FEC:      sra AR 1 
00FED:      src P1 1 
00FEE:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
00FEF:      				pop		AR
00FF0:      				pop		AR
            
            			; S_INS = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00FF1:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00FF2:      				R3=		AR		; INS
            
            			; S_FLTP = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
00FF3:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
00FF4:      				R2=		AR		; FLTP
            
            			; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
00FF5:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
00FF6:      				pop		AX
00FF7:      				pop		CX
00FF8:      				pop		BX
00FF9:      				pop		I1
            		; }
            		@md2pokon_label_1347:
            
            
            		; __sub_md2PlayNote_nomap();
00FFA:      			push		I1
00FFB:      			push		BX
00FFC:      			push		CX
00FFD:      			push		AX
00FFE:      			pop		CX
            			; DX=		0x7FFF
            
00FFF:      			PCH=		__sub_md2PlayNote_nomap
01000:      			lcall		__sub_md2PlayNote_nomap
01001:      			pop		CX
01002:      			pop		BX
01003:      			pop		I1
            
            		; mp.okon[i].INS = kindex;
01004:      			AR=		BX
01005:      			rm[I1++2]=	AR
            
            		; kindex++;
01006:      			BX++
            
01007:      		loop		@md2pokon_loop_1337
            	; }
            	@md2pokon_label_1338:
            
01008:      	rets
            ; }
            
            
            ; ---------------------------------------------------------------------------
            
            md2ReleaseOkon:
            ; {
            	; if(!mp.okmask)
01009:      		I1=		mp@okmask
0100B:      		AR=		rm[I1]
0100C:      		if NZ jmp	@md2rokon_label_1603
            	; {
            		; return;
0100D:      			rets
            	; }
            	@md2rokon_label_1603:
            
            
            md2ReleaseOkonAccomp:
            	; kindex = 0x0100;
0100E:      		AX=		0x0100
            
            	; for(i = 0; i < 20; i++)
01010:      		I1=		mp@okon
01012:      		CX=		rm[mp_lop]
            	@md2rokon_loop_1337:
            	; {
            		; if(mp.okon[i].INS == -1)
01013:      			AR=		rm[I1]
01014:      			SF=		AR - 0xFF
01015:      			if EQ jmp	@md2rokon_label_1338
            		; {
            			; break;
            		; }
            
            		; md2ReleaseNote_okon(mp.okon[i].INS);
01016:      			push		I1
01017:      			push		CX
01018:      			AX=		rm[I1]
01019:      			PCH=		md2ReleaseNote_okon
0101A:      			lcall		md2ReleaseNote_okon
0101B:      			pop		CX
0101C:      			pop		I1
            
            		; mp.okon[i].INS = -1;
0101D:      			AR=		-1
0101E:      			rm[I1++]=	AR
            
            		; mp.okon[i].FLTP = -1;
0101F:      			rm[I1++]=	AR
            
01020:      		loop		@md2rokon_loop_1337
            	; }
            	@md2rokon_label_1338:
            
01021:      	rets
            ; }
            
            
            
            ; ~.~------------------------------------------------------------
            ; bool md2LoopToSong(short index)
            ;
            ; in:
            ;    AX			- index
            ;
            ; out:
            ;    none
            ;
            ; affect registers:
            ;    All
            ;
            ; meaning registers:
            ;
            ;
            ; special request:
            ;   none
            ;
            ; -------------------------------------------------------------
            md2LoopToSong:
            ; {
            	; if(index >= mp.songcnt)
01022:      		AR=		rm[mp_songcnt]
01023:      		SF=		AR - AX
01024:      		if LE jmp	@md2looptosong_label_1541
01025:      		jmp		@md2looptosong_label_1541_1
            	@md2looptosong_label_1541:
            	; {
            		; return false;
01026:      			clr		Z
01027:      			rets
            	; }
            	@md2looptosong_label_1541_1:
            
            
            	; mp.lpadr = mp.songhdr + (index * sizeof(long))
01028:      		I1=		mp@songhdr_l
0102A:      		BX=		rm[I1++]
0102B:      		DX=		rm[I1]
0102C:      		I1=		mp@lpadrl
0102E:      		AR=		AX
0102F:      		slz		AR, 2
01030:      		rm[I1++]=	BX + AR
01031:      		AR=		0
01032:      		rm[I1]=		DX + AR + C
            
            
            	; sfContReadStart(HIADR(&mp.lpadr));
01033:      		I1=		mp@lpadrh
            ;;<<System message ======  Macro. mSfContReadStart,12243,12249,,,,,,,,,,,,,,,,  strat ======
01035:      AR= rm[I1 -- ] 
01036:      P1 = rm[I1] 
01037:      sra AR 1 
01038:      src P1 1 
01039:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            	; sfContRead2Word();
            
            	; mp.lpadr = mp.baseadr + (SPI_DAT + (SPI_DAT << 16));
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
0103A:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
0103B:      		BX=		AR
            ;;<<System message ======  Macro. mSfContReadWord,12252,12254,,,,,,,,,,,,,,,,  strat ======
0103C:      AR= pm[P1 ++ ] 
            ;; System message>>====== Macro. mSfContReadWord end ======
0103D:      		DX=		AR
0103E:      		I1=		mp_baseadr_l
0103F:      		AR=		rm[I1++]
01040:      		BX=		BX + AR
01041:      		AR=		rm[I1]
01042:      		DX=		DX + AR + C
01043:      		I1=		mp@lpadrl
01045:      		rm[I1++]=	BX
01046:      		rm[I1]=		DX
            
            	; mp.lpadr &= 0x3FFFFFFF;
01047:      		AR=		rm[I1]
01048:      		clr		AR.b15
01049:      		clr		AR.b14
0104A:      		rm[I1]=		AR
            
            	; sfContReadStop
            ;;<<System message ======  Macro. mSfContReadStop,12257,12259,,,,,,,,,,,,,,,,  strat ======
0104B:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; return true;
0104C:      		set		Z
0104D:      		rets
            ; }
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBMD2TINY\F2GM-PIANO-COHERE-TINY.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBMD2TINY\F2GM-CSHELL-E.ASM> Start=========================
            
            
            ShareVar = {
            
            	; ~~ for backward compatible only
            	
            	_mp_outbufE6EABE1D = mp_outbuf
            }
            
            
            
            
            ; ----------------------------
            
            _md2DoRoutine82B98B9D:
            ; {
0104E:      	PCH=		md2DoRoutine
0104F:      	lcall		md2DoRoutine
            
            L68D8F143_0:
01050:      	if ZR jmp	L68D8F143_1
01051:      	AX=		0
01052:      	rets
            L68D8F143_1:
01053:      	AX=		1
01054:      	rets
            ; }
            
            ; ----------------------------
            
            _md2SelectIns277ACAB1:
            ; {
            	; AX - rpdax
01055:      	PCH=		md2SelectIns
01056:      	lcall		md2SelectIns
01057:      	jmp		L68D8F143_0
            ; }
            
            ; ----------------------------
            
            _md2PlaySongF1CD4C9D:
            ; {
            	; AX - rpdax
01058:      	PCH=		md2PlaySong
01059:      	lcall		md2PlaySong
0105A:      	jmp		L68D8F143_0
            ; }
            
            ; ----------------------------
            
            _md2PlayRhythmLoop446C96D5:
            ; {
            	; AX - rpdax
0105B:      	PCH=		md2PlayRhythmLoop
0105C:      	lcall		md2PlayRhythmLoop
0105D:      	jmp		L68D8F143_0
            ; }
            
            ; ----------------------------
            
            _md2ChkSongEnd0B00CDA5:
            ; {
0105E:      	PCH=		md2ChkSongEnd
0105F:      	lcall		md2ChkSongEnd
01060:      	jmp		L68D8F143_0
            ; }
            
            
            ; ----------------------------
            
            _md2PlayNoteC61ED125:
            ; {
01061:      	AR=		BP
01062:      	AR=		AR + 1
01063:      	I1=		AR
            
01064:      	AX=		rm[I1++]
01065:      	DX=		rm[I1]
01066:      	PCH=		md2PlayNote
01067:      	lcall		md2PlayNote
01068:      	jmp		L68D8F143_0
            ; }
            
            ; ----------------------------
            
            _md2PlayPercNote818E3F25:
            ; {
01069:      	AR=		BP
0106A:      	AR=		AR + 1
0106B:      	I1=		AR
            
0106C:      	AX=		rm[I1++]
0106D:      	DX=		rm[I1]
0106E:      	PCH=		md2PlayPercNote
0106F:      	lcall		md2PlayPercNote
01070:      	jmp		L68D8F143_0
            ; }
            
            ; ----------------------------
            
            _md2ReleaseNote7FE95EF3:
            ; {
01071:      	AR=		BP
01072:      	AR=		AR + 1
01073:      	I1=		AR
01074:      	AX=		rm[I1++]
01075:      	DX=		rm[I1]
01076:      	PCH=		md2ReleaseNote
01077:      	lcall		md2ReleaseNote
01078:      	jmp		L68D8F143_0
            ; }
            
            ; ----------------------------
            
            _md2ReleasePercNote8CD707D5:
            ; {
01079:      	AR=		BP
0107A:      	AR=		AR + 1
0107B:      	I1=		AR
0107C:      	AX=		rm[I1++]
0107D:      	DX=		rm[I1]
0107E:      	PCH=		md2ReleasePercNote
0107F:      	lcall		md2ReleasePercNote
01080:      	jmp		L68D8F143_0
            ; }
            
            ; ----------------------------
            
            _md2FindMidiEntry757C576D:
            ; {
            	; DX:AX - rpdax --> AX:BX
            
01081:      	AR=		AX
01082:      	BX=		AR
01083:      	AR=		DX
01084:      	AX=		AR
01085:      	PCH=		md2FindMidiEntry
01086:      	lcall		md2FindMidiEntry
01087:      	jmp		L68D8F143_0
            ; }
            
            ; ----------------------------
            
            _md2FindNextOkonD3FEE6DA:
            ; {
01088:      	PCH=		md2FindNextOkon
01089:      	lcall		md2FindNextOkon
0108A:      	jmp		L68D8F143_0
            ; }
            
            ; ----------------------------
            
            _md2PlayOkon3411E62A:
            ; {
            	; AX - rpdax -> DX
0108B:      	AR=		AX
0108C:      	DX=		AR
0108D:      	PCH=		md2PlayOkon
0108E:      	lcall		md2PlayOkon
0108F:      	jmp		L68D8F143_0
            ; }
            
            ; ----------------------------
            
            _md2PlayOkonAccomp18254831:
            ; {
            	; AX - rpdax -> DX
01090:      	AR=		AX
01091:      	DX=		AR
01092:      	PCH=		md2PlayOkonAccomp
01093:      	lcall		md2PlayOkonAccomp
01094:      	jmp		L68D8F143_0
            ; }
            
            ; ----------------------------
            
            _md2ReleaseOkonF4500B9D:
            ; {
            	; AX - rpdax -> DX
01095:      	AR=		AX
01096:      	DX=		AR
01097:      	PCH=		md2ReleaseOkon
01098:      	lcall		md2ReleaseOkon
01099:      	jmp		L68D8F143_0
            ; }
            
            ; ----------------------------
            
            _md2LoopToSong6DEA50ED:
            ; {
            	; AX - rpdax
0109A:      	PCH=		md2LoopToSong
0109B:      	lcall		md2LoopToSong
0109C:      	jmp		L68D8F143_0
            ; }
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBMD2TINY\F2GM-CSHELL-E.ASM> End=========================
            
            ;
            #LINKOBJ "C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBMD2TINY\MD2MIDPCM.OBJ"
            ;
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBMD2TINY\F2GM-MEDIA.ASM> Start=========================
            
            
            .code
            
            ; ~~ hardware SPI for MX25L3205D / KH25L2405D / MX25L25635E
            
            
            
            
            ; ~.~
            
            #define SFCMD_READ		0x0003
            #define SFCMD_WRITE_ENABLE	0x0006
            #define SFCMD_WRITE_DISABLE	0x0004
            #define SFCMD_READ_STATUS	0x0005
            #define SFCMD_WRITE_STATUS	0x0001
            #define SFCMD_SECTOR_ERASE	0x0020
            #define SFCMD_PAGE_PROGRAM	0x0002
            #define SFCMD_CONT_PROGRAM	0x00AD
            
            
            #ifdef MD2_USE_SPI
            
            
            
            
            #ifdef _SPIFLASH_STD_SF16128_
            
              #define SF_SPEED		0x13
            
            #else
            
              #define SF_SPEED		0x10
            
            #endif
            
            
            
            
            #ifdef _SPIFLASH_STD_SF16128_
            
            ; ~.~------------------------------------------------------------
            ; void sfContReadStart(WORD *pAdrHL)
            ;
            ; in:
            ;    I1			- pAdrHL (flash address point to high address)
            ;
            ; out:
            ;
            ;
            ; affect registers:
            ;    AR, I1
            ;
            ; meaning registers:
            ;
            ;
            ; ---------------------------------------------------------------
            sfContReadStart:
            ; {
            	; PIN_SFLASH_CS(low);
            		PIN_SFLASH_CS	clr
            
            	; SPI_ICS = LOW;
            		SPI_ICS		clr
            
            	; SPI_DAT = SFCMD_READ | ((*(pAdrHL--) & 0x00FF) << 8);
            		AR=		rm[I1--]
            		xchg		AR
            		AL=		SFCMD_READ
            		io[SPI_DAT]=	AR
            
            	; SPI_CTL = 2;
            		AH=		SF_SPEED
            		AL=		0x12
            		io[SPI_CTL]=	AR
            
            	; sfWaitSPIOK();
            		call		sfWaitSPIOK
            
            	; ADR = *(pAdrHL);
            	; SPI_DAT = (ADR << 8) | (ADR >> 8);
            		AR=		rm[I1]
            		xchg		AR
            		io[SPI_DAT]=	AR
            
            	; SPI_CTL = 2;
            		AH=		SF_SPEED
            		AL=		0x12
            		io[SPI_CTL]=	AR
            
            	; sfWaitSPIOK();
            		jmp		sfWaitSPIOK
            
            	; rets
            ; }
            
            
            
            
            macro	mSfContReadStart
            	PCH=		sfContReadStart
            	lcall		sfContReadStart
            endm
            
            
            macro	mSfContRead	count
            	; SPI_CTL = count | SEND | SF_SPEED;
            		AH=		SF_SPEED
            		AL=		count
            		io[SPI_CTL]=	AR
            endm
            
            
            macro	mSfContReadWord
            	PCH=		sfContReadWord
            	lcall		sfContReadWord
            endm
            
            
            macro mSfContReadStop
            	set		io[PortB].b5		; ~~ SPI_CS
            	AR=		io[SPI_CTL]
            	set		AR.b11
            	io[SPI_CTL]=	AR
            endm
            
            
            
            #endif
            
            
            ; ~.~------------------------------------------------------------
            ; WORD sfContReadWord(void)
            ;
            ; in:
            ;    none
            ;
            ; out:
            ;    AR
            ;
            ; affect registers:
            ;    AR
            ;
            ; affect RAM:
            ;
            ;
            ; meaning registers:
            ;
            ;
            ; ---------------------------------------------------------------
            sfContReadWord:
            ; {
            #ifdef _SPIFLASH_STD_SF16128_
            
            	mSfContRead		0x22
            
            #else
            
            	mSfContRead		2
            
            #endif
            
            	; sfWaitSPIOK();
            		call		sfWaitSPIOK
            
            	; return SPI_DAT;
            		AR=		io[SPI_DAT]
            		rets
            ; }
            
            
            
            ; ~.~-----------------------------------------------------------
            ; sfWaitSPIOK(void)
            ;
            ; in:
            ;    none
            ;
            ; out:
            ;    none
            ;
            ; affect registers:
            ;    none
            ;
            ; meaning registers:
            ;    none
            ;
            ; special request:
            ;    none
            ;
            ; -------------------------------------------------------------
            sfWaitSPIOK:
            ; {
            	; while(!SPI_CTL.DATOK);
            	@swso_loop_0954:
            		AR=		io[SPI_CTL]
            		test		AR.b7
            		if ZR jmp	@swso_loop_0954
            
            #ifdef _SPIFLASH_STD_SF16128_
            
            
            #else
            	; SPI_CTL.CLR = 1;
            		set		io[SPI_CTL].b6
            	; SPI_CTL.CLR = 0;
            		clr		io[SPI_CTL].b6
            #endif
            
            	rets
            ; }
            
            
            
            #endif
            
            
            
            
            #ifdef MD2_USE_PROM
            
            
            macro	mSfContReadStart
            	AR=		rm[I1--]
            	P1=		rm[I1]
            	sra		AR, 1
            	src		P1, 1
            	P1.hh=		AR
            endm
            
            
            macro	mSfContReadWord
            	AR=		pm[P1++]
            endm
            
            
            macro mSfContReadStop
            	P1.hh=		0
            endm
            
            
            
            #endif
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBMD2TINY\F2GM-MEDIA.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBADPCM\ADP12_CSHELL-E.ASM> Start=========================
            
            
            
            
            
            _SDSP_ADPCM_4Bit_SingleCH_decoder94C4563E:
            ; {
01114:      	PCH=            SDSP_ADPCM_4Bit_SingleCH_decoder
01115:              lcall           SDSP_ADPCM_4Bit_SingleCH_decoder	; Z fail
01116:              AX=		1
01117:              if NZ jmp	L9E1082DD_0
01118:              AX=		0
            L9E1082DD_0:
01119:      	rets
            ; }
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBADPCM\ADP12_CSHELL-E.ASM> End=========================
            
            ;
            #LINKOBJ "C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBADPCM\XDSP_ADPCM_4BIT_DECV04.OBJ"
            ;
            
            ;=========================Include <DEPS\6C656251_GINIT.S.CODE.ASM> Start=========================
            ; 6C656251_ginit.s.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code(void)			
            ginit_code:
            ; //{
            ; //	ginit_code_HOW_DO_I_PLAY_MD2_AND_ADPCM_SIMULTANEOUSLY_D38B16D5_s();
0144F:      	pch	= ginit_code_HOW_DO_I_PLAY_MD2_AND_ADPCM_SIMULTANEOUSLY_D38B16D5_s
01450:      	lcall	ginit_code_HOW_DO_I_PLAY_MD2_AND_ADPCM_SIMULTANEOUSLY_D38B16D5_s
            ; //	ginit_code_keypad_0E0216C1_s();		
01451:      	pch	= ginit_code_keypad_0E0216C1_s
01452:      	lcall	ginit_code_keypad_0E0216C1_s
            ; //	ginit_code_global_6037E6D5_s();		
01453:      	pch	= ginit_code_global_6037E6D5_s
01454:      	lcall	ginit_code_global_6037E6D5_s
            ; //	ginit_code_support_EBA84A55_s();	
01455:      	pch	= ginit_code_support_EBA84A55_s
01456:      	lcall	ginit_code_support_EBA84A55_s
            ; //	ginit_code_data_0EBCA7F9_s();		
01457:      	pch	= ginit_code_data_0EBCA7F9_s
01458:      	lcall	ginit_code_data_0EBCA7F9_s
            ; //	ginit_code_memset_CDCF17ED_s();		
01459:      	pch	= ginit_code_memset_CDCF17ED_s
0145A:      	lcall	ginit_code_memset_CDCF17ED_s
            ; //	ginit_code_md2_8786BA41_s();		
0145B:      	pch	= ginit_code_md2_8786BA41_s
0145C:      	lcall	ginit_code_md2_8786BA41_s
            ; //	ginit_code_adp12_EF8DA009_s();		
0145D:      	pch	= ginit_code_adp12_EF8DA009_s
0145E:      	lcall	ginit_code_adp12_EF8DA009_s
            ; //	return;					
0145F:      	rets
            ; //}
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\6C656251_GINIT.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> Start=========================
            
            
            ; ~~ CRT0 support functions
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GLOBALINIT(void)
            ; void sfx_LOCALINIT(void)
            ;
            ; in:
            ;     I1	- pointer to SRAM initial value
            ;     P1	- pointer to PROM initial data
            ;     CX	- total count (word)
            ;
            ; out:
            ;     none
            ;
            ; --------------------------------------------
            sfx_GLOBALINIT:
            sfx_LOCALINIT:
01460:      	P1.hh=		0
01461:      	jmp		@glinit_label_1409
            @glinit_loop_1409:
01462:      	AR=		pm[P1++]
01463:      	rm[I1++]=	AR
            @glinit_label_1409:
01464:      	loop		@glinit_loop_1409
01465:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MUL_AX_CX(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MUL_AX_CX:
            
01466:      	AR=		AX
01467:      	MX=		AR
01468:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
01469:      	MACOP=		3
0146A:      	MR=		MX * AR
            #endif
            
0146B:      	AR=		MR0
0146C:      	AX=		AR
0146D:      	AR=		MR1
0146E:      	DX=		AR
0146F:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMUL_AX_CX(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMUL_AX_CX:
            
01470:      	AR=		AX
01471:      	MX=		AR
01472:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
01473:      	MACOP=		0
01474:      	MR=		MX * AR
            #endif
            
01475:      	AR=		MR0
01476:      	AX=		AR
01477:      	AR=		MR1
01478:      	DX=		AR
01479:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMULLONG(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMULLONG:
0147A:      	AR=		rm[BP_SAVE]
0147B:      	push		AR
0147C:      	AR=		BP
0147D:      	rm[BP_SAVE]=	AR
0147E:      	AR=		AR - 3
0147F:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
01480:      	AR=		CX
01481:      	MX=		AR
01482:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
01483:      	MACOP=		3		; unsigned
01484:      	MR=		MX * AR
            #endif
            
01485:      	I1=		rm[BP_SAVE]
01486:      	AR=		2
01487:      	I1=		I1 - AR
01488:      	rm[I1++]=	MR0
01489:      	rm[I1++]=	MR1
0148A:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
0148B:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUS
            #else
0148C:      	MACOP=		1		; mx:unsigned / my:signed
0148D:      	MR=		MX * AR
            #endif
            
0148E:      	AR=		rm[I1]
0148F:      	AR=		AR + MR0
01490:      	rm[I1++]=	AR
01491:      	AR=		rm[I1]
01492:      	AR=		AR + MR1 + C
01493:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
01494:      	AR=		BX
01495:      	MX=		AR
01496:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULSU
            #else
01497:      	MACOP=		2		; mx:signed / my:unsigned
01498:      	MR=		MX * AR
            #endif
            
01499:      	AR=		rm[I1]
0149A:      	AR=		AR + MR0
0149B:      	rm[I1++]=	AR
0149C:      	AR=		rm[I1]
0149D:      	AR=		AR + MR1 + C
0149E:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
0149F:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
014A0:      	MACOP=		0		; mx:signed / my:signed
014A1:      	MR=		MX * AR
            #endif
            
014A2:      	AR=		rm[I1]
014A3:      	AR=		AR + MR0
014A4:      	rm[I1]=		AR
            
014A5:      	I1=		rm[BP_SAVE]
014A6:      	CX=		rm[I1--]
014A7:      	DX=		rm[I1--]
014A8:      	AX=		rm[I1]
            
014A9:      	AR=		3
014AA:      	BP=		BP + AR
014AB:      	pop		AR
014AC:      	rm[BP_SAVE]=	AR
            
014AD:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MULLONG(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MULLONG:
014AE:      	AR=		rm[BP_SAVE]
014AF:      	push		AR
014B0:      	AR=		BP
014B1:      	rm[BP_SAVE]=	AR
014B2:      	AR=		AR - 3
014B3:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
014B4:      	AR=		CX
014B5:      	MX=		AR
014B6:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
014B7:      	MACOP=		3		; unsigned
014B8:      	MR=		MX * AR
            #endif
            
014B9:      	I1=		rm[BP_SAVE]
014BA:      	AR=		2
014BB:      	I1=		I1 - AR
014BC:      	rm[I1++]=	MR0
014BD:      	rm[I1++]=	MR1
014BE:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
014BF:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
014C0:      	MR=		MX * AR
            #endif
            
014C1:      	AR=		rm[I1]
014C2:      	AR=		AR + MR0
014C3:      	rm[I1++]=	AR
014C4:      	AR=		rm[I1]
014C5:      	AR=		AR + MR1 + C
014C6:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
014C7:      	AR=		BX
014C8:      	MX=		AR
014C9:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
014CA:      	MR=		MX * AR
            #endif
            
014CB:      	AR=		rm[I1]
014CC:      	AR=		AR + MR0
014CD:      	rm[I1++]=	AR
014CE:      	AR=		rm[I1]
014CF:      	AR=		AR + MR1 + C
014D0:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
014D1:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
014D2:      	MR=		MX * AR
            #endif
            
014D3:      	AR=		rm[I1]
014D4:      	AR=		AR + MR0
014D5:      	rm[I1]=		AR
            
014D6:      	I1=		rm[BP_SAVE]
014D7:      	CX=		rm[I1--]
014D8:      	DX=		rm[I1--]
014D9:      	AX=		rm[I1]
            
014DA:      	AR=		3
014DB:      	BP=		BP + AR
014DC:      	pop		AR
014DD:      	rm[BP_SAVE]=	AR
            
014DE:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIV_AX_CX(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIV_AX_CX:
            	; unsigned int reste = 0;
014DF:      		DX=		0
            	; unsigned char count = 16;
014E0:      		R0=		16
            	; BOOL c;
            
            	; do
            	@divword_loop_1824:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
014E1:      			slz		AX, 1
            		; reste <<= 1;
014E2:      			slc		DX, 1
            
            		; if (c)
            		; {
            			; reste |= 1;
            		; }
            		@divword_label_1822:
            
            		; if (reste >= y)
014E3:      			AR=		DX
014E4:      			AR-=		CX
014E5:      			AR=		0
014E6:      			AR=		AR - 0 + C - 1
014E7:      			if AN jmp	@divword_label_1823
            		; {
            			; reste -= y;
014E8:      				AR=		CX
014E9:      				DX=		DX - AR
            			; ~~ x <- (result = 1)
            			; x |= 1;
014EA:      				set		AX.b0
            		; }
            		@divword_label_1823:
            
014EB:      		R0--
014EC:      		if NZ jmp	@divword_loop_1824
            	; }while (--count);
            
            	; return x;
014ED:      		rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIV_AX_CX(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIV_AX_CX:
            
            	; register int r;
            
            	; r = sfx_DIV_AX_CX((x < 0 ? -x : x), (y < 0 ? -y : y));
014EE:      		R1=		0
014EF:      		AR=		0
014F0:      		test		AX.b15
014F1:      		if ZR jmp	@divsword_label_1833
014F2:      			AX=		AR - AX
014F3:      			set		R1.b0
            		@divsword_label_1833:
014F4:      		test		CX.b15
014F5:      		if ZR jmp	@divsword_label_1834
014F6:      			CX=		AR - CX
014F7:      			set		R1.b1
            		@divsword_label_1834:
014F8:      		call		sfx_DIV_AX_CX
            
            	; if ((x < 0) ^ (y < 0))
014F9:      		AR=		R1
014FA:      		slz		AR, 1
014FB:      		AR^=		R1
014FC:      		test		AR.b1
014FD:      		if ZR jmp	@divsword_label_1835
            	; {
            		; return (0 - r);
014FE:      			AR=		0
014FF:      			AX=		AR - AX
01500:      			DX=		AR - DX
            
            	; }
            	@divsword_label_1835:
            
            	; return r;
01501:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIVLONG(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIVLONG:
            	; unsigned long reste = 0L;
01502:      		R0=		0	; L
01503:      		R1=		0	; H
            	; unsigned char count = 32;
01504:      		R2=		32
            	; BOOL c;
            
            	; do
            	@divulong_loop_1723:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
01505:      			slz		AX, 1
01506:      			slc		DX, 1
            		; reste <<= 1;
01507:      			slc		R0, 1
01508:      			slc		R1, 1
            
            		; if (c)
            		; {
            			; reste |= 1L;
            		; }
            		@divulong_label_1726:
            
            		; if (reste >= y)
01509:      			AR=		R0
0150A:      			AR-=		CX
0150B:      			AR=		R1
0150C:      			AR=		AR - BX + C - 1
0150D:      			if AN jmp	@divulong_label_1734
            		; {
            			; reste -= y;
0150E:      				AR=		CX
0150F:      				R0=		R0 - AR
01510:      				AR=		BX
01511:      				R1=		R1 - AR + C - 1
            			; ~~ x <- (result = 1)
            			; x |= 1L;
01512:      				set		AX.b0
            		; }
            		@divulong_label_1734:
            
01513:      		R2--
01514:      		if NZ jmp	@divulong_loop_1723
            	; }while (--count);
            
            	; return x;
01515:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIVLONG(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     BX:DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIVLONG:
            	; long r;
            
            	; r = divulong((x < 0 ? -x : x), (y < 0 ? -y : y));
01516:      		R3=		0
01517:      		AR=		0
01518:      		test		DX.b15
01519:      		if ZR jmp	@divslong_label_1759
0151A:      			AX=		AR - AX
0151B:      			DX=		AR - DX + C - 1
0151C:      			set		R3.b0
            		@divslong_label_1759:
0151D:      		test		BX.b15
0151E:      		if ZR jmp	@divslong_label_1800
0151F:      			CX=		AR - CX
01520:      			BX=		AR - BX + C - 1
01521:      			set		R3.b1
            		@divslong_label_1800:
01522:      		call		sfx_DIVLONG
            
            	; if ((x < 0) ^ (y < 0))
01523:      		AR=		R3
01524:      		slz		AR, 1
01525:      		AR^=		R3
01526:      		test		AR.b1
01527:      		if ZR jmp	@divslong_label_1807
            	; {
            		; return -r;
01528:      			AR=		0
01529:      			AX=		AR - AX
0152A:      			DX=		AR - DX + C - 1
0152B:      			R0=		AR - R0
0152C:      			R1=		AR - R1 + C - 1
            
            	; }
            	@divslong_label_1807:
            
            	; return r;
0152D:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MOD_AX_CX(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_MOD_AX_CX:
0152E:      	call		sfx_DIV_AX_CX
0152F:      	AR=		DX
01530:      	AX=		AR
01531:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMOD_AX_CX(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMOD_AX_CX:
01532:      	call		sfx_IDIV_AX_CX
01533:      	AR=		DX
01534:      	AX=		AR
01535:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MODLONG(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_MODLONG:
01536:      	call		sfx_DIVLONG
01537:      	AR=		R0
01538:      	AX=		AR
01539:      	AR=		R1
0153A:      	DX=		AR
0153B:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMODLONG(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMODLONG:
0153C:      	call		sfx_IDIVLONG
0153D:      	AR=		R0
0153E:      	AX=		AR
0153F:      	AR=		R1
01540:      	DX=		AR
01541:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG:
            	; AR=		CX
            	; AX=		AX + AR
            	; AR=		BX
            	; DX=		DX + AR + C
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG_BXCX_DXAX(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG_BXCX_DXAX:
            	; AR=		AX
            	; CX=		CX + AR
            	; AR=		DX
            	; BX=		BX + AR + C
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBLONG(void)
            ;
            ; note:
            ;     signed sub
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SUBLONG:
            	; AR=		CX
            	; AX=		AX - AR
            	; AR=		BX
            	; DX=		DX - AR + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDDIOFS(void)
            ;
            ; note:
            ;     add P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDDIOFS:
01542:      	AR=		AX
01543:      	P1=		P1 + AR
01544:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDSIOFS(void)
            ;
            ; note:
            ;     add I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDSIOFS:
01545:      	AR=		AX
01546:      	I1=		I1 + AR
01547:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDAXOFS(void)
            ;
            ; note:
            ;     add AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_ADDAXOFS:
01548:      	AR=		CX
01549:      	AX=		AX + AR
0154A:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBDIOFS(void)
            ;
            ; note:
            ;     sub P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBDIOFS:
0154B:      	AR=		AX
0154C:      	P1=		P1 - AR
0154D:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBSIOFS(void)
            ;
            ; note:
            ;     sub I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBSIOFS:
0154E:      	AR=		AX
0154F:      	I1=		I1 - AR
01550:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBAXOFS(void)
            ;
            ; note:
            ;     sub AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_SUBAXOFS:
01551:      	AR=		CX
01552:      	AX=		AX + AR
01553:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_DXAX(void)
            ;
            ; note:
            ;     load long data from PROM to DX:AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG:
            ; sfx_GETDILONG_DXAX:
            	; AX=		pm[P1++]
            	; DX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_BXCX(void)
            ;
            ; note:
            ;     load long data from PROM to BX:CX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG_BXCX:
            	; CX=		pm[P1++]
            	; BX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_DXAX(void)
            ; void sfx_GETSILONG_DXAX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to DX:AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG:
            ; sfx_GETSILONG_D:
            ; sfx_GETSILONG_DXAX:
            ; sfx_GETSILONG_DXAX_D:
            	; AX=		rm[I1++]
            	; DX=		rm[I1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_BXCX(void)
            ; void sfx_GETSILONG_BXCX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to BX:CX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG_BXCX:
            ; sfx_GETSILONG_BXCX_D:
            	; CX=		rm[I1++]
            	; BX=		rm[I1--]
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ANDLONG(void)
            ;
            ; note:
            ;     AND two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ANDLONG:
            	; AR=		CX
            	; AX=		AX & AR
            	; AR=		BX
            	; DX=		DX & AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ORLONG(void)
            ;
            ; note:
            ;     OR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ORLONG:
            	; AR=		CX
            	; AX=		AX | AR
            	; AR=		BX
            	; DX=		DX | AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XORLONG(void)
            ;
            ; note:
            ;     XOR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_XORLONG:
            	; AR=		CX
            	; AX=		AX ^ AR
            	; AR=		BX
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHL_AX_CX(void)
            ;
            ; note:
            ;     left shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHL_AX_CX:
            	; jmp		@shlac_label_1653
            ; @shlac_loop_1653:
            	; slz		AX, 1
            ; @shlac_label_1653:
            	; loop		@shlac_loop_1653
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SHLLONG(void)
            ;
            ; note:
            ;     left shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHLLONG:
            	; jmp		@shllong_label_1653
            ; @shllong_loop_1653:
            	; slz		AX, 1
            	; slc		DX, 1
            ; @shllong_label_1653:
            	; loop		@shllong_loop_1653
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX_CX(void)
            ;
            ; note:
            ;     unsigned right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX_CX:
            	; jmp		@shrac_label_1657
            ; @shrac_loop_1657:
            	; clr		C
            	; src		AX, 1
            ; @shrac_label_1657:
            	; loop		@shrac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX_CX(void)
            ;
            ; note:
            ;     signed right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX_CX:
            	; jmp		@sarac_label_1657
            ; @sarac_loop_1657:
            	; sra		AX, 1
            ; @sarac_label_1657:
            	; loop		@sarac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SARLONG(void)
            ;
            ; note:
            ;     signed right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SARLONG:
            	; jmp		@sarlong_label_1657
            ; @sarlong_loop_1657:
            	; sra		DX, 1
            	; src		AX, 1
            ; @sarlong_label_1657:
            	; loop		@sarlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHRLONG(void)
            ;
            ; note:
            ;     unsigned right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- ulong data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHRLONG:
            	; jmp		@shrlong_label_1657
            ; @shrlong_loop_1657:
            	; clr		C
            	; src		DX, 1
            	; src		AX, 1
            ; @shrlong_label_1657:
            	; loop		@shrlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX(void)
            ;
            ; note:
            ;     unsigned right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX:
            	; clr		C
            	; src		AX, 1
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX(void)
            ;
            ; note:
            ;     signed right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX:
            	; sra		AX, 1
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG(void)
            ; void sfx_STORSILONG_D(void)		; for function's parameter
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG:
            ; sfx_STORSILONG_D:
            	; rm[I1++]=	AX
            	; rm[I1--]=	DX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG_BXCX(void)
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG_BXCX:
            	; rm[I1++]=	CX
            	; rm[I1--]=	BX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG:
01554:      	pm[P1++]=	AX
01555:      	pm[P1--]=	DX
01556:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG_BXCX:
01557:      	pm[P1++]=	CX
01558:      	pm[P1--]=	BX
01559:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CX to BX
            ;
            ; in:
            ;     CX	- signed short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_CX:
            ; sfx_INT2ULONG_CX:
            	; BX=		0
            	; test		CX.b15
            	; if ZR jmp	@i2lcx_label_1756
            	; BX=		-1
            ; @i2lcx_label_1756:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_CX(void)
            ;
            ; note:
            ;     convert short unsigned value CX to long (BX:CX)
            ;
            ; in:
            ;     CX	- unsigned short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_CX:
            ; sfx_UINT2ULONG_CX:
            	; BX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CL to BX:CH
            ;
            ; in:
            ;     CX	- signed char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_CX:
0155A:      	BX=		0
0155B:      	CX.h=		0
0155C:      	test		CX.b7
0155D:      	if ZR jmp	@c2lcx_label_1800
0155E:      	CX.h=		0xFF
0155F:      	BX=		-1
            @c2lcx_label_1800:
01560:      	rets
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_CX(void)
            ;
            ; note:
            ;     convert unsigned char value CL to long (BX:CX)
            ;
            ; in:
            ;     CL	- unsigned char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_CX:
            	; CX.h=		0
            	; BX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AX to DX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_AX:
            ; sfx_INT2ULONG_AX:
            	; DX=		0
            	; test		AX.b15
            	; if ZR jmp	@i2lax_label_1756
            	; DX=		-1
            ; @i2lax_label_1756:
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_AX(void)
            ;
            ; note:
            ;     convert short unsigned value AX to long (DX:AX)
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_AX:
            ; sfx_UINT2ULONG_AX:
            	; DX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AL to DX:AH
            ;
            ; in:
            ;     AX	- signed char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_AX:
01561:      	DX=		0
01562:      	AX.h=		0
01563:      	test		AX.b7
01564:      	if ZR jmp	@c2lax_label_1800
01565:      	AX.h=		0xFF
01566:      	DX=		-1
            @c2lax_label_1800:
01567:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_AX(void)
            ;
            ; note:
            ;     convert unsigned char value AL to long (DX:AX)
            ;
            ; in:
            ;     AL	- unsigned char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_AX:
            	; AX.h=		0
            	; DX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CALL_BY_AX(void)
            ;
            ; note:
            ;     call sub routine in AX (address)
            ;
            ; in:
            ;     AX	- sub routine address
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_CALL_BY_AX:
            	; AR=		AX
            	; P1=		AR
            	; P1.hh=		0
            	; fjmp		pm[P1]
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHG_AX_CX(void)
            ;
            ; note:
            ;     exchange AX CX value
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; result:
            ;     AX <-> CX
            ;
            ; --------------------------------------------
            ; sfx_XCHG_AX_CX:
            	; push		AX
            	; push		CX
            	; pop		AX
            	; pop		CX
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHGLONG(void)
            ;
            ; note:
            ;     exchange DX:AX BX:CX value
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; result:
            ;     DX:AX <-> BX:CX
            ;
            ; --------------------------------------------
            sfx_XCHGLONG:
01568:      	push		AX
01569:      	push		CX
0156A:      	pop		AX
0156B:      	pop		CX
0156C:      	push		DX
0156D:      	push		BX
0156E:      	pop		DX
0156F:      	pop		BX
01570:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEG_AX(void)
            ;
            ; note:
            ;     negative AX
            ;
            ; in:
            ;     AX	- operator 1
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEG_AX:
            	; AR=		0
            	; AX=		AR - AX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEGLONG(void)
            ;
            ; note:
            ;     negative DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEGLONG:
            	; AR=		0
            	; AX=		AR - AX
            	; DX=		AR - DX + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOT_AX(void)
            ;
            ; note:
            ;     not AX
            ;
            ; in:
            ;     AX	- operator
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOT_AX:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOTLONG(void)
            ;
            ; note:
            ;     not DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOTLONG:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOT_AX(void)
            ;
            ; note:
            ;     logical NOT
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_LOGNOT_AX:
            	;; x86 code
            	;;   neg AX
            	;;   sbb AX,AX
            	;;   inc AX
            	; AR=		0
            	; AR=		AR - AX
            	; AX=		AR
            	; AX=		AR - AX + C - 1
            	; AX++
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOTLONG(void)
            ;
            ; note:
            ;     logical NOT (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            sfx_LOGNOTLONG:
            	; x86 code
            	;   neg AX
            	;   sbb AX,AX
            	;   inc AX
01571:      	AR=		DX
01572:      	DX=		0
01573:      	AR=		AR | AX
01574:      	AX=		1
01575:      	if ZR jmp	@longnotl_label_1120
01576:      	AX=		0
            @longnotl_label_1120:
01577:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOL_AX(void)
            ;
            ; note:
            ;     logical BOOL
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOL_AX:
            	;; x86 code
            	;;   neg ax
            	;;   sbb ax,ax
            	;;   neg ax
            	; AR=		AX
            	; AX=		0
            	; if ZR jmp	@boolax_label_1758
            	; AX=		1
            ; @boolax_label_1758:
            	; rets
            	
            	; AR=		-1
            	; AR=		AR + AX
            	; AX=		0
            	; AX += C
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOLLONG(void)
            ;
            ; note:
            ;     logical BOOL (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOLLONG:
            	; AR=		DX
            	; DX=		0
            	; AR=		AR | AX
            	; AX=		0
            	; if ZR jmp	@boollong_label_1801
            	; AX=		1
            ; @boollong_label_1801:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INITSISTOR(void)
            ;
            ; note:
            ;     for used in global/local variable initial
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     I1 + 1
            ;
            ; --------------------------------------------
            ; sfx_INITSISTOR:
            	; rm[I1++]=	AX
            	; rets
            
            ; --------------------------------------------
            
            ; sfx_INITSISTORLONG:
            	; rm[I1++]=	AX
            	; rm[I1++]=	DX
            	; rets
            
            
            ; ~~ condition assistant functions ~~
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; JNE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            sfx_CMP_AX_CX_U_JNE:
01578:      	DX=		0
01579:      	BX=		0
            sfx_CMPLONG_JNE:
0157A:      	AR=		CX
0157B:      	AX=		AX - AR
0157C:      	AR=		BX
0157D:      	AR=		DX - AR + C - 1
0157E:      	AR=		AR | AX
0157F:      	if EQ jmp	@sfx_cl_jne_f
01580:      	set		Z		; true
01581:      	rets
            @sfx_cl_jne_f:
01582:      	clr		Z		; false
01583:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JNE:
01584:      	DX=		0
01585:      	BX=		0
            sfx_CMPLONG_BCDA_JNE:
01586:      	AR=		AX
01587:      	CX=		CX - AR
01588:      	AR=		DX
01589:      	AR=		BX - AR + C - 1
0158A:      	AR=		AR | CX
0158B:      	if EQ jmp	@sfx_clbcda_jne_f
0158C:      	set		Z		; true
0158D:      	rets
            @sfx_clbcda_jne_f:
0158E:      	clr		Z		; false
0158F:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JNE:
01590:      	AR=		CX
01591:      	SF=		AX - AR
01592:      	if EQ jmp	@sfx_ac_jne_f
01593:      	set		Z
01594:      	rets
            @sfx_ac_jne_f:
01595:      	clr		Z
01596:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JNE:
01597:      	AR=		AX
01598:      	SF=		CX - AR
01599:      	if EQ jmp	@sfx_ca_jne_f
0159A:      	set		Z
0159B:      	rets
            @sfx_ca_jne_f:
0159C:      	clr		Z
0159D:      	rets
            
            
            
            ; JE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            
            
            sfx_CMP_AX_CX_U_JE:
0159E:      	DX=		0
0159F:      	BX=		0
            sfx_CMPLONG_JE:
015A0:      	AR=		CX
015A1:      	AX=		AX - AR
015A2:      	AR=		BX
015A3:      	AR=		DX - AR + C - 1
015A4:      	AR=		AR | AX
015A5:      	if NE jmp	@sfx_cl_jz_f
015A6:      	set		Z		; true
015A7:      	rets
            @sfx_cl_jz_f:
015A8:      	clr		Z		; false
015A9:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JE:
015AA:      	DX=		0
015AB:      	BX=		0
            sfx_CMPLONG_BCDA_JE:
015AC:      	AR=		AX
015AD:      	CX=		CX - AR
015AE:      	AR=		DX
015AF:      	AR=		BX - AR + C - 1
015B0:      	AR=		AR | CX
015B1:      	if NE jmp	@sfx_clbcda_jz_f
015B2:      	set		Z		; true
015B3:      	rets
            @sfx_clbcda_jz_f:
015B4:      	clr		Z		; false
015B5:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JE:
015B6:      	AR=		CX
015B7:      	SF=		AX - AR
015B8:      	if NE jmp	@sfx_ac_je_f
015B9:      	set		Z
015BA:      	rets
            @sfx_ac_je_f:
015BB:      	clr		Z
015BC:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JE:
015BD:      	AR=		AX
015BE:      	SF=		CX - AR
015BF:      	if NE jmp	@sfx_ca_je_f
015C0:      	set		Z
015C1:      	rets
            @sfx_ca_je_f:
015C2:      	clr		Z
015C3:      	rets
            
            
            
            ; JG group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; A - above (unsigned)
            ; G - greater (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JA:
            sfx_CMP_AX_CX_JA:
015C4:      	DX=		0
015C5:      	BX=		0
            sfx_CMPLONG_JG:
015C6:      	AR=		CX
015C7:      	AX=		AX - AR
015C8:      	AR=		BX
015C9:      	AR=		DX - AR + C - 1
015CA:      	if AN jmp	@sfx_cl_jg_f
            
            	; exclude EQU condition
015CB:      	AR=		AR | AX
015CC:      	if ZR jmp	@sfx_cl_jg_f
            
015CD:      	set		Z		; true
015CE:      	rets
            @sfx_cl_jg_f:
015CF:      	clr		Z		; false
015D0:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JA:
015D1:      	AR=		CX
015D2:      	AX=		AX - AR
015D3:      	AR=		BX
015D4:      	DX=		DX - AR + C - 1
015D5:      	AR=		0
015D6:      	AR=		AR - 0 + C - 1
015D7:      	if AN jmp	@sfx_cl_jg_f
            
015D8:      	AR=		AR | DX		; exclude EQU condition
015D9:      	AR=		AR | AX
015DA:      	if ZR jmp	@sfx_cl_jg_f
            
015DB:      	set		Z		; true
015DC:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JA:
            sfx_CMP_CX_AX_JA:
015DD:      	DX=		0
015DE:      	BX=		0
            sfx_CMPLONG_BCDA_JG:
015DF:      	AR=		AX
015E0:      	CX=		CX - AR
015E1:      	AR=		DX
015E2:      	AR=		BX - AR + C - 1
015E3:      	if AN jmp	@sfx_clbcda_jg_f
            
015E4:      	AR=		AR | CX		; exclude EQU condition
015E5:      	if ZR jmp	@sfx_clbcda_jg_f
            
015E6:      	set		Z		; true
015E7:      	rets
            @sfx_clbcda_jg_f:
015E8:      	clr		Z		; false
015E9:      	rets
            
            ; ~~---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JA:
015EA:      	AR=		AX
015EB:      	CX=		CX - AR
015EC:      	AR=		DX
015ED:      	BX=		BX - AR + C - 1
015EE:      	AR=		0
015EF:      	AR=		AR - 0 + C - 1
015F0:      	if AN jmp	@sfx_clbcda_jg_f
            
015F1:      	AR=		AR | BX		; exclude EQU condition
015F2:      	AR=		AR | CX
015F3:      	if ZR jmp	@sfx_clbcda_jg_f
            
015F4:      	set		Z		; true
015F5:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JG:
015F6:      	AR=		CX
015F7:      	SF=		AX - AR
015F8:      	if LE jmp	@sfx_cmp_ac_jg_f
015F9:      	set		Z
015FA:      	rets
            @sfx_cmp_ac_jg_f:
015FB:      	clr		Z
015FC:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JG:
015FD:      	AR=		AX
015FE:      	SF=		CX - AR
015FF:      	if LE jmp	@sfx_cmp_ca_jg_f
01600:      	set		Z
01601:      	rets
            @sfx_cmp_ca_jg_f:
01602:      	clr		Z
01603:      	rets
            
            
            ; JGE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JAE:
            sfx_CMP_AX_CX_JAE:
01604:      	DX=		0
01605:      	BX=		0
            sfx_CMPLONG_JGE:
01606:      	AR=		CX
01607:      	AX=		AX - AR
01608:      	AR=		BX
01609:      	DX=		DX - AR + C - 1
0160A:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
            
0160B:      	set		Z		; true
0160C:      	rets
            @sfx_cl_jge_f:
0160D:      	clr		Z		; false
0160E:      	rets
            
            ; ~~-----------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JAE:
0160F:      	AR=		CX
01610:      	AX=		AX - AR
01611:      	AR=		BX
01612:      	DX=		DX - AR + C - 1
01613:      	AR=		0
01614:      	AR=		AR - 0 + C - 1
01615:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
01616:      	set		Z		; true
01617:      	rets
            
            ; ---------
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JAE:
            sfx_CMP_CX_AX_JAE:
01618:      	DX=		0
01619:      	BX=		0
            sfx_CMPLONG_BCDA_JGE:
0161A:      	AR=		AX
0161B:      	CX=		CX - AR
0161C:      	AR=		DX
0161D:      	BX=		BX - AR + C - 1
0161E:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
            
0161F:      	set		Z		; true
01620:      	rets
            @sfx_clbcda_jge_f:
01621:      	clr		Z		; false
01622:      	rets
            
            ; ---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JAE:
01623:      	AR=		AX
01624:      	CX=		CX - AR
01625:      	AR=		DX
01626:      	BX=		BX - AR + C - 1
01627:      	AR=		0
01628:      	AR=		AR - 0 + C - 1
01629:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
0162A:      	set		Z		; true
0162B:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JGE:
0162C:      	AR=		CX
0162D:      	SF=		AX - AR
0162E:      	if AN jmp	@sfx_cmp_ac_jge_f
0162F:      	set		Z
01630:      	rets
            @sfx_cmp_ac_jge_f:
01631:      	clr		Z
01632:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JGE:
01633:      	AR=		AX
01634:      	SF=		CX - AR
01635:      	if AN jmp	@sfx_cmp_ca_jge_f
01636:      	set		Z
01637:      	rets
            @sfx_cmp_ca_jge_f:
01638:      	clr		Z
01639:      	rets
            
            
            ; JL group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; B - below (unsigned)
            ; L - less (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JB:
            sfx_CMP_AX_CX_JB:
0163A:      	DX=		0
0163B:      	BX=		0
            sfx_CMPLONG_JL:
0163C:      	AR=		CX
0163D:      	AX=		AX - AR
0163E:      	AR=		BX
0163F:      	AR=		DX - AR + C - 1
01640:      	if AN jmp	@sfx_cl_jl_chk
            
            @sfx_cl_jl_f:
01641:      	clr		Z		; false
01642:      	rets
            
            @sfx_cl_jl_chk:
01643:      	AR=		AR | AX		; exclude EQU condition
01644:      	if ZR jmp	@sfx_cl_jl_f
01645:      	set		Z
01646:      	rets
            
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JB:
01647:      	AR=		CX
01648:      	AX=		AX - AR
01649:      	AR=		BX
0164A:      	DX=		DX - AR + C - 1
0164B:      	AR=		0
0164C:      	AR=		AR - 0 + C - 1
0164D:      	if AN jmp	@sfx_cl_jb_chk
            
            @sfx_cl_jb_f:
0164E:      	clr		Z		; false
0164F:      	rets
            
            @sfx_cl_jb_chk:
01650:      	AR=		AR | DX
01651:      	AR=		AR | AX		; exclude EQU condition
01652:      	if ZR jmp	@sfx_cl_jb_f
01653:      	set		Z
01654:      	rets
            
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JB:
            sfx_CMP_CX_AX_JB:
01655:      	DX=		0
01656:      	BX=		0
            sfx_CMPLONG_BCDA_JL:
01657:      	AR=		AX
01658:      	CX=		CX - AR
01659:      	AR=		DX
0165A:      	AR=		BX - AR + C - 1
0165B:      	if AN jmp	@sfx_clbcda_jl_chk
            
            @sfx_clbcda_jl_f:
0165C:      	clr		Z		; false
0165D:      	rets
            
            @sfx_clbcda_jl_chk:
0165E:      	AR=		AR | CX		; exclude EQU condition
0165F:      	if ZR jmp	@sfx_clbcda_jl_f
01660:      	set		Z		; true
01661:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JB:
01662:      	AR=		AX
01663:      	CX=		CX - AR
01664:      	AR=		DX
01665:      	BX=		BX - AR + C - 1
01666:      	AR=		0
01667:      	AR=		AR - 0 + C - 1
01668:      	if AN jmp	@sfx_clbcda_jb_chk
            
            @sfx_clbcda_jb_f:
01669:      	clr		Z		; false
0166A:      	rets
            
            @sfx_clbcda_jb_chk:
0166B:      	AR=		AR | CX
0166C:      	AR=		AR | BX
0166D:      	if ZR jmp	@sfx_clbcda_jb_f
0166E:      	set		Z		; true
0166F:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JL:
01670:      	AR=		CX
01671:      	SF=		AX - AR
01672:      	if GE jmp	@sfx_cmp_ac_jl_f
01673:      	set		Z
01674:      	rets
            @sfx_cmp_ac_jl_f:
01675:      	clr		Z
01676:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JL:
01677:      	AR=		AX
01678:      	SF=		CX - AR
01679:      	if GE jmp	@sfx_cmp_ca_jl_f
0167A:      	set		Z
0167B:      	rets
            @sfx_cmp_ca_jl_f:
0167C:      	clr		Z
0167D:      	rets
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JBE:
            sfx_CMP_AX_CX_JBE:
0167E:      	DX=		0
0167F:      	BX=		0
            sfx_CMPLONG_JLE:
01680:      	AR=		CX
01681:      	AX=		AX - AR
01682:      	AR=		BX
01683:      	AR=		DX - AR + C - 1
01684:      	if AN jmp	@sfx_cl_jle_t
            
01685:      	AR=		AR | AX		; include EQU condition
01686:      	if ZR jmp	@sfx_cl_jle_t
            
01687:      	clr		Z		; false
01688:      	rets
            @sfx_cl_jle_t:
01689:      	set		Z		; true
0168A:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JBE:
0168B:      	AR=		CX
0168C:      	AX=		AX - AR
0168D:      	AR=		BX
0168E:      	DX=		DX - AR + C - 1
0168F:      	AR=		0
01690:      	AR=		AR - 0 + C - 1
01691:      	if AN jmp	@sfx_cl_jle_t
            
01692:      	AR=		AR | DX
01693:      	AR=		AR | AX
01694:      	if ZR jmp	@sfx_cl_jle_t
            
01695:      	clr		Z		; false
01696:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JBE:
            sfx_CMP_CX_AX_JBE:
01697:      	DX=		0
01698:      	BX=		0
            sfx_CMPLONG_BCDA_JLE:
01699:      	AR=		AX
0169A:      	CX=		CX - AR
0169B:      	AR=		DX
0169C:      	AR=		BX - AR + C - 1
0169D:      	if AN jmp	@sfx_clbcda_jle_t
            
0169E:      	AR=		AR | CX		; include EQU condition
0169F:      	if ZR jmp	@sfx_clbcda_jle_t
            
016A0:      	clr		Z		; false
016A1:      	rets
            @sfx_clbcda_jle_t:
016A2:      	set		Z		; true
016A3:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JBE:
016A4:      	AR=		AX
016A5:      	CX=		CX - AR
016A6:      	AR=		DX
016A7:      	BX=		BX - AR + C - 1
016A8:      	AR=		0
016A9:      	AR=		AR - 0 + C - 1
016AA:      	if AN jmp	@sfx_clbcda_jle_t
            
016AB:      	AR=		AR | BX
016AC:      	AR=		AR | CX
016AD:      	if ZR jmp	@sfx_clbcda_jle_t
            
016AE:      	clr		Z		; false
016AF:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JLE:
016B0:      	AR=		CX
016B1:      	SF=		AX - AR
016B2:      	if LE jmp	@sfx_cmp_ac_jl_t
016B3:      	clr		Z
016B4:      	rets
            @sfx_cmp_ac_jl_t:
016B5:      	set		Z
016B6:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JLE:
016B7:      	AR=		AX
016B8:      	SF=		CX - AR
016B9:      	if LE jmp	@sfx_cmp_ca_jl_t
016BA:      	clr		Z
016BB:      	rets
            @sfx_cmp_ca_jl_t:
016BC:      	set		Z
016BD:      	rets
            
            
            ; ~!~ bit-field support
            
            @sfx_ortable_0:
016BE:      	DW 0xFFFE
            @sfx_ortable_1:
016BF:      	DW 0xFFFC
            @sfx_ortable_2:
016C0:      	DW 0xFFF8
            @sfx_ortable_3:
016C1:      	DW 0xFFF0
            @sfx_ortable_4:
016C2:      	DW 0xFFE0
            @sfx_ortable_5:
016C3:      	DW 0xFFC0
            @sfx_ortable_6:
016C4:      	DW 0xFF80
            @sfx_ortable_7:
016C5:      	DW 0xFF00
            @sfx_ortable_8:
016C6:      	DW 0xFE00
            @sfx_ortable_9:
016C7:      	DW 0xFC00
            @sfx_ortable_10:
016C8:      	DW 0xF800
            @sfx_ortable_11:
016C9:      	DW 0xF000
            @sfx_ortable_12:
016CA:      	DW 0xE000
            @sfx_ortable_13:
016CB:      	DW 0xC000
            @sfx_ortable_14:
016CC:      	DW 0x8000
            
            ; ~!~
            
            @sfx_orhigh:
016CD:      	AR=		pm[P1]
016CE:      	DX=		DX | AR
016CF:      	rets
            
            @sfx_orhigh_dx:
016D0:      	DX=		-1
            @sfx_orlow:
016D1:      	AR=		pm[P1]
016D2:      	AX=		AX | AR
            @sfx_sextw_rets:
016D3:      	rets
            
            ; ~!~ signed short
            
            sfx_SignExtW0:
016D4:      	P1=		#@sfx_ortable_0
016D7:      	test		AX.b0
016D8:      	if ZR jmp	@sfx_sextw_rets
016D9:      	jmp		@sfx_orlow
            
            sfx_SignExtW1:
016DA:      	P1=		#@sfx_ortable_1
016DD:      	test		AX.b1
016DE:      	if ZR jmp	@sfx_sextw_rets
016DF:      	jmp		@sfx_orlow
            
            sfx_SignExtW2:
016E0:      	P1=		#@sfx_ortable_2
016E3:      	test		AX.b2
016E4:      	if ZR jmp	@sfx_sextw_rets
016E5:      	jmp		@sfx_orlow
            
            sfx_SignExtW3:
016E6:      	P1=		#@sfx_ortable_3
016E9:      	test		AX.b3
016EA:      	if ZR jmp	@sfx_sextw_rets
016EB:      	jmp		@sfx_orlow
            
            sfx_SignExtW4:
016EC:      	P1=		#@sfx_ortable_4
016EF:      	test		AX.b4
016F0:      	if ZR jmp	@sfx_sextw_rets
016F1:      	jmp		@sfx_orlow
            
            sfx_SignExtW5:
016F2:      	P1=		#@sfx_ortable_5
016F5:      	test		AX.b5
016F6:      	if ZR jmp	@sfx_sextw_rets
016F7:      	jmp		@sfx_orlow
            
            sfx_SignExtW6:
016F8:      	P1=		#@sfx_ortable_6
016FB:      	test		AX.b6
016FC:      	if ZR jmp	@sfx_sextw_rets
016FD:      	jmp		@sfx_orlow
            
            sfx_SignExtW7:
016FE:      	P1=		#@sfx_ortable_7
01701:      	test		AX.b7
01702:      	if ZR jmp	@sfx_sextw_rets
01703:      	jmp		@sfx_orlow
            
            sfx_SignExtW8:
01704:      	P1=		#@sfx_ortable_8
01707:      	test		AX.b8
01708:      	if ZR jmp	@sfx_sextw_rets
01709:      	jmp		@sfx_orlow
            
            sfx_SignExtW9:
0170A:      	P1=		#@sfx_ortable_9
0170D:      	test		AX.b9
0170E:      	if ZR jmp	@sfx_sextw_rets
0170F:      	jmp		@sfx_orlow
            
            sfx_SignExtW10:
01710:      	P1=		#@sfx_ortable_10
01713:      	test		AX.b10
01714:      	if ZR jmp	@sfx_sextw_rets
01715:      	jmp		@sfx_orlow
            
            sfx_SignExtW11:
01716:      	P1=		#@sfx_ortable_11
01719:      	test		AX.b11
0171A:      	if ZR jmp	@sfx_sextw_rets
0171B:      	jmp		@sfx_orlow
            
            sfx_SignExtW12:
0171C:      	P1=		#@sfx_ortable_12
0171F:      	test		AX.b12
01720:      	if ZR jmp	@sfx_sextw_rets
01721:      	jmp		@sfx_orlow
            
            sfx_SignExtW13:
01722:      	P1=		#@sfx_ortable_13
01725:      	test		AX.b13
01726:      	if ZR jmp	@sfx_sextw_rets
01727:      	jmp		@sfx_orlow
            
            sfx_SignExtW14:
01728:      	P1=		#@sfx_ortable_14
0172B:      	test		AX.b14
0172C:      	if ZR jmp	@sfx_sextw_rets
0172D:      	jmp		@sfx_orlow
            
            ; ~!~ signed long
            
            sfx_SignExtL0:
0172E:      	P1=		#@sfx_ortable_0
01731:      	test		AX.b0
01732:      	if ZR jmp	@sfx_sextw_rets
01733:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL1:
01734:      	P1=		#@sfx_ortable_1
01737:      	test		AX.b1
01738:      	if ZR jmp	@sfx_sextw_rets
01739:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL2:
0173A:      	P1=		#@sfx_ortable_2
0173D:      	test		AX.b2
0173E:      	if ZR jmp	@sfx_sextw_rets
0173F:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL3:
01740:      	P1=		#@sfx_ortable_3
01743:      	test		AX.b3
01744:      	if ZR jmp	@sfx_sextw_rets
01745:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL4:
01746:      	P1=		#@sfx_ortable_4
01749:      	test		AX.b4
0174A:      	if ZR jmp	@sfx_sextw_rets
0174B:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL5:
0174C:      	P1=		#@sfx_ortable_5
0174F:      	test		AX.b5
01750:      	if ZR jmp	@sfx_sextw_rets
01751:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL6:
01752:      	P1=		#@sfx_ortable_6
01755:      	test		AX.b6
01756:      	if ZR jmp	@sfx_sextw_rets
01757:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL7:
01758:      	P1=		#@sfx_ortable_7
0175B:      	test		AX.b7
0175C:      	if ZR jmp	@sfx_sextw_rets
0175D:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL8:
0175E:      	P1=		#@sfx_ortable_8
01761:      	test		AX.b8
01762:      	if ZR jmp	@sfx_sextw_rets
01763:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL9:
01764:      	P1=		#@sfx_ortable_9
01767:      	test		AX.b9
01768:      	if ZR jmp	@sfx_sextw_rets
01769:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL10:
0176A:      	P1=		#@sfx_ortable_10
0176D:      	test		AX.b10
0176E:      	if ZR jmp	@sfx_sextw_rets
0176F:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL11:
01770:      	P1=		#@sfx_ortable_11
01773:      	test		AX.b11
01774:      	if ZR jmp	@sfx_sextw_rets
01775:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL12:
01776:      	P1=		#@sfx_ortable_12
01779:      	test		AX.b12
0177A:      	if ZR jmp	@sfx_sextw_rets
0177B:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL13:
0177C:      	P1=		#@sfx_ortable_13
0177F:      	test		AX.b13
01780:      	if ZR jmp	@sfx_sextw_rets
01781:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL14:
01782:      	P1=		#@sfx_ortable_14
01785:      	test		AX.b14
01786:      	if ZR jmp	@sfx_sextw_rets
01787:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL15:
01788:      	test		AX.b15
01789:      	if ZR jmp	@sfx_sextw_rets
0178A:      	DX=		-1
0178B:      	rets
            
            sfx_SignExtL16:
0178C:      	P1=		#@sfx_ortable_0
0178F:      	test		DX.b0
01790:      	if ZR jmp	@sfx_sextw_rets
01791:      	jmp		@sfx_orhigh
            
            sfx_SignExtL17:
01792:      	P1=		#@sfx_ortable_1
01795:      	test		DX.b1
01796:      	if ZR jmp	@sfx_sextw_rets
01797:      	jmp		@sfx_orhigh
            
            sfx_SignExtL18:
01798:      	P1=		#@sfx_ortable_2
0179B:      	test		DX.b2
0179C:      	if ZR jmp	@sfx_sextw_rets
0179D:      	jmp		@sfx_orhigh
            
            sfx_SignExtL19:
0179E:      	P1=		#@sfx_ortable_3
017A1:      	test		DX.b3
017A2:      	if ZR jmp	@sfx_sextw_rets
017A3:      	jmp		@sfx_orhigh
            
            sfx_SignExtL20:
017A4:      	P1=		#@sfx_ortable_4
017A7:      	test		DX.b4
017A8:      	if ZR jmp	@sfx_sextw_rets
017A9:      	jmp		@sfx_orhigh
            
            sfx_SignExtL21:
017AA:      	P1=		#@sfx_ortable_5
017AD:      	test		DX.b5
017AE:      	if ZR jmp	@sfx_sextw_rets
017AF:      	jmp		@sfx_orhigh
            
            sfx_SignExtL22:
017B0:      	P1=		#@sfx_ortable_6
017B3:      	test		DX.b6
017B4:      	if ZR jmp	@sfx_sextw_rets
017B5:      	jmp		@sfx_orhigh
            
            sfx_SignExtL23:
017B6:      	P1=		#@sfx_ortable_7
017B9:      	test		DX.b7
017BA:      	if ZR jmp	@sfx_sextw_rets
017BB:      	jmp		@sfx_orhigh
            
            sfx_SignExtL24:
017BC:      	P1=		#@sfx_ortable_8
017BF:      	test		DX.b8
017C0:      	if ZR jmp	@sfx_sextw_rets
017C1:      	jmp		@sfx_orhigh
            
            sfx_SignExtL25:
017C2:      	P1=		#@sfx_ortable_9
017C5:      	test		DX.b9
017C6:      	if ZR jmp	@sfx_sextw_rets
017C7:      	jmp		@sfx_orhigh
            
            sfx_SignExtL26:
017C8:      	P1=		#@sfx_ortable_10
017CB:      	test		DX.b10
017CC:      	if ZR jmp	@sfx_sextw_rets
017CD:      	jmp		@sfx_orhigh
            
            sfx_SignExtL27:
017CE:      	P1=		#@sfx_ortable_11
017D1:      	test		DX.b11
017D2:      	if ZR jmp	@sfx_sextw_rets
017D3:      	jmp		@sfx_orhigh
            
            sfx_SignExtL28:
017D4:      	P1=		#@sfx_ortable_12
017D7:      	test		DX.b12
017D8:      	if ZR jmp	@sfx_sextw_rets
017D9:      	jmp		@sfx_orhigh
            
            sfx_SignExtL29:
017DA:      	P1=		#@sfx_ortable_13
017DD:      	test		DX.b13
017DE:      	if ZR jmp	@sfx_sextw_rets
017DF:      	jmp		@sfx_orhigh
            
            sfx_SignExtL30:
017E0:      	P1=		#@sfx_ortable_14
017E3:      	test		DX.b14
017E4:      	if ZR jmp	@sfx_sextw_rets
017E5:      	jmp		@sfx_orhigh
            
            
            ; ~.~--------------------
            ; I1, AX
            
            sfx_REPMOV_SS:
            @sfx_repmov_ss_loop_1804:
017E6:      	push		I1
017E7:      	AR=		AX
017E8:      	I1=		AR
017E9:      	AR=		rm[I1]
017EA:      	pop		I1
017EB:      	rm[I1++]=	AR
017EC:      	AX++
017ED:      	loop		@sfx_repmov_ss_loop_1804
017EE:      	rets
            
            ; ~~
            
            sfx_REPMOV_SR:
017EF:      	AR=		AX
017F0:      	P1=		AR
            @sfx_repmov_sr_loop_1804:
017F1:      	rm[I1++]=	pm[P1++]
017F2:      	loop		@sfx_repmov_sr_loop_1804
017F3:      	rets
            
            
            ; ~~
            
            sfx_REPMOV_RS:
017F4:      	AR=		AX
017F5:      	I1=		AR
            @sfx_repmov_rs_loop_1804:
017F6:      	AR=		rm[I1++]
017F7:      	pm[P1++]=	AR
017F8:      	loop		@sfx_repmov_rs_loop_1804
017F9:      	rets
            
            ; ~~
            
            sfx_REPMOV_RR:
            @sfx_repmov_rr_loop_1804:
017FA:      	push		P1
017FB:      	AR=		AX
017FC:      	P1=		AR
017FD:      	AR=		pm[P1]
017FE:      	pop		P1
017FF:      	pm[P1++]=	AR
01800:      	AX++
01801:      	loop		@sfx_repmov_rr_loop_1804
01802:      	rets
            
            ; ~~
            
            ; sfx_CHECKZERO:
            	; AR=		AX
            	; rets
            
            ; ~~
            
            ; sfx_CHECKZEROLONG:
            	; AR=		AX
            	; AR=		AR | DX
            	; rets
            
            ; ~~
            
            
            #ifdef PRAM_BANK
            
            ;  ~~ simple link list for PRAM allocate
            
            ;  +---------+---------+
            ;  | field 0 | field 1 |
            ;  +---------+---------+
            ;  |   PROM  |  next   |
            ;  +---------+---------+
            
            sfx_DynFastCallInit:
            ; {
            	P1.hh=		PRAM_BANK
            	P1=		PRAM_OFFSET
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	rets
            ; }
            
            
            ; ~~ for C / ASM progam compatible used
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            ; bool sfx_DynFindPrg(PRGADR)
            ;
            ; in:
            ;    P1		- function start address
            ;
            ; out:
            ;     Z		- found, P0 = program entry address at PRAM
            ;     NZ	- not found, P0 = free space (list) start at PRAM
            ; ----------------------------------------------------------------
            
            sfx_DynFindPrg:
            ; {
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfp_loop_1320:
            	AR=		pm[P0++]	; program address
            	if ZR jmp	@sfxdfp_label_1321
            	SF=		AR - P1
            	if NE jmp	@sfxdfp_label_1323
            	
            	P0++
            	set		Z
            	rets
            
            @sfxdfp_label_1323:
            	AR=		pm[P0]		; next
            	P0=		0xFC00
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfp_label_1655
            	P0=		AR
            	jmp		@sfxdfp_loop_1320
            
            @sfxdfp_label_1321:
            	P0--				; list
            	clr		Z
            	rets
            	
            @sfxdfp_label_1655:
            ; ~~ list broken...
            	P0=		PRAM_OFFSET
            	clr		Z
            	rets
            ; }
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free link start
            ; AX = function end address
            
            
            sfx_DynBooking:
            ; {
            	; check if PRG to big to fit in PRAM
            
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	; ~~ can not cache PRG (total PRAM_SIZE) ??
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdb_label_1345
            
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdb_label_1349
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdb_label_1349:
            	; create link list
            
            	AR=		P1
            	pm[P0++]=	AR		; PRG
            	AR=		P0
            	AR=		AR - 3		; remove 1 list and 1 next
            	CX=		CX + AR
            	pm[P0++]=	CX		; next
            
            	push		P1
            	P1=		#@sfxdfc_label_1840
            	AR=		pm[P1]		; inst -> P1.hh = 0
            	pm[P0++]=	AR
            	AR=		CX
            	P1=		AR
            	P1.hh=		PRAM_BANK
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	pop		P1
            	
            	set		Z
            	rets
            
            @sfxdb_label_1345:
            	P0.hh=		0
            	clr		Z
            	rets
            ; }
            
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free PRG entry
            ; AX = function end address
            
            sfx_DynCache:
            	push		P0
            	AR=		AX
            	AR=		AR - P1
            	CX=		AR
            	jmp		@sfxdynch_label_1650
            @sfxdynch_loop_1650:
            	AR=		pm[P1++]
            	pm[P0++]=	AR
            @sfxdynch_label_1650:
            	loop		@sfxdynch_loop_1650
            	pop		P0
            	P0--
            	rets
            
            ; --------------------------------------------------------
            
            
            ; ~~ for C
            
            ; P1 = function start address
            ; AX = function end address
            
            sfx_DynFastCall:
            ; {
            	; look up function entry by prom address (P1)
            
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfc_label_1759:
            	AR=		pm[P0++]		; next
            	if ZR jmp	@sfxdfc_label_1758
            	SF=		AR - P1
            	if EQ jmp	@sfxdfc_label_1722
            	AR=		pm[P0]
            	P0=		0xFC00
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfc_label_2035
            	P0=		AR
            	jmp		@sfxdfc_label_1759
            
            @sfxdfc_label_2035:
            	P0=		PRAM_OFFSET + 1
            
            ; -----
            
            @sfxdfc_label_1758:
            
            	; look for remain free space
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	P0--
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdfc_label_1840
            	
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdfc_label_1817
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdfc_label_1817:
            
            	; copy program to pram
            
            	; ~~ PROM field
            		AR=		P1
            		pm[P0++]=	AR
            	; ~~ next field
            		AR=		P0
            		AR=		AR - 3		; remove 1 list and 1 next
            		CX=		CX + AR
            		pm[P0++]=	CX		; next
            
            	; ~~ booking
            		push		P1
            		P1=		#@sfxdfc_label_1840
            		AR=		pm[P1]		; inst -> P1.hh = 0
            		pm[P0++]=	AR
            		AR=		CX
            		P1=		AR
            		P1.hh=		PRAM_BANK
            		AR=		0
            		pm[P1++]=	AR
            		pm[P1]=		AR
            		P1.hh=		0
            		pop		P1
            
            	; copy instruction  "P0.hh = 0"
            		push		P0		; save exec address
            	@sfxdfc_loop_1829:
            		AR=		pm[P1++]
            		pm[P0++]=	AR
            		AR=		P0
            		SF=		AR - CX
            		if AN jmp	@sfxdfc_loop_1829
            		pop		P0
            		P0--
            		fjmp		pm[P0]
            
            @sfxdfc_label_1722:
            	P0++			; program entry
            	fjmp		pm[P0]
            
            @sfxdfc_label_1840:
            	P0.hh=		0
            
            @sfxdfc_label_1733:
            	; free space too small, direct run
            	fjmp		pm[P1]
            ; }
            
            
            
            
            #endif
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> End=========================
            
            
            
            // .code segment
            
            WAKEUP_PROC:
01803:      	PCH=	SYS_PROG_ENTRY
01804:      	ljmp	SYS_PROG_ENTRY
            
            IntVectTable:
01805:      	DW #EMPTY_INTENTRY
01806:      	DW #EMPTY_INTENTRY
01807:      	DW #EMPTY_INTENTRY
01808:      	DW #EMPTY_INTENTRY
01809:      	DW #EMPTY_INTENTRY
0180A:      	DW #Pwm_process
            
            // .code ends
            ;;FDSP-IDE V2.53
            _SYSTEM_MAIN_PROGRAM_END_ADDRESS: 
