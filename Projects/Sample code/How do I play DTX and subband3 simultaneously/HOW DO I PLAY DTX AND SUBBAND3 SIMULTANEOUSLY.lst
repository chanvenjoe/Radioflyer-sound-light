            ;=========================Include <OPTION.INC> Start=========================
            //--------------------------------------------------------------------------------------------------
            // TRITAN FDSP-IDE Option define file.
            // WARNING! All changes made in this file will be lost when recompiling.
            //--------------------------------------------------------------------------------------------------
            // Part number    : TRSF16127A
            // Option version : 2.2
            // Base Information--------------------------------------------------------------------------------
            #define       _OPT_TRSF16127A_                
            #define       _OPT_PROMSize_                0x20000   //PROM Size
            #define       _OPT_SRAMSize_                3072      //SRAM Size
            // I/O Configuration--------------------------------------------------------------------------------
            #define       _OPT_EXTReset_EN_             0         //EXT Reset Enable,0:Disable,1:Enable
            #define       _OPT_EXTINT1_EN_              0         //EXTINT1_EN,0:Disable,1:Enable
            #define       _OPT_EXTINT0_EN_              0         //EXTINT0_EN,0:Disable,1:Enable
            #define       _OPT_SpreadSpectrum_          0         //Spread Spectrum Enable,0:Disable,1:Enable
            #define       _OPT_EXTResetPin_             0         //EXT Reset Pin Select,0:PB3,1:PC3
            #define       _OPT_EXTINT1_INV_             0         //EXTINT1_INV,0:Disable,1:Enable
            #define       _OPT_EXTINT0_INV_             0         //EXTINT0_INV,0:Disable,1:Enable
            // Memory Configuration-----------------------------------------------------------------------------
            #define       _OPT_PRAMBank_                0         //PRAM Bank
            #define       _OPT_PRAMSize_                0         //PRAM Size(Words)
            #define       _OPT_WriteSegmentProtection_  0x0FFFF   //Write Segment Protection(0000H~ )
            // System Control Setup-----------------------------------------------------------------------------
            #define       _OPT_Bank0Speed_              11        //Bank0 Speed(MHz)
            #define       _OPT_RTCINT_                  1         //RTC interrupt,0:Disable,1:Enable
            #define       _OPT_RTCinHalt_               0         //RTC LP32K in Halt Mode,0:Disable,1:Enable
            #define       _OPT_LVR_                     2200      //LVR(mv)
            #define       _OPT_WatchDog_                256       //Watch dog(ms)
            #define       _OPT_ICEEnable_               1         //ICE Disable/Enable,0:Disable,1:Enable
            // Audio Configuration------------------------------------------------------------------------------
            #define       _OPT_AudioSamplingRate_       32        //Audio Sampling Rate(KHz)
            #define       _OPT_PWMBit_                  16        //PWM Bit
            #define       _OPT_DACFIFO_                 1         //DAC FIFO,0:Disable,1:Enable
            //--------------------------------------------------------------------------------------------------
            ;=========================Include <OPTION.INC> End=========================
            
            #define DSP_SRAM_SIZE		3072
            #define DSP_VECT_SUPPORT		6
            #define _PROJECT_CONFIG_FILE_		
            #define DTX_WORD_ADR		
            #define MIDIPCMDEC		
            #define _PWM_32K_		
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> Start=========================
            
            ; =====================
            ;      COMMON I/O
            ; =====================
            
            #ifdef _MFDSP_
            
            ; {
            	STATUS          EQU             00H             ;R/W, BIT0: Zero.
            							;R/W, BIT1: Carry.
            							;R/W, BIT2: Overflow.
            							;R/W, BIT3: Negative.
            							;R/W, BIT7: Global Interrupt Enable.
            							;R/W, BIT[12:8]: SD_EN, TRA_EN, ADH_EN, SPIS_EN, SPIM_EN.
            							;R/W, BIT13: Interrupt Vector Table Access Enable.
            							;R/W, BIT14: Filter Buffer Available.
            							;R/W, BIT15: Parser Buffer Available.
            
            	INTENA          EQU             01H             ;R/W, Int Enable.
            	INTREQ          EQU             02H             ;R/W, Int Request.
            	IntVect         EQU             03H             ;R/W, Interrupt Table
            	IOC_PA          EQU             04H             ;R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB          EQU             05H             ;R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PCI         EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PC          EQU             06H             ;R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA           EQU             07H             ;R/W, General input/output port.
            	PortB           EQU             08H             ;R/W, General input/output port.
            	PortCI          EQU             09H             ;R/W, General input/output port.
            	PortC           EQU             09H             ;R/W, General input/output port.
            	INTMASK         EQU             0AH             ;R/W, Int Mask.
            	SPIS_CTL        EQU             0BH             ;R/W, SPI slaver control register.
            	SPIS_DAT        EQU             0CH             ;R/W, SPI slaver data    register.
            	SPI_CTL         EQU             0DH             ;R/W, SPI master control register.
            	SPI_DAT         EQU             0EH             ;R/W, SPI master data    register.
            	SD_CTL          EQU             0FH             ;R/W, SD card interface control register.
            	SD_DAT          EQU             10H             ;R/W, SD card interface data.
            	SD_RSP          EQU             11H             ;R/W, SD card interface response register.
            	UART_CTL        EQU             12H
            	UART_DAT        EQU             13H
            	DPPWM           EQU             14H
            	//------------------------------------
            	PUPD_PA         EQU             15H             ;R/W, PortA  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	DACL            EQU             16H
            	DACR            EQU             17H
            	USB_CTL         EQU             18H
            	USB_DAT         EQU             19H
            	PUPD_PB         EQU             1AH             ;R/W, PortB  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	PUPD_PC         EQU             1BH             ;R/W, PortC  Pull-Up(b15~b8)/Pull-Down(b7~b0)
            	MISC            EQU             1CH
            	ClrWDT          EQU             1DH             ;W, Clear Watch-dog reset.
            	Real_T          EQU             1DH             ;R, System Real-Time Counter, base on 31.25us
            	IOP_IX          EQU             1EH             ;W, Programming IO Port index .
            	IOP_DAT         EQU             1FH             ;W, Programming IO Port Data .
            
            	//------------------------------------
            	// Virtual         Program IO Port
            	IOP_Timer1      EQU             00H
            	IOP_Timer2      EQU             01H
            	IOP_RTC32K      EQU             02H
            	IOP_PreScale    EQU             03H
            	IOP_FGREEN32K   EQU             04H
            	IOP_ODEN_PA     EQU             05H
            	IOP_ODEN_PB     EQU             06H
            	IOP_ODEN_PC     EQU             07H
            
            	IOP_TOUCH_CFG   EQU             08H
            	IOP_TOUCH_DAT   EQU             09H
            
            	IOP_CLK_CFG     EQU             0AH
            	IOP_CLK_DAT1    EQU             0BH
            	IOP_CLK_DAT2    EQU             0CH
            	IOP_CUR_PA      EQU             0DH
            	IOP_CUR_PB      EQU             0EH
            	IOP_CUR_PC      EQU             0FH
            
            	//------------------------------------
            	// IO[0x40-0x7F]
            	ADH_CFG0        EQU             40H
            	ADH_CFG1        EQU             41H
            	ADH_CFG2        EQU             42H
            	ADH_CFG3        EQU             43H
            	ADH_DO          EQU             44H
            
            	ADL_CFG         EQU             45H
            
            	TRA_CFG         EQU             46H
            	TRA_DAT         EQU             47H
            
            	I2C_CTL         EQU             48H
            	I2C_DAT         EQU             49H
            	I2C_CMD         EQU             4AH
            	I2C_SR          EQU             4AH             ; same as I2C_CMD
            
            	I80_CTL         EQU             4BH
            	I80_INX         EQU             4CH
            	I80_DAT         EQU             4DH
            	I80_RADR        EQU             4EH
            	I80_DMANUM      EQU             4FH
            
            	SD_DMA_CTL      EQU             50H
            	SD_DMA_RADR     EQU             51H
            	SD_DMA_DMANUM   EQU             52H
            
            	SPI_DMA_CTL     EQU             53H
            	SPI_DMA_RADR    EQU             54H
            	SPI_DMA_DMANUM  EQU             55H
            
            	USB_DMA_CTL     EQU             56H
            	USB_DMA_RADR    EQU             57H
            	USB_DMA_DMANUM  EQU             58H
            
            	SSC             EQU             63H
            	MIC             EQU             64H
            	GREEN           EQU             65H
            	SLEEP           EQU             66H
            	SPEED           EQU             67H
            	PR              EQU             68H
            
            	//------------------------------------
            	IOP_WAKEN_PA    EQU             10H
            	IOP_WAKEN_PB    EQU             11H
            	IOP_WAKEN_PC    EQU             12H
            ; }
            
            #endif
            
            
            
            
            #ifdef _MSPEECHDSP_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            
            #ifdef _MSPEECHDSP2_
            
            	STATUS		EQU    00H	 ; R/W, BIT0:  Zero.
            					 ; R/W, BIT1:  Carry.
            					 ; R/W, BIT2:  Overflow.
            					 ; R/W, BIT3:  Negative.
            					 ; R/W, BIT7:  Global Interrupt Enable.
            					 ; R/W, BIT8:  SPIM_EN.
            					 ; R/W, BIT13: Interrupt Vector Table Access Enable.
            					 ; R/W, BIT14: Filter Buffer Available.
            					 ; R/W, BIT15: Parser Buffer Available.
            
            	INTENA		EQU    01H	 ; R/W, Int Enable.
            	INTREQ		EQU    02H	 ; R/W, Int Request.
            	IntVect		EQU    03H	 ; R/W, Interrupt Table
            	IOC_PA		EQU    04H	 ; R/W, PortA IO control. ('0' = input,'1' = output)
            	IOC_PB		EQU    05H	 ; R/W, PortB IO control. ('0' = input,'1' = output)
            	IOC_PC		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	IOC_PCI		EQU    06H	 ; R/W, PortCI IO control. ('0' = input,'1' = output)
            	PortA		EQU    07H	 ; R/W, General input/output port.
            	PortB		EQU    08H	 ; R/W, General input/output port.
            	PortC		EQU    09H	 ; R/W, General input/output port.
            	PortCI		EQU    09H	 ; R/W, General input/output port.
            	INTMASK		EQU    0AH	 ; R/W, Int Mask.
            	DACL		EQU    16H
            	MISC5		EQU    18H	 ; R/W, Miscellanea register #5
            	MISC4		EQU    19H	 ; R/W, Miscellanea register #4
            	MISC3		EQU    1AH	 ; R/W, Miscellanea register #3
            	MISC2		EQU    1BH	 ; R/W, Miscellanea register #2
            	MISC		EQU    1CH	 ; R/W, Miscellanea register #1
            	ClrWDT		EQU    1DH	 ; W, Clear Watch-dog reset.
            	Real_T		EQU    1DH	 ; R, System Real-Time Counter, base on 31.25us
            	IOP_IX		EQU    1EH	 ; W, Programming IO Port index .
            	IOP_DAT		EQU    1FH	 ; W, Programming IO Port Data .
            
            	; Virtual Program IO Port
            	IOP_Timer1	EQU    00H
            	IOP_Timer2	EQU    01H
            	IOP_RTC32K	EQU    02H
            	IOP_FetchCNT	EQU    03H
            
            	IOP_PA_PD50K	EQU    05H
            	IOP_PB_PD50K	EQU    06H
            	IOP_PCI_PD50K	EQU    07H
            	IOP_PA_PD220K	EQU    08H
            	IOP_PB_PD220K	EQU    09H
            	IOP_PCI_PD220K	EQU    0AH
            	IOP_PA_PD1M	EQU    0BH
            	IOP_PB_PD1M	EQU    0CH
            	IOP_PCI_PD1M	EQU    0DH
            	IOP_PA_4MA	EQU    0EH
            	IOP_PB_4MA	EQU    0FH
            	IOP_PCI_4MA	EQU    10H
            	IOP_PA_WLOW	EQU    11H
            	IOP_PB_WLOW	EQU    12H
            	IOP_PCI_WLOW	EQU    13H
            	IOP_WAKEN_PA	EQU    14H
            	IOP_WAKEN_PB	EQU    15H
            	IOP_WAKEN_PC	EQU    16H
            	IOP_WAKELV_PA	EQU    17H
            	IOP_WAKELV_PB	EQU    18H
            	IOP_WAKELV_PC	EQU    19H
            	IOP_WAKEDLV_PB	EQU    1AH
            
            	; IO[0x40-0x7F]
            	ENC_DAT		EQU    54H
            	SPI_CTL		EQU    55H
            	SPI_DAT		EQU    56H
            	EP		EQU    5EH
            	SSC		EQU    63H
            	SPEED		EQU    67H
            #endif
            
            
            
            
            ;-----------------------------------------------------------
            
            #ifdef NO_OPTIMAL_RM
            
            
            #else
            
            #define Optimal_RM	; Optimal RAM function Enable
            
            #endif
            
            
            VarRM[0:127] = {
            BP_SAVE,
            
            }
            
            VarRM[128:511] = {
            
            }
            
            VarRM[512:4095] = {
            
            }
            
            ShareVar = {
            
            }
            
            ;--------------------------------------------------------------------
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.INC> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> Start=========================
            
            	org	0000h
            RSTB_ENTRY:
00000:      	PCH=		SYS_PROG_ENTRY
00001:      	ljmp		SYS_PROG_ENTRY
            
            
            	org	0004h
            WAKEUP_ENTRY:
00004:      	PCH=		WAKEUP_PROC
00005:      	ljmp		WAKEUP_PROC
            
            
            	org	0100h
            
            
            
            SYS_PROG_ENTRY:
            	; ~~ DSP initial
            
00100:      	dsi
00101:      	nop
00102:      	AR=		@STACKBOTTOM
00104:      	BP=		AR
00105:      	AR=		DSP_SRAM_SIZE
00107:      	AR--
00108:      	CX=		AR
00109:      	I1=		AR
0010A:      	AR=		0
            @clearram_loop_1705:
0010B:      	rm[I1--]=	AR
0010C:      	loop		@clearram_loop_1705
            
0010D:      	io[ClrWDT]=	AR
            
0010E:      	set		io[STATUS].b13
0010F:      	CX=		DSP_VECT_SUPPORT
00110:      	P1=		#IntVectTable
00113:      	jmp		@setintvect_label_1548
            @setintvect_loop_1548:
00114:      	AR=		pm[P1++]
00115:      	io[IntVect]=	AR
            @setintvect_label_1548:
00116:      	loop		@setintvect_loop_1548
            
00117:      	clr		io[STATUS].b13
            
            	; ~~ C code
            
            #ifdef PRAM_BANK
            	PCH=		sfx_DynFastCallInit
            	lcall		sfx_DynFastCallInit
            #endif
            
00118:      	PCH=		ginit_code
00119:      	lcall		ginit_code
            
0011A:      	PCH=		_main
0011B:      	lcall		_main
0011C:      	jmp		SYS_PROG_ENTRY
            
            
            /* ================================================================= */
            // ------------- Interrupt Service Routine--------------------------
            /* ================================================================= */
            
            EMPTY_INTENTRY:
0011D:      	reti
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\CRT0.ASM> End=========================
            
            ;=========================Include <DEPS\HOW DO I PLAY DTX AND SUBBAND3 SIMULTANEOUSLY_528516D5.S.CODE.ASM> Start=========================
            ; HOW DO I PLAY DTX AND SUBBAND3 SIMULTANEOUSLY.C Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _main();
            ; //rjmp void _KeyPlaySongC44FFB6D();
            ; //rjmp void _KeyPlayStop0C3B8DB1();
            ; //rjmp void _KeyPlayNextAFBA8CED();
            ; //rjmp void _KeyPlayPrev8E98A35A();
            ; //rjmp void _KeyModEEAB4D5A();
            ; //rjmp void _KeySubb3A3BA54B6D();
            ; //rjmp void _KeySubb3B3F6456DA();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _main()				
            _main:
            ; //{
            ; //_A5A7AA303_0:;					
            _A5A7AA303_0:
            ; //	
            ; //_A5A7AA303_1:;					
            _A5A7AA303_1:
            ; //_A5A7AA303_2:;					
            _A5A7AA303_2:
            ; //	_InitialDA4A7CC4();			
0011E:      	pch	= _InitialDA4A7CC4
0011F:      	lcall	_InitialDA4A7CC4
            ; //_A5A7AA303_3:;					
            _A5A7AA303_3:
            ; //_A5A7AA303_4:;					
            _A5A7AA303_4:
            ; //	_InitKey3C587B6D();			
00120:      	pch	= _InitKey3C587B6D
00121:      	lcall	_InitKey3C587B6D
            ; //_A5A7AA303_5:;					
            _A5A7AA303_5:
            ; //	asm set io[0x06].b0;			
00122:      	set io[0x06].b0//
            ; //_A5A7AA303_6:;					
            _A5A7AA303_6:
            ; //	asm set io[0x06].b1;			
00123:      	set io[0x06].b1//
            ; //_A5A7AA303_7:;					
            _A5A7AA303_7:
            ; //	asm clr io[0x09].b0;			
00124:      	clr io[0x09].b0//
            ; //_A5A7AA303_8:;					
            _A5A7AA303_8:
            ; //	asm clr io[0x09].b1;			
00125:      	clr io[0x09].b1//
            ; //_A5A7AA303_9:;					
            _A5A7AA303_9:
            ; //_A5A7AA303_10:;					
            _A5A7AA303_10:
            ; //	ChangePWMIntToDynCache();		
00126:      	pch	= ChangePWMIntToDynCache
00127:      	lcall	ChangePWMIntToDynCache
            ; //_A5A7AA303_11:;					
            _A5A7AA303_11:
            ; //_A5A7AA303_12:;					
            _A5A7AA303_12:
            ; //	dtxInitialize();			
00128:      	pch	= dtxInitialize
00129:      	lcall	dtxInitialize
            ; //L9FD7D12A_4:;					
            L9FD7D12A_4:
            ; //_A5A7AA303_13:;					
            _A5A7AA303_13:
            ; //_A5A7AA303_14:;					
            _A5A7AA303_14:
            ; //	asm AX = #melody+0;			
0012A:      	AX = #melody+0//
            ; //	asm DX = #melody.n2			
0012C:      	DX = #melody.n2
            ; //	asm set DX.b11				
0012D:      	set DX.b11
            ; //	_dtxFindToneEntry12F3B4ED(STACK[sSP + 0], STACK[sSP + 1]);
0012E:      	pch	= _dtxFindToneEntry12F3B4ED
0012F:      	lcall	_dtxFindToneEntry12F3B4ED
            ; //	sfx_CHECKZERO();			
00130:      	AR	= AX
            ; //	if(__jz__)	goto L9FD7D12A_5;	
00131:      	if ZR	jmp L9FD7D12A_5
            ; //	goto	L9FD7D12A_3;			
00132:      	jmp	L9FD7D12A_3
            ; //L9FD7D12A_5:;					
            L9FD7D12A_5:
            ; //	
            ; //L9FD7D12A_7:;					
            L9FD7D12A_7:
            ; //_A5A7AA303_15:;					
            _A5A7AA303_15:
            ; //	goto L9FD7D12A_7;			
00133:      	jmp	L9FD7D12A_7
            ; //L9FD7D12A_6:;					
            L9FD7D12A_6:
            ; //	goto L9FD7D12A_4;			
00134:      	jmp	L9FD7D12A_4
            ; //L9FD7D12A_3:;					
            L9FD7D12A_3:
            ; //_A5A7AA303_16:;					
            _A5A7AA303_16:
            ; //_A5A7AA303_17:;					
            _A5A7AA303_17:
            ; //	dtxInitParameters();			
00135:      	pch	= dtxInitParameters
00136:      	lcall	dtxInitParameters
            ; //_A5A7AA303_18:;					
            _A5A7AA303_18:
            ; //_A5A7AA303_19:;					
            _A5A7AA303_19:
            ; //	dtxReadTune();				
00137:      	pch	= dtxReadTune
00138:      	lcall	dtxReadTune
            ; //_A5A7AA303_20:;					
            _A5A7AA303_20:
            ; //	sAX	= 0x0000;			
00139:      	AX	= 0x00
            ; //	asm I1 = _songidx8C42F7DA+0;		
0013A:      	I1 = _songidx8C42F7DA+0//
            ; //	*(__int16*)sSI	= sAX			
0013B:      	rm[I1]	= AX
            ; //_A5A7AA303_21:;					
            _A5A7AA303_21:
            ; //	sAX	= 0x7FFF;			
0013C:      	AX	= 0x7FFF
            ; //	asm I1 = dtxfltg+0;			
0013E:      	I1 = dtxfltg+0//
            ; //	*(__int16*)sSI	= sAX			
0013F:      	rm[I1]	= AX
            ; //L9FD7D12A_9:;					
            L9FD7D12A_9:
            ; //_A5A7AA303_22:;					
            _A5A7AA303_22:
            ; //_A5A7AA303_23:;					
            _A5A7AA303_23:
            ; //	asm	io[ClrWDT] = AR			
00140:      	io[ClrWDT] = AR
            ; //	
            ; //_A5A7AA303_24:;					
            _A5A7AA303_24:
            ; //_A5A7AA303_25:;					
            _A5A7AA303_25:
            ; //	_PollingKey3B90E3B1();			
00141:      	pch	= _PollingKey3B90E3B1
00142:      	lcall	_PollingKey3B90E3B1
            ; //_A5A7AA303_26:;					
            _A5A7AA303_26:
            ; //_A5A7AA303_27:;					
            _A5A7AA303_27:
            ; //	_KeyShowLEDA84888EC();			
00143:      	pch	= _KeyShowLEDA84888EC
00144:      	lcall	_KeyShowLEDA84888EC
            ; //_A5A7AA303_28:;					
            _A5A7AA303_28:
            ; //_A5A7AA303_29:;					
            _A5A7AA303_29:
            ; //	_ToneVolCtrl03CF265A();			
00145:      	pch	= _ToneVolCtrl03CF265A
00146:      	lcall	_ToneVolCtrl03CF265A
            ; //_A5A7AA303_30:;					
            _A5A7AA303_30:
            ; //_A5A7AA303_31:;					
            _A5A7AA303_31:
            ; //	_WaitPCM_Empty_size53398B9D();		
00147:      	pch	= _WaitPCM_Empty_size53398B9D
00148:      	lcall	_WaitPCM_Empty_size53398B9D
            ; //	sCX	= 0x0000;			
00149:      	CX	= 0x00
            ; //	sfx_CMP_AX_CX_JL();			
0014A:      	pch	= sfx_CMP_AX_CX_JL
0014B:      	lcall	sfx_CMP_AX_CX_JL
            ; //	if(__je__)	goto L9FD7D12A_11;	
0014C:      	if ZR	jmp L9FD7D12A_11
            ; //	goto	L9FD7D12A_10;			
0014D:      	jmp	L9FD7D12A_10
            ; //L9FD7D12A_11:;					
            L9FD7D12A_11:
            ; //_A5A7AA303_32:;					
            _A5A7AA303_32:
            ; //	goto L9FD7D12A_9;			
0014E:      	jmp	L9FD7D12A_9
            ; //L9FD7D12A_10:;					
            L9FD7D12A_10:
            ; //_A5A7AA303_33:;					
            _A5A7AA303_33:
            ; //_A5A7AA303_34:;					
            _A5A7AA303_34:
            ; //	sAX	= 0;				
0014F:      	AX	= 0x00
            ; //	asm I1 = _flags026116D5+0;		
00150:      	I1 = _flags026116D5+0//
            ; //	asm AR = rm[I1];			
00151:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
00152:      	test AR.b0//
            ; //	if(__jz__) goto L9FD7D12A_13;		
00153:      	if ZR	jmp L9FD7D12A_13
            ; //	sAX	= 1;				
00154:      	AX	= 0x01
            ; //L9FD7D12A_13:;					
            L9FD7D12A_13:
            ; //	sfx_CHECKZERO();			
00155:      	AR	= AX
            ; //	if(__jnz__)	goto L9FD7D12A_14;	
00156:      	if NZ	jmp L9FD7D12A_14
            ; //	goto	L9FD7D12A_12;			
00157:      	jmp	L9FD7D12A_12
            ; //L9FD7D12A_14:;					
            L9FD7D12A_14:
            ; //	
            ; //_A5A7AA303_35:;					
            _A5A7AA303_35:
            ; //_A5A7AA303_36:;					
            _A5A7AA303_36:
            ; //	Subb3_Dec();				
00158:      	pch	= Subb3_Dec
00159:      	lcall	Subb3_Dec
            ; //	sfx_CHECKZERO();			
0015A:      	AR	= AX
            ; //	if(__jnz__)	goto L9FD7D12A_16;	
0015B:      	if NZ	jmp L9FD7D12A_16
            ; //	goto	L9FD7D12A_15;			
0015C:      	jmp	L9FD7D12A_15
            ; //L9FD7D12A_16:;					
            L9FD7D12A_16:
            ; //	
            ; //_A5A7AA303_37:;					
            _A5A7AA303_37:
            ; //	asm I1 = _flags026116D5+0;		
0015D:      	I1 = _flags026116D5+0//
            ; //	asm AR = rm[I1];			
0015E:      	AR = rm[I1]//
            ; //	asm clr AR.b0;				
0015F:      	clr AR.b0//
            ; //	asm rm[I1] = AR;			
00160:      	rm[I1] = AR//
            ; //_A5A7AA303_38:;					
            _A5A7AA303_38:
            ; //_A5A7AA303_39:;					
            _A5A7AA303_39:
            ; //	_Sub3ZeroFillABFF23AA();		
00161:      	pch	= _Sub3ZeroFillABFF23AA
00162:      	lcall	_Sub3ZeroFillABFF23AA
            ; //L9FD7D12A_15:;					
            L9FD7D12A_15:
            ; //_A5A7AA303_40:;					
            _A5A7AA303_40:
            ; //	goto L9FD7D12A_17;			
00163:      	jmp	L9FD7D12A_17
            ; //L9FD7D12A_12:;					
            L9FD7D12A_12:
            ; //	
            ; //_A5A7AA303_41:;					
            _A5A7AA303_41:
            ; //_A5A7AA303_42:;					
            _A5A7AA303_42:
            ; //	_Sub3ZeroFillABFF23AA();		
00164:      	pch	= _Sub3ZeroFillABFF23AA
00165:      	lcall	_Sub3ZeroFillABFF23AA
            ; //L9FD7D12A_17:;					
            L9FD7D12A_17:
            ; //_A5A7AA303_43:;					
            _A5A7AA303_43:
            ; //	goto L9FD7D12A_9;			
00166:      	jmp	L9FD7D12A_9
            ; //L9FD7D12A_8:;					
            L9FD7D12A_8:
            ; //L9FD7D12A_2:;					
            L9FD7D12A_2:
            ; //_A5A7AA303_44:;					
            _A5A7AA303_44:
            ; //	return;					
00167:      	rets
            ; //_main_end:;					
            _main_end:
            ; //_A5A7AA303_45:;					
            _A5A7AA303_45:
            ; //}
            ; //
            ; //rjmp void _KeyPlaySongC44FFB6D()		
            _KeyPlaySongC44FFB6D:
            ; //{
            ; //_A5A7AA303_46:;					
            _A5A7AA303_46:
            ; //	
            ; //_A5A7AA303_47:;					
            _A5A7AA303_47:
            ; //	asm I1 = _flags026116D5+0;		
00168:      	I1 = _flags026116D5+0//
            ; //	asm AR = rm[I1];			
00169:      	AR = rm[I1]//
            ; //	asm clr AR.b0;				
0016A:      	clr AR.b0//
            ; //	asm rm[I1] = AR;			
0016B:      	rm[I1] = AR//
            ; //_A5A7AA303_48:;					
            _A5A7AA303_48:
            ; //_A5A7AA303_49:;					
            _A5A7AA303_49:
            ; //	_dtxCheckSongEnd870A9712();		
0016C:      	pch	= _dtxCheckSongEnd870A9712
0016D:      	lcall	_dtxCheckSongEnd870A9712
            ; //	sfx_CHECKZERO();			
0016E:      	AR	= AX
            ; //	if(__jnz__)	goto L9FD7D12A_20;	
0016F:      	if NZ	jmp L9FD7D12A_20
            ; //	goto	L9FD7D12A_19;			
00170:      	jmp	L9FD7D12A_19
            ; //L9FD7D12A_20:;					
            L9FD7D12A_20:
            ; //	
            ; //_A5A7AA303_50:;					
            _A5A7AA303_50:
            ; //_A5A7AA303_51:;					
            _A5A7AA303_51:
            ; //	asm I1 = _songidx8C42F7DA+0;		
00171:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
00172:      	AX	= rm[I1]
            ; //	_dtxPlaySong5B7DBDA5(STACK[sSP + 0]);	
00173:      	pch	= _dtxPlaySong5B7DBDA5
00174:      	lcall	_dtxPlaySong5B7DBDA5
            ; //	goto L9FD7D12A_21;			
00175:      	jmp	L9FD7D12A_21
            ; //L9FD7D12A_19:;					
            L9FD7D12A_19:
            ; //	
            ; //_A5A7AA303_52:;					
            _A5A7AA303_52:
            ; //_A5A7AA303_53:;					
            _A5A7AA303_53:
            ; //	dtxStopSong();				
00176:      	pch	= dtxStopSong
00177:      	lcall	dtxStopSong
            ; //L9FD7D12A_21:;					
            L9FD7D12A_21:
            ; //_A5A7AA303_54:;					
            _A5A7AA303_54:
            ; //L9FD7D12A_18:;					
            L9FD7D12A_18:
            ; //_A5A7AA303_55:;					
            _A5A7AA303_55:
            ; //	return;					
00178:      	rets
            ; //_KeyPlaySongC44FFB6D_end:;			
            _KeyPlaySongC44FFB6D_end:
            ; //_A5A7AA303_56:;					
            _A5A7AA303_56:
            ; //}
            ; //
            ; //rjmp void _KeyPlayStop0C3B8DB1()		
            _KeyPlayStop0C3B8DB1:
            ; //{
            ; //_A5A7AA303_57:;					
            _A5A7AA303_57:
            ; //	
            ; //_A5A7AA303_58:;					
            _A5A7AA303_58:
            ; //_A5A7AA303_59:;					
            _A5A7AA303_59:
            ; //	dtxStopSong();				
00179:      	pch	= dtxStopSong
0017A:      	lcall	dtxStopSong
            ; //L9FD7D12A_22:;					
            L9FD7D12A_22:
            ; //_A5A7AA303_60:;					
            _A5A7AA303_60:
            ; //	return;					
0017B:      	rets
            ; //_KeyPlayStop0C3B8DB1_end:;			
            _KeyPlayStop0C3B8DB1_end:
            ; //_A5A7AA303_61:;					
            _A5A7AA303_61:
            ; //}
            ; //
            ; //rjmp void _KeyPlayNextAFBA8CED()		
            _KeyPlayNextAFBA8CED:
            ; //{
            ; //_A5A7AA303_62:;					
            _A5A7AA303_62:
            ; //	
            ; //_A5A7AA303_63:;					
            _A5A7AA303_63:
            ; //_A5A7AA303_64:;					
            _A5A7AA303_64:
            ; //	dtxStopSong();				
0017C:      	pch	= dtxStopSong
0017D:      	lcall	dtxStopSong
            ; //_A5A7AA303_65:;					
            _A5A7AA303_65:
            ; //	asm I1 = _songidx8C42F7DA+0;		
0017E:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
0017F:      	AX	= rm[I1]
            ; //	sSI	= (int)&_songidx8C42F7DA;	
00180:      	I1	= _songidx8C42F7DA
            ; //	sCX	= *(__int16*)sSI;		
00181:      	CX	= rm[I1]
            ; //	sCX++;					
00182:      	CX++
            ; //	*(__int16*)sSI	= sCX;			
00183:      	rm[I1]	= CX
            ; //_A5A7AA303_66:;					
            _A5A7AA303_66:
            ; //_A5A7AA303_67:;					
            _A5A7AA303_67:
            ; //	_CheckSongLimit402181B4();		
00184:      	pch	= _CheckSongLimit402181B4
00185:      	lcall	_CheckSongLimit402181B4
            ; //_A5A7AA303_68:;					
            _A5A7AA303_68:
            ; //_A5A7AA303_69:;					
            _A5A7AA303_69:
            ; //	_KeyPlaySongC44FFB6D();			
00186:      	pch	= _KeyPlaySongC44FFB6D
00187:      	lcall	_KeyPlaySongC44FFB6D
            ; //L9FD7D12A_23:;					
            L9FD7D12A_23:
            ; //_A5A7AA303_70:;					
            _A5A7AA303_70:
            ; //	return;					
00188:      	rets
            ; //_KeyPlayNextAFBA8CED_end:;			
            _KeyPlayNextAFBA8CED_end:
            ; //_A5A7AA303_71:;					
            _A5A7AA303_71:
            ; //}
            ; //
            ; //rjmp void _KeyPlayPrev8E98A35A()		
            _KeyPlayPrev8E98A35A:
            ; //{
            ; //_A5A7AA303_72:;					
            _A5A7AA303_72:
            ; //	
            ; //_A5A7AA303_73:;					
            _A5A7AA303_73:
            ; //_A5A7AA303_74:;					
            _A5A7AA303_74:
            ; //	dtxStopSong();				
00189:      	pch	= dtxStopSong
0018A:      	lcall	dtxStopSong
            ; //_A5A7AA303_75:;					
            _A5A7AA303_75:
            ; //	asm I1 = _songidx8C42F7DA+0;		
0018B:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
0018C:      	AX	= rm[I1]
            ; //	sSI	= (int)&_songidx8C42F7DA;	
0018D:      	I1	= _songidx8C42F7DA
            ; //	sCX	= *(__int16*)sSI;		
0018E:      	CX	= rm[I1]
            ; //	sCX--;					
0018F:      	CX--
            ; //	*(__int16*)sSI	= sCX;			
00190:      	rm[I1]	= CX
            ; //_A5A7AA303_76:;					
            _A5A7AA303_76:
            ; //_A5A7AA303_77:;					
            _A5A7AA303_77:
            ; //	_CheckSongLimit402181B4();		
00191:      	pch	= _CheckSongLimit402181B4
00192:      	lcall	_CheckSongLimit402181B4
            ; //_A5A7AA303_78:;					
            _A5A7AA303_78:
            ; //_A5A7AA303_79:;					
            _A5A7AA303_79:
            ; //	_KeyPlaySongC44FFB6D();			
00193:      	pch	= _KeyPlaySongC44FFB6D
00194:      	lcall	_KeyPlaySongC44FFB6D
            ; //L9FD7D12A_24:;					
            L9FD7D12A_24:
            ; //_A5A7AA303_80:;					
            _A5A7AA303_80:
            ; //	return;					
00195:      	rets
            ; //_KeyPlayPrev8E98A35A_end:;			
            _KeyPlayPrev8E98A35A_end:
            ; //_A5A7AA303_81:;					
            _A5A7AA303_81:
            ; //}
            ; //
            ; //rjmp void _KeyModEEAB4D5A()			
            _KeyModEEAB4D5A:
            ; //{
            ; //_A5A7AA303_82:;					
            _A5A7AA303_82:
            ; //	
            ; //_A5A7AA303_83:;					
            _A5A7AA303_83:
            ; //	asm AX = dtxtonech+7;			
00196:      	AX = dtxtonech+7//
            ; //	PUSH(sAX);				
00198:      	push	AX
            ; //	sAX	= 0x0001;			
00199:      	AX	= 0x01
            ; //	asm I1 = dtxtonech+7;			
0019A:      	I1 = dtxtonech+7//
            ; //	sCX	= *(__int16*)sSI;		
0019C:      	CX	= rm[I1]
            ; //	sAX	= sAX + sCX;			
0019D:      	AR	= CX
0019E:      	AX	+= AR
            ; //	asm AR = 0x0003;			
0019F:      	AR = 0x0003//
            ; //	asm AX = AX & AR;			
001A0:      	AX = AX & AR//
            ; //	sSI	= POP();			
001A1:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
001A2:      	rm[I1]	= AX
            ; //_A5A7AA303_84:;					
            _A5A7AA303_84:
            ; //	asm AX = dtxtonech+15;			
001A3:      	AX = dtxtonech+15//
            ; //	PUSH(sAX);				
001A5:      	push	AX
            ; //	sAX	= 0x0001;			
001A6:      	AX	= 0x01
            ; //	asm I1 = dtxtonech+15;			
001A7:      	I1 = dtxtonech+15//
            ; //	sCX	= *(__int16*)sSI;		
001A9:      	CX	= rm[I1]
            ; //	sAX	= sAX + sCX;			
001AA:      	AR	= CX
001AB:      	AX	+= AR
            ; //	asm AR = 0x0003;			
001AC:      	AR = 0x0003//
            ; //	asm AX = AX & AR;			
001AD:      	AX = AX & AR//
            ; //	sSI	= POP();			
001AE:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
001AF:      	rm[I1]	= AX
            ; //L9FD7D12A_25:;					
            L9FD7D12A_25:
            ; //_A5A7AA303_85:;					
            _A5A7AA303_85:
            ; //	return;					
001B0:      	rets
            ; //_KeyModEEAB4D5A_end:;				
            _KeyModEEAB4D5A_end:
            ; //_A5A7AA303_86:;					
            _A5A7AA303_86:
            ; //}
            ; //
            ; //rjmp void _KeySubb3A3BA54B6D()			
            _KeySubb3A3BA54B6D:
            ; //{
            ; //_A5A7AA303_87:;					
            _A5A7AA303_87:
            ; //	
            ; //_A5A7AA303_88:;					
            _A5A7AA303_88:
            ; //_A5A7AA303_89:;					
            _A5A7AA303_89:
            ; //	dtxStopSong();				
001B1:      	pch	= dtxStopSong
001B2:      	lcall	dtxStopSong
            ; //_A5A7AA303_90:;					
            _A5A7AA303_90:
            ; //_A5A7AA303_91:;					
            _A5A7AA303_91:
            ; //	asm AX = #subdat0+0;			
001B3:      	AX = #subdat0+0//
            ; //	asm DX = #subdat0.n2			
001B5:      	DX = #subdat0.n2
            ; //	asm set DX.b11				
001B6:      	set DX.b11
            ; //	PUSH(sDX);				
001B7:      	push	DX
            ; //	PUSH(sAX);				
001B8:      	push	AX
            ; //	_Sub3Play422CAD6D(STACK[sSP + 0], STACK[sSP + 1]);
001B9:      	pch	= _Sub3Play422CAD6D
001BA:      	lcall	_Sub3Play422CAD6D
            ; //	RESTORESP(2);				
001BB:      	pop	AR
001BC:      	pop	AR
            ; //_A5A7AA303_92:;					
            _A5A7AA303_92:
            ; //	asm I1 = _flags026116D5+0;		
001BD:      	I1 = _flags026116D5+0//
            ; //	asm AR = rm[I1];			
001BE:      	AR = rm[I1]//
            ; //	asm set AR.b0;				
001BF:      	set AR.b0//
            ; //	asm rm[I1] = AR;			
001C0:      	rm[I1] = AR//
            ; //L9FD7D12A_26:;					
            L9FD7D12A_26:
            ; //_A5A7AA303_93:;					
            _A5A7AA303_93:
            ; //	return;					
001C1:      	rets
            ; //_KeySubb3A3BA54B6D_end:;			
            _KeySubb3A3BA54B6D_end:
            ; //_A5A7AA303_94:;					
            _A5A7AA303_94:
            ; //}
            ; //
            ; //rjmp void _KeySubb3B3F6456DA()			
            _KeySubb3B3F6456DA:
            ; //{
            ; //_A5A7AA303_95:;					
            _A5A7AA303_95:
            ; //	
            ; //_A5A7AA303_96:;					
            _A5A7AA303_96:
            ; //_A5A7AA303_97:;					
            _A5A7AA303_97:
            ; //	dtxStopSong();				
001C2:      	pch	= dtxStopSong
001C3:      	lcall	dtxStopSong
            ; //_A5A7AA303_98:;					
            _A5A7AA303_98:
            ; //_A5A7AA303_99:;					
            _A5A7AA303_99:
            ; //	asm AX = #subdat1+0;			
001C4:      	AX = #subdat1+0//
            ; //	asm DX = #subdat1.n2			
001C6:      	DX = #subdat1.n2
            ; //	asm set DX.b11				
001C7:      	set DX.b11
            ; //	PUSH(sDX);				
001C8:      	push	DX
            ; //	PUSH(sAX);				
001C9:      	push	AX
            ; //	_Sub3Play422CAD6D(STACK[sSP + 0], STACK[sSP + 1]);
001CA:      	pch	= _Sub3Play422CAD6D
001CB:      	lcall	_Sub3Play422CAD6D
            ; //	RESTORESP(2);				
001CC:      	pop	AR
001CD:      	pop	AR
            ; //_A5A7AA303_100:;				
            _A5A7AA303_100:
            ; //	asm I1 = _flags026116D5+0;		
001CE:      	I1 = _flags026116D5+0//
            ; //	asm AR = rm[I1];			
001CF:      	AR = rm[I1]//
            ; //	asm set AR.b0;				
001D0:      	set AR.b0//
            ; //	asm rm[I1] = AR;			
001D1:      	rm[I1] = AR//
            ; //L9FD7D12A_27:;					
            L9FD7D12A_27:
            ; //_A5A7AA303_101:;				
            _A5A7AA303_101:
            ; //	return;					
001D2:      	rets
            ; //_KeySubb3B3F6456DA_end:;			
            _KeySubb3B3F6456DA_end:
            ; //_A5A7AA303_102:;				
            _A5A7AA303_102:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_HOW_DO_I_PLAY_DTX_AND_SUBBAND3_SIMULTANEOUSLY_528516D5_s(void)
            ginit_code_HOW_DO_I_PLAY_DTX_AND_SUBBAND3_SIMULTANEOUSLY_528516D5_s:
            ; //{
            ; //	return;					
001D3:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //__int16 _keyfuncF06F3D55[15] = {		
            _keyfuncF06F3D55:
            ; //	(int)&_KeyPlayNextAFBA8CED, 0x0000, 0x0000, (int)&_KeyPlayPrev8E98A35A, 0x0000, 0x0000, (int)&_KeyModEEAB4D5A, 0x0000, 
001D4:      DW #_KeyPlayNextAFBA8CED,0x0000,0x0000,#_KeyPlayPrev8E98A35A,0x0000,0x0000,#_KeyModEEAB4D5A,0x0000,
            ; //	0x0000, (int)&_KeySubb3A3BA54B6D, 0x0000, 0x0000, (int)&_KeySubb3B3F6456DA, 0x0000, 0x0000
001DC:      DW 0x0000,#_KeySubb3A3BA54B6D,0x0000,0x0000,#_KeySubb3B3F6456DA,0x0000,0x0000,
            ; //};
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\HOW DO I PLAY DTX AND SUBBAND3 SIMULTANEOUSLY_528516D5.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\GLOBAL_6037E6D5.S.CODE.ASM> Start=========================
            ; global.c Code Start!!;
            VarRM[0:4095]={
             _flags026116D5,_songidx8C42F7DA,_sub_vol980B1B83,_ticksA7263C09[2] 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _InitialDA4A7CC4();
            ; //rjmp void _CheckSongLimit402181B4();
            ; //rjmp void _RampUpFF7996DA();
            ; //rjmp void _RampDown1D382EDA();
            ; //rjmp void _ToneVolCtrl03CF265A();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void L0E8FA404_29()			
            L0E8FA404_29:
            ; //{
            ; //_A5A7AA303_103:;				
            _A5A7AA303_103:
            ; //	
            ; //_A5A7AA303_104:;				
            _A5A7AA303_104:
            ; //	io[0x16]	= 0x0000;		
001E3:      	AR	= 0x00
001E4:      	io[0x16]	= AR
            ; //_A5A7AA303_105:;				
            _A5A7AA303_105:
            ; //	io[0x16]	= 0x0000;		
001E5:      	AR	= 0x00
001E6:      	io[0x16]	= AR
            ; //_A5A7AA303_106:;				
            _A5A7AA303_106:
            ; //	io[0x16]	= 0x0000;		
001E7:      	AR	= 0x00
001E8:      	io[0x16]	= AR
            ; //_A5A7AA303_107:;				
            _A5A7AA303_107:
            ; //	io[0x16]	= 0x0000;		
001E9:      	AR	= 0x00
001EA:      	io[0x16]	= AR
            ; //_A5A7AA303_108:;				
            _A5A7AA303_108:
            ; //	io[0x36]	= 0x0000;		
001EB:      	AR	= 0x00
001EC:      	io[0x36]	= AR
            ; //_A5A7AA303_109:;				
            _A5A7AA303_109:
            ; //	io[0x36]	= 0x0000;		
001ED:      	AR	= 0x00
001EE:      	io[0x36]	= AR
            ; //_A5A7AA303_110:;				
            _A5A7AA303_110:
            ; //	io[0x36]	= 0x0000;		
001EF:      	AR	= 0x00
001F0:      	io[0x36]	= AR
            ; //_A5A7AA303_111:;				
            _A5A7AA303_111:
            ; //	io[0x36]	= 0x0000;		
001F1:      	AR	= 0x00
001F2:      	io[0x36]	= AR
            ; //_A5A7AA303_112:;				
            _A5A7AA303_112:
            ; //	io[0x36]	= 0x0000;		
001F3:      	AR	= 0x00
001F4:      	io[0x36]	= AR
            ; //_A5A7AA303_113:;				
            _A5A7AA303_113:
            ; //	io[0x36]	= 0x0000;		
001F5:      	AR	= 0x00
001F6:      	io[0x36]	= AR
            ; //_A5A7AA303_114:;				
            _A5A7AA303_114:
            ; //	io[0x36]	= 0x0000;		
001F7:      	AR	= 0x00
001F8:      	io[0x36]	= AR
            ; //_A5A7AA303_115:;				
            _A5A7AA303_115:
            ; //	io[0x36]	= 0x0000;		
001F9:      	AR	= 0x00
001FA:      	io[0x36]	= AR
            ; //_A5A7AA303_116:;				
            _A5A7AA303_116:
            ; //	io[0x3C]	= 0x003F;		
001FB:      	AR	= 0x3F
001FC:      	io[0x3C]	= AR
            ; //_A5A7AA303_117:;				
            _A5A7AA303_117:
            ; //	sAX	= io[0x3C];			
001FD:      	AR	= io[0x3C]
001FE:      	AX	= AR
            ; //_A5A7AA303_118:;				
            _A5A7AA303_118:
            ; //	asm	set io[MISC].b9			
001FF:      	set io[MISC].b9
            ; //_A5A7AA303_119:;				
            _A5A7AA303_119:
            ; //	asm	set io[MISC].b8			
00200:      	set io[MISC].b8
            ; //_A5A7AA303_120:;				
            _A5A7AA303_120:
            ; //	asm	set io[MISC].b4			
00201:      	set io[MISC].b4
            ; //L0E8FA404_31:;					
            L0E8FA404_31:
            ; //_A5A7AA303_121:;				
            _A5A7AA303_121:
            ; //	return;					
00202:      	rets
            ; //L0E8FA404_29_end:;				
            L0E8FA404_29_end:
            ; //_A5A7AA303_122:;				
            _A5A7AA303_122:
            ; //}
            ; //
            ; //rjmp void L0E8FA404_32()			
            L0E8FA404_32:
            ; //{
            ; //_A5A7AA303_123:;				
            _A5A7AA303_123:
            ; //	
            ; //_A5A7AA303_124:;				
            _A5A7AA303_124:
            ; //	io[0x04]	= 0x000F;		
00203:      	AR	= 0x0F
00204:      	io[0x04]	= AR
            ; //_A5A7AA303_125:;				
            _A5A7AA303_125:
            ; //	io[0x05]	= 0xFFFF;		
00205:      	AR	= 0xFFFF
00207:      	io[0x05]	= AR
            ; //_A5A7AA303_126:;				
            _A5A7AA303_126:
            ; //	io[0x07]	= 0x0000;		
00208:      	AR	= 0x00
00209:      	io[0x07]	= AR
            ; //_A5A7AA303_127:;				
            _A5A7AA303_127:
            ; //	io[0x08]	= 0xFFFF;		
0020A:      	AR	= 0xFFFF
0020C:      	io[0x08]	= AR
            ; //L0E8FA404_34:;					
            L0E8FA404_34:
            ; //_A5A7AA303_128:;				
            _A5A7AA303_128:
            ; //	return;					
0020D:      	rets
            ; //L0E8FA404_32_end:;				
            L0E8FA404_32_end:
            ; //_A5A7AA303_129:;				
            _A5A7AA303_129:
            ; //}
            ; //
            ; //rjmp void _InitialDA4A7CC4()			
            _InitialDA4A7CC4:
            ; //{
            ; //_A5A7AA303_130:;				
            _A5A7AA303_130:
            ; //	
            ; //_A5A7AA303_131:;				
            _A5A7AA303_131:
            ; //	sAX	= 0x0000;			
0020E:      	AX	= 0x00
            ; //	asm I1 = _songidx8C42F7DA+0;		
0020F:      	I1 = _songidx8C42F7DA+0//
            ; //	*(__int16*)sSI	= sAX			
00210:      	rm[I1]	= AX
            ; //_A5A7AA303_132:;				
            _A5A7AA303_132:
            ; //_A5A7AA303_133:;				
            _A5A7AA303_133:
            ; //	NEARCALL(L0E8FA404_29);			
00211:      	call	L0E8FA404_29
            ; //_A5A7AA303_134:;				
            _A5A7AA303_134:
            ; //_A5A7AA303_135:;				
            _A5A7AA303_135:
            ; //	NEARCALL(L0E8FA404_32);			
00212:      	call	L0E8FA404_32
            ; //_A5A7AA303_136:;				
            _A5A7AA303_136:
            ; //	sAX	= 0x0000;			
00213:      	AX	= 0x00
            ; //	asm I1 = _flags026116D5+0;		
00214:      	I1 = _flags026116D5+0//
            ; //	*(__int16*)sSI	= sAX			
00215:      	rm[I1]	= AX
            ; //_A5A7AA303_137:;				
            _A5A7AA303_137:
            ; //	asm AX = PCMY+0;			
00216:      	AX = PCMY+0//
            ; //	asm I1 = PCMYIN_PTR+0;			
00218:      	I1 = PCMYIN_PTR+0//
            ; //	*(__int16*)sSI	= sAX			
00219:      	rm[I1]	= AX
            ; //_A5A7AA303_138:;				
            _A5A7AA303_138:
            ; //	asm AX = PCMY+0;			
0021A:      	AX = PCMY+0//
            ; //	asm I1 = PCMYOU_PTR+0;			
0021C:      	I1 = PCMYOU_PTR+0//
            ; //	*(__int16*)sSI	= sAX			
0021D:      	rm[I1]	= AX
            ; //L0E8FA404_35:;					
            L0E8FA404_35:
            ; //_A5A7AA303_139:;				
            _A5A7AA303_139:
            ; //	return;					
0021E:      	rets
            ; //_InitialDA4A7CC4_end:;				
            _InitialDA4A7CC4_end:
            ; //_A5A7AA303_140:;				
            _A5A7AA303_140:
            ; //}
            ; //
            ; //rjmp void _CheckSongLimit402181B4()		
            _CheckSongLimit402181B4:
            ; //{
            ; //_A5A7AA303_141:;				
            _A5A7AA303_141:
            ; //	
            ; //_A5A7AA303_142:;				
            _A5A7AA303_142:
            ; //	asm I1 = _songidx8C42F7DA+0;		
0021F:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
00220:      	AX	= rm[I1]
            ; //	sCX	= 0x0000;			
00221:      	CX	= 0x00
            ; //	sfx_CMP_AX_CX_JL();			
00222:      	pch	= sfx_CMP_AX_CX_JL
00223:      	lcall	sfx_CMP_AX_CX_JL
            ; //	if(__je__)	goto L0E8FA404_38;	
00224:      	if ZR	jmp L0E8FA404_38
            ; //	goto	L0E8FA404_37;			
00225:      	jmp	L0E8FA404_37
            ; //L0E8FA404_38:;					
            L0E8FA404_38:
            ; //	
            ; //_A5A7AA303_143:;				
            _A5A7AA303_143:
            ; //	asm I1 = dtxsongcnt+0;			
00226:      	I1 = dtxsongcnt+0//
            ; //	sAX	= *(__int16*)sSI;		
00228:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
00229:      	CX	= 0x01
            ; //	sAX	= sAX - sCX;			
0022A:      	AR	= CX
0022B:      	AX	-= AR
            ; //	asm I1 = _songidx8C42F7DA+0;		
0022C:      	I1 = _songidx8C42F7DA+0//
            ; //	*(__int16*)sSI	= sAX			
0022D:      	rm[I1]	= AX
            ; //	goto L0E8FA404_39;			
0022E:      	jmp	L0E8FA404_39
            ; //L0E8FA404_37:;					
            L0E8FA404_37:
            ; //	
            ; //_A5A7AA303_144:;				
            _A5A7AA303_144:
            ; //	asm I1 = _songidx8C42F7DA+0;		
0022F:      	I1 = _songidx8C42F7DA+0//
            ; //	sAX	= *(__int16*)sSI;		
00230:      	AX	= rm[I1]
            ; //	asm I1 = dtxsongcnt+0;			
00231:      	I1 = dtxsongcnt+0//
            ; //	asm CX = rm[I1];			
00233:      	CX = rm[I1]//
            ; //	sfx_CMP_AX_CX_JGE();			
00234:      	pch	= sfx_CMP_AX_CX_JGE
00235:      	lcall	sfx_CMP_AX_CX_JGE
            ; //	if(__je__)	goto L0E8FA404_41;	
00236:      	if ZR	jmp L0E8FA404_41
            ; //	goto	L0E8FA404_40;			
00237:      	jmp	L0E8FA404_40
            ; //L0E8FA404_41:;					
            L0E8FA404_41:
            ; //	
            ; //_A5A7AA303_145:;				
            _A5A7AA303_145:
            ; //	sAX	= 0x0000;			
00238:      	AX	= 0x00
            ; //	asm I1 = _songidx8C42F7DA+0;		
00239:      	I1 = _songidx8C42F7DA+0//
            ; //	*(__int16*)sSI	= sAX			
0023A:      	rm[I1]	= AX
            ; //L0E8FA404_40:;					
            L0E8FA404_40:
            ; //_A5A7AA303_146:;				
            _A5A7AA303_146:
            ; //L0E8FA404_39:;					
            L0E8FA404_39:
            ; //_A5A7AA303_147:;				
            _A5A7AA303_147:
            ; //L0E8FA404_36:;					
            L0E8FA404_36:
            ; //_A5A7AA303_148:;				
            _A5A7AA303_148:
            ; //	return;					
0023B:      	rets
            ; //_CheckSongLimit402181B4_end:;			
            _CheckSongLimit402181B4_end:
            ; //_A5A7AA303_149:;				
            _A5A7AA303_149:
            ; //}
            ; //
            ; //rjmp void _RampUpFF7996DA()			
            _RampUpFF7996DA:
            ; //{
            ; //_A5A7AA303_150:;				
            _A5A7AA303_150:
            ; //	
            ; //_A5A7AA303_151:;				
            _A5A7AA303_151:
            ; //	asm I1 = _sub_vol980B1B83+0;		
0023C:      	I1 = _sub_vol980B1B83+0//
            ; //	sAX	= *(__int16*)sSI;		
0023D:      	AX	= rm[I1]
            ; //	asm AR = 0x003F;			
0023E:      	AR = 0x003F//
            ; //	asm AX = AX & AR;			
0023F:      	AX = AX & AR//
            ; //	sCX	= 0x003F;			
00240:      	CX	= 0x3F
            ; //	sfx_CMP_AX_CX_JE();			
00241:      	pch	= sfx_CMP_AX_CX_JE
00242:      	lcall	sfx_CMP_AX_CX_JE
            ; //	if(__je__)	goto L0E8FA404_44;	
00243:      	if ZR	jmp L0E8FA404_44
            ; //	goto	L0E8FA404_43;			
00244:      	jmp	L0E8FA404_43
            ; //L0E8FA404_44:;					
            L0E8FA404_44:
            ; //_A5A7AA303_152:;				
            _A5A7AA303_152:
            ; //	sAX	= 0x0000;			
00245:      	AX	= 0x00
            ; //	goto L0E8FA404_42;			
00246:      	jmp	L0E8FA404_42
            ; //L0E8FA404_43:;					
            L0E8FA404_43:
            ; //_A5A7AA303_153:;				
            _A5A7AA303_153:
            ; //_A5A7AA303_154:;				
            _A5A7AA303_154:
            ; //_A5A7AA303_155:;				
            _A5A7AA303_155:
            ; //	_GetTickCount18DC070C();		
00247:      	pch	= _GetTickCount18DC070C
00248:      	lcall	_GetTickCount18DC070C
            ; //	asm I1 = _ticksA7263C09+0;		
00249:      	I1 = _ticksA7263C09+0//
            ; //	sCX	= *(__int16*)sSI++;		
0024A:      	CX	= rm[I1++]
            ; //	sBX	= *(__int16*)sSI--;		
0024B:      	BX	= rm[I1--]
            ; //	sfx_SUBLONG();				
0024C:      	AR	= CX
0024D:      	AX	= AX - AR
0024E:      	AR	= BX
0024F:      	DX	= DX - AR + C - 1
            ; //	sCX	= 0x0000;			
00250:      	CX	= 0x00
            ; //	sBX	= 0x0005;			
00251:      	BX	= 0x05
            ; //	sfx_CMPLONG_JA();			
00252:      	pch	= sfx_CMPLONG_JA
00253:      	lcall	sfx_CMPLONG_JA
            ; //	if(__je__)	goto L0E8FA404_46;	
00254:      	if ZR	jmp L0E8FA404_46
            ; //	goto	L0E8FA404_45;			
00255:      	jmp	L0E8FA404_45
            ; //L0E8FA404_46:;					
            L0E8FA404_46:
            ; //	
            ; //_A5A7AA303_156:;				
            _A5A7AA303_156:
            ; //_A5A7AA303_157:;				
            _A5A7AA303_157:
            ; //	_GetTickCount18DC070C();		
00256:      	pch	= _GetTickCount18DC070C
00257:      	lcall	_GetTickCount18DC070C
            ; //	asm I1 = _ticksA7263C09+0;		
00258:      	I1 = _ticksA7263C09+0//
            ; //	sfx_STORSILONG();			
00259:      	rm[I1++]	= AX
0025A:      	rm[I1--]	= DX
            ; //_A5A7AA303_158:;				
            _A5A7AA303_158:
            ; //	sSI	= (int)&_sub_vol980B1B83;	
0025B:      	I1	= _sub_vol980B1B83
            ; //	sAX	= *(__int16*)sSI;		
0025C:      	AX	= rm[I1]
            ; //	sAX++;					
0025D:      	AX++
            ; //	*(__int16*)sSI	= sAX;			
0025E:      	rm[I1]	= AX
            ; //	io[0x3C]	= sAX;			
0025F:      	AR	= AX
00260:      	io[0x3C]	= AR
            ; //L0E8FA404_45:;					
            L0E8FA404_45:
            ; //_A5A7AA303_159:;				
            _A5A7AA303_159:
            ; //_A5A7AA303_160:;				
            _A5A7AA303_160:
            ; //	sAX	= 0x0001;			
00261:      	AX	= 0x01
            ; //	goto L0E8FA404_42;			
00262:      	jmp	L0E8FA404_42
            ; //L0E8FA404_42:;					
            L0E8FA404_42:
            ; //_A5A7AA303_161:;				
            _A5A7AA303_161:
            ; //	return;					
00263:      	rets
            ; //_RampUpFF7996DA_end:;				
            _RampUpFF7996DA_end:
            ; //_A5A7AA303_162:;				
            _A5A7AA303_162:
            ; //}
            ; //
            ; //rjmp void _RampDown1D382EDA()			
            _RampDown1D382EDA:
            ; //{
            ; //_A5A7AA303_163:;				
            _A5A7AA303_163:
            ; //	
            ; //_A5A7AA303_164:;				
            _A5A7AA303_164:
            ; //	asm I1 = _sub_vol980B1B83+0;		
00264:      	I1 = _sub_vol980B1B83+0//
            ; //	sAX	= *(__int16*)sSI;		
00265:      	AX	= rm[I1]
            ; //	asm AR = 0x003F;			
00266:      	AR = 0x003F//
            ; //	asm AX = AX & AR;			
00267:      	AX = AX & AR//
            ; //	sCX	= 0x0000;			
00268:      	CX	= 0x00
            ; //	sfx_CMP_AX_CX_JE();			
00269:      	pch	= sfx_CMP_AX_CX_JE
0026A:      	lcall	sfx_CMP_AX_CX_JE
            ; //	if(__je__)	goto L0E8FA404_49;	
0026B:      	if ZR	jmp L0E8FA404_49
            ; //	goto	L0E8FA404_48;			
0026C:      	jmp	L0E8FA404_48
            ; //L0E8FA404_49:;					
            L0E8FA404_49:
            ; //_A5A7AA303_165:;				
            _A5A7AA303_165:
            ; //	sAX	= 0x0000;			
0026D:      	AX	= 0x00
            ; //	goto L0E8FA404_47;			
0026E:      	jmp	L0E8FA404_47
            ; //L0E8FA404_48:;					
            L0E8FA404_48:
            ; //_A5A7AA303_166:;				
            _A5A7AA303_166:
            ; //_A5A7AA303_167:;				
            _A5A7AA303_167:
            ; //_A5A7AA303_168:;				
            _A5A7AA303_168:
            ; //	_GetTickCount18DC070C();		
0026F:      	pch	= _GetTickCount18DC070C
00270:      	lcall	_GetTickCount18DC070C
            ; //	asm I1 = _ticksA7263C09+0;		
00271:      	I1 = _ticksA7263C09+0//
            ; //	sCX	= *(__int16*)sSI++;		
00272:      	CX	= rm[I1++]
            ; //	sBX	= *(__int16*)sSI--;		
00273:      	BX	= rm[I1--]
            ; //	sfx_SUBLONG();				
00274:      	AR	= CX
00275:      	AX	= AX - AR
00276:      	AR	= BX
00277:      	DX	= DX - AR + C - 1
            ; //	sCX	= 0x0000;			
00278:      	CX	= 0x00
            ; //	sBX	= 0x0005;			
00279:      	BX	= 0x05
            ; //	sfx_CMPLONG_JA();			
0027A:      	pch	= sfx_CMPLONG_JA
0027B:      	lcall	sfx_CMPLONG_JA
            ; //	if(__je__)	goto L0E8FA404_51;	
0027C:      	if ZR	jmp L0E8FA404_51
            ; //	goto	L0E8FA404_50;			
0027D:      	jmp	L0E8FA404_50
            ; //L0E8FA404_51:;					
            L0E8FA404_51:
            ; //	
            ; //_A5A7AA303_169:;				
            _A5A7AA303_169:
            ; //_A5A7AA303_170:;				
            _A5A7AA303_170:
            ; //	_GetTickCount18DC070C();		
0027E:      	pch	= _GetTickCount18DC070C
0027F:      	lcall	_GetTickCount18DC070C
            ; //	asm I1 = _ticksA7263C09+0;		
00280:      	I1 = _ticksA7263C09+0//
            ; //	sfx_STORSILONG();			
00281:      	rm[I1++]	= AX
00282:      	rm[I1--]	= DX
            ; //_A5A7AA303_171:;				
            _A5A7AA303_171:
            ; //	sSI	= (int)&_sub_vol980B1B83;	
00283:      	I1	= _sub_vol980B1B83
            ; //	sAX	= *(__int16*)sSI;		
00284:      	AX	= rm[I1]
            ; //	sAX--;					
00285:      	AX--
            ; //	*(__int16*)sSI	= sAX;			
00286:      	rm[I1]	= AX
            ; //	io[0x3C]	= sAX;			
00287:      	AR	= AX
00288:      	io[0x3C]	= AR
            ; //L0E8FA404_50:;					
            L0E8FA404_50:
            ; //_A5A7AA303_172:;				
            _A5A7AA303_172:
            ; //_A5A7AA303_173:;				
            _A5A7AA303_173:
            ; //	sAX	= 0x0001;			
00289:      	AX	= 0x01
            ; //	goto L0E8FA404_47;			
0028A:      	jmp	L0E8FA404_47
            ; //L0E8FA404_47:;					
            L0E8FA404_47:
            ; //_A5A7AA303_174:;				
            _A5A7AA303_174:
            ; //	return;					
0028B:      	rets
            ; //_RampDown1D382EDA_end:;				
            _RampDown1D382EDA_end:
            ; //_A5A7AA303_175:;				
            _A5A7AA303_175:
            ; //}
            ; //
            ; //rjmp void _ToneVolCtrl03CF265A()		
            _ToneVolCtrl03CF265A:
            ; //{
            ; //_A5A7AA303_176:;				
            _A5A7AA303_176:
            ; //	
            ; //_A5A7AA303_177:;				
            _A5A7AA303_177:
            ; //	sAX	= 0;				
0028C:      	AX	= 0x00
            ; //	asm I1 = _flags026116D5+0;		
0028D:      	I1 = _flags026116D5+0//
            ; //	asm AR = rm[I1];			
0028E:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
0028F:      	test AR.b0//
            ; //	if(__jz__) goto L0E8FA404_54;		
00290:      	if ZR	jmp L0E8FA404_54
            ; //	sAX	= 1;				
00291:      	AX	= 0x01
            ; //L0E8FA404_54:;					
            L0E8FA404_54:
            ; //	sfx_CHECKZERO();			
00292:      	AR	= AX
            ; //	if(__jnz__)	goto L0E8FA404_55;	
00293:      	if NZ	jmp L0E8FA404_55
            ; //	goto	L0E8FA404_53;			
00294:      	jmp	L0E8FA404_53
            ; //L0E8FA404_55:;					
            L0E8FA404_55:
            ; //	
            ; //_A5A7AA303_178:;				
            _A5A7AA303_178:
            ; //	asm I1 = dtxfltg+0;			
00295:      	I1 = dtxfltg+0//
            ; //	sAX	= *(__int16*)sSI;		
00296:      	AX	= rm[I1]
            ; //	sCX	= 0x100F;			
00297:      	CX	= 0x100F
            ; //	sfx_CMP_AX_CX_JG();			
00299:      	pch	= sfx_CMP_AX_CX_JG
0029A:      	lcall	sfx_CMP_AX_CX_JG
            ; //	if(__je__)	goto L0E8FA404_57;	
0029B:      	if ZR	jmp L0E8FA404_57
            ; //	goto	L0E8FA404_56;			
0029C:      	jmp	L0E8FA404_56
            ; //L0E8FA404_57:;					
            L0E8FA404_57:
            ; //_A5A7AA303_179:;				
            _A5A7AA303_179:
            ; //	asm I1 = dtxfltg+0;			
0029D:      	I1 = dtxfltg+0//
            ; //	sAX	= *(__int16*)sSI;		
0029E:      	AX	= rm[I1]
            ; //	sCX	= 0x0010;			
0029F:      	CX	= 0x10
            ; //	sAX	= sAX - sCX;			
002A0:      	AR	= CX
002A1:      	AX	-= AR
            ; //	asm I1 = dtxfltg+0;			
002A2:      	I1 = dtxfltg+0//
            ; //	*(__int16*)sSI	= sAX			
002A3:      	rm[I1]	= AX
            ; //L0E8FA404_56:;					
            L0E8FA404_56:
            ; //_A5A7AA303_180:;				
            _A5A7AA303_180:
            ; //	goto L0E8FA404_58;			
002A4:      	jmp	L0E8FA404_58
            ; //L0E8FA404_53:;					
            L0E8FA404_53:
            ; //	
            ; //_A5A7AA303_181:;				
            _A5A7AA303_181:
            ; //	asm I1 = dtxfltg+0;			
002A5:      	I1 = dtxfltg+0//
            ; //	sAX	= *(__int16*)sSI;		
002A6:      	AX	= rm[I1]
            ; //	sCX	= 0x7FFF;			
002A7:      	CX	= 0x7FFF
            ; //	sfx_CMP_AX_CX_JNE();			
002A9:      	pch	= sfx_CMP_AX_CX_JNE
002AA:      	lcall	sfx_CMP_AX_CX_JNE
            ; //	if(__je__)	goto L0E8FA404_60;	
002AB:      	if ZR	jmp L0E8FA404_60
            ; //	goto	L0E8FA404_59;			
002AC:      	jmp	L0E8FA404_59
            ; //L0E8FA404_60:;					
            L0E8FA404_60:
            ; //_A5A7AA303_182:;				
            _A5A7AA303_182:
            ; //	sSI	= (int)&dtxfltg;		
002AD:      	I1	= dtxfltg
            ; //	sAX	= *(__int16*)sSI;		
002AE:      	AX	= rm[I1]
            ; //	sAX++;					
002AF:      	AX++
            ; //	*(__int16*)sSI	= sAX;			
002B0:      	rm[I1]	= AX
            ; //L0E8FA404_59:;					
            L0E8FA404_59:
            ; //_A5A7AA303_183:;				
            _A5A7AA303_183:
            ; //L0E8FA404_58:;					
            L0E8FA404_58:
            ; //_A5A7AA303_184:;				
            _A5A7AA303_184:
            ; //L0E8FA404_52:;					
            L0E8FA404_52:
            ; //_A5A7AA303_185:;				
            _A5A7AA303_185:
            ; //	return;					
002B1:      	rets
            ; //_ToneVolCtrl03CF265A_end:;			
            _ToneVolCtrl03CF265A_end:
            ; //_A5A7AA303_186:;				
            _A5A7AA303_186:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_global_6037E6D5_s(void)	
            ginit_code_global_6037E6D5_s:
            ; //{
            ; //	return;					
002B2:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\GLOBAL_6037E6D5.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\KEYPAD_0E0216C1.S.CODE.ASM> Start=========================
            ; keypad.c Code Start!!;
            VarRM[0:4095]={
             L5589D4CE_62,L5589D4CE_63,L5589D4CE_64 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _InitKey3C587B6D();
            ; //rjmp void _PollingKey3B90E3B1();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _InitKey3C587B6D()			
            _InitKey3C587B6D:
            ; //{
            ; //_A5A7AA303_187:;				
            _A5A7AA303_187:
            ; //	
            ; //_A5A7AA303_188:;				
            _A5A7AA303_188:
            ; //	asm clr io[0x04].b0;			
002B3:      	clr io[0x04].b0//
            ; //_A5A7AA303_189:;				
            _A5A7AA303_189:
            ; //	asm clr io[0x04].b1;			
002B4:      	clr io[0x04].b1//
            ; //_A5A7AA303_190:;				
            _A5A7AA303_190:
            ; //	asm clr io[0x04].b2;			
002B5:      	clr io[0x04].b2//
            ; //_A5A7AA303_191:;				
            _A5A7AA303_191:
            ; //	asm clr io[0x04].b3;			
002B6:      	clr io[0x04].b3//
            ; //_A5A7AA303_192:;				
            _A5A7AA303_192:
            ; //	io[0x1E]	= 0x0005;		
002B7:      	AR	= 0x05
002B8:      	io[0x1E]	= AR
            ; //_A5A7AA303_193:;				
            _A5A7AA303_193:
            ; //	sAX	= 0x000F;			
002B9:      	AX	= 0x0F
            ; //	sAX	= sAX | io[0x1F];		
002BA:      	AR	= io[0x1F]
002BB:      	AX	|= AR
            ; //	io[0x1F]	= sAX;			
002BC:      	AR	= AX
002BD:      	io[0x1F]	= AR
            ; //_A5A7AA303_194:;				
            _A5A7AA303_194:
            ; //	sAX	= 0x0000;			
002BE:      	AX	= 0x00
            ; //	sSI	= (int)&L5589D4CE_62;		
002BF:      	I1	= L5589D4CE_62
            ; //	*(__int16*)sSI	= sAX			
002C0:      	rm[I1]	= AX
            ; //_A5A7AA303_195:;				
            _A5A7AA303_195:
            ; //	sAX	= 0x0000;			
002C1:      	AX	= 0x00
            ; //	sSI	= (int)&L5589D4CE_63;		
002C2:      	I1	= L5589D4CE_63
            ; //	*(__int16*)sSI	= sAX			
002C3:      	rm[I1]	= AX
            ; //_A5A7AA303_196:;				
            _A5A7AA303_196:
            ; //	sAX	= 0x0200;			
002C4:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_64;		
002C6:      	I1	= L5589D4CE_64
            ; //	*(__int16*)sSI	= sAX			
002C7:      	rm[I1]	= AX
            ; //L5589D4CE_65:;					
            L5589D4CE_65:
            ; //_A5A7AA303_197:;				
            _A5A7AA303_197:
            ; //	return;					
002C8:      	rets
            ; //_InitKey3C587B6D_end:;				
            _InitKey3C587B6D_end:
            ; //_A5A7AA303_198:;				
            _A5A7AA303_198:
            ; //}
            ; //
            ; //rjmp void L5589D4CE_66()			
            L5589D4CE_66:
            ; //{
            ; //	__int16 _btn_1_2;
            ; //						
002C9:      	AR	= rm[BP_SAVE]
002CA:      	push	AR
002CB:      	AR	= BP
002CC:      	rm[BP_SAVE]	= AR
002CD:      	AR	 = -1
002CE:      	BP	+= AR
            ; //_A5A7AA303_199:;				
            _A5A7AA303_199:
            ; //_A5A7AA303_200:;				
            _A5A7AA303_200:
            ; //	sAX	= 0x000F;			
002CF:      	AX	= 0x0F
            ; //	sAX	= sAX & io[0x07];		
002D0:      	AR	= io[0x07]
002D1:      	AX	&= AR
            ; //	sSI	= (int)&_btn_1_2;		
002D2:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
002D3:      	rm[I1]	= AX
            ; //_A5A7AA303_201:;				
            _A5A7AA303_201:
            ; //	sSI	= (int)&_btn_1_2;		
002D4:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
002D5:      	AX	= rm[I1]
            ; //	goto L5589D4CE_68;			
002D6:      	jmp	L5589D4CE_68
            ; //L5589D4CE_68:;					
            L5589D4CE_68:
            ; //_A5A7AA303_202:;				
            _A5A7AA303_202:
            ; //	return;					
002D7:      	AR	= 1
002D8:      	BP	+= AR
002D9:      	pop	AR
002DA:      	rm[BP_SAVE]	= AR
002DB:      	rets
            ; //L5589D4CE_66_end:;				
            L5589D4CE_66_end:
            ; //_A5A7AA303_203:;				
            _A5A7AA303_203:
            ; //}
            ; //
            ; //rjmp void _PollingKey3B90E3B1()			
            _PollingKey3B90E3B1:
            ; //{
            ; //	__int16 _keynow_1_2;
            ; //	__int16 _i_1_4;
            ; //	__int16 _bits_1_6;
            ; //	__int16 _bitp_1_8;
            ; //	__int16 _pkey_1_10;
            ; //						
002DC:      	AR	= rm[BP_SAVE]
002DD:      	push	AR
002DE:      	AR	= BP
002DF:      	rm[BP_SAVE]	= AR
002E0:      	AR	 = -5
002E1:      	BP	+= AR
            ; //_A5A7AA303_204:;				
            _A5A7AA303_204:
            ; //_A5A7AA303_205:;				
            _A5A7AA303_205:
            ; //_A5A7AA303_206:;				
            _A5A7AA303_206:
            ; //	NEARCALL(L5589D4CE_66);			
002E2:      	call	L5589D4CE_66
            ; //	sSI	= (int)&_keynow_1_2;		
002E3:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
002E4:      	rm[I1]	= AX
            ; //_A5A7AA303_207:;				
            _A5A7AA303_207:
            ; //	asm I1 = L5589D4CE_62+0;		
002E5:      	I1 = L5589D4CE_62+0//
            ; //	sAX	= *(__int16*)sSI;		
002E6:      	AX	= rm[I1]
            ; //	sSI	= (int)&_keynow_1_2;		
002E7:      	I1	= rm[BP_SAVE]
            ; //	sCX	= *(__int16*)sSI;		
002E8:      	CX	= rm[I1]
            ; //	sfx_CMP_AX_CX_JNE();			
002E9:      	pch	= sfx_CMP_AX_CX_JNE
002EA:      	lcall	sfx_CMP_AX_CX_JNE
            ; //	if(__je__)	goto L5589D4CE_71;	
002EB:      	if ZR	jmp L5589D4CE_71
            ; //	goto	L5589D4CE_70;			
002EC:      	jmp	L5589D4CE_70
            ; //L5589D4CE_71:;					
            L5589D4CE_71:
            ; //	
            ; //_A5A7AA303_208:;				
            _A5A7AA303_208:
            ; //	sSI	= (int)&_keynow_1_2;		
002ED:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
002EE:      	AX	= rm[I1]
            ; //	sSI	= (int)&L5589D4CE_62;		
002EF:      	I1	= L5589D4CE_62
            ; //	*(__int16*)sSI	= sAX			
002F0:      	rm[I1]	= AX
            ; //_A5A7AA303_209:;				
            _A5A7AA303_209:
            ; //	sAX	= 0x0200;			
002F1:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_64;		
002F3:      	I1	= L5589D4CE_64
            ; //	*(__int16*)sSI	= sAX			
002F4:      	rm[I1]	= AX
            ; //_A5A7AA303_210:;				
            _A5A7AA303_210:
            ; //	goto L5589D4CE_69;			
002F5:      	jmp	L5589D4CE_69
            ; //L5589D4CE_70:;					
            L5589D4CE_70:
            ; //_A5A7AA303_211:;				
            _A5A7AA303_211:
            ; //_A5A7AA303_212:;				
            _A5A7AA303_212:
            ; //	asm I1 = L5589D4CE_64+0;		
002F6:      	I1 = L5589D4CE_64+0//
            ; //	sAX	= *(__int16*)sSI;		
002F7:      	AX	= rm[I1]
            ; //	sfx_CHECKZERO();			
002F8:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_73;	
002F9:      	if NZ	jmp L5589D4CE_73
            ; //	goto	L5589D4CE_72;			
002FA:      	jmp	L5589D4CE_72
            ; //L5589D4CE_73:;					
            L5589D4CE_73:
            ; //	
            ; //_A5A7AA303_213:;				
            _A5A7AA303_213:
            ; //	asm I1 = L5589D4CE_64+0;		
002FB:      	I1 = L5589D4CE_64+0//
            ; //	sAX	= *(__int16*)sSI;		
002FC:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
002FD:      	CX	= 0x01
            ; //	sAX	= sAX - sCX;			
002FE:      	AR	= CX
002FF:      	AX	-= AR
            ; //	sSI	= (int)&L5589D4CE_64;		
00300:      	I1	= L5589D4CE_64
            ; //	*(__int16*)sSI	= sAX			
00301:      	rm[I1]	= AX
            ; //_A5A7AA303_214:;				
            _A5A7AA303_214:
            ; //	goto L5589D4CE_69;			
00302:      	jmp	L5589D4CE_69
            ; //L5589D4CE_72:;					
            L5589D4CE_72:
            ; //_A5A7AA303_215:;				
            _A5A7AA303_215:
            ; //_A5A7AA303_216:;				
            _A5A7AA303_216:
            ; //	asm AX = #_keyfuncF06F3D55+0;		
00303:      	AX = #_keyfuncF06F3D55+0//
            ; //	sSI	= (int)&_pkey_1_10;		
00305:      	AR	= -4
00306:      	I1	= rm[BP_SAVE]
00307:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00308:      	rm[I1]	= AX
            ; //_A5A7AA303_217:;				
            _A5A7AA303_217:
            ; //	sAX	= 0x0200;			
00309:      	AX	= 0x0200
            ; //	sSI	= (int)&L5589D4CE_64;		
0030B:      	I1	= L5589D4CE_64
            ; //	*(__int16*)sSI	= sAX			
0030C:      	rm[I1]	= AX
            ; //_A5A7AA303_218:;				
            _A5A7AA303_218:
            ; //	asm I1 = L5589D4CE_63+0;		
0030D:      	I1 = L5589D4CE_63+0//
            ; //	sAX	= *(__int16*)sSI;		
0030E:      	AX	= rm[I1]
            ; //	asm I1 = L5589D4CE_62+0;		
0030F:      	I1 = L5589D4CE_62+0//
            ; //	asm AR = rm[I1];			
00310:      	AR = rm[I1]//
            ; //	asm AX = AX ^ AR;			
00311:      	AX = AX ^ AR//
            ; //	sSI	= (int)&_bits_1_6;		
00312:      	AR	= -2
00313:      	I1	= rm[BP_SAVE]
00314:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
00315:      	rm[I1]	= AX
            ; //_A5A7AA303_219:;				
            _A5A7AA303_219:
            ; //	asm I1 = L5589D4CE_63+0;		
00316:      	I1 = L5589D4CE_63+0//
            ; //	sAX	= *(__int16*)sSI;		
00317:      	AX	= rm[I1]
            ; //	sSI	= (int)&_bitp_1_8;		
00318:      	AR	= -3
00319:      	I1	= rm[BP_SAVE]
0031A:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
0031B:      	rm[I1]	= AX
            ; //_A5A7AA303_220:;				
            _A5A7AA303_220:
            ; //	asm I1 = L5589D4CE_62+0;		
0031C:      	I1 = L5589D4CE_62+0//
            ; //	sAX	= *(__int16*)sSI;		
0031D:      	AX	= rm[I1]
            ; //	sSI	= (int)&L5589D4CE_63;		
0031E:      	I1	= L5589D4CE_63
            ; //	*(__int16*)sSI	= sAX			
0031F:      	rm[I1]	= AX
            ; //_A5A7AA303_221:;				
            _A5A7AA303_221:
            ; //	_i_1_4+0	= 0x05;			
00320:      	AR	= -1
00321:      	I1	= rm[BP_SAVE]
00322:      	I1	+= AR
00323:      	AR	= 0x05
00324:      	rm[I1]	= AR
            ; //L5589D4CE_75:;					
            L5589D4CE_75:
            ; //_A5A7AA303_222:;				
            _A5A7AA303_222:
            ; //	sSI	= (int)&_i_1_4;			
00325:      	AR	= -1
00326:      	I1	= rm[BP_SAVE]
00327:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00328:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_4;			
00329:      	AR	= -1
0032A:      	I1	= rm[BP_SAVE]
0032B:      	I1	+= AR
            ; //	asm AR = 0x0001;			
0032C:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
0032D:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
0032E:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
0032F:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_76;	
00330:      	if NZ	jmp L5589D4CE_76
            ; //	goto	L5589D4CE_74;			
00331:      	jmp	L5589D4CE_74
            ; //L5589D4CE_76:;					
            L5589D4CE_76:
            ; //	
            ; //_A5A7AA303_223:;				
            _A5A7AA303_223:
            ; //	sAX	= 0;				
00332:      	AX	= 0x00
            ; //	sSI	= (int)&_bits_1_6+0;		
00333:      	AR	= -2
00334:      	I1	= rm[BP_SAVE]
00335:      	I1	+= AR
            ; //	asm AR = rm[I1];			
00336:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
00337:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_78;		
00338:      	if ZR	jmp L5589D4CE_78
            ; //	sAX	= 1;				
00339:      	AX	= 0x01
            ; //L5589D4CE_78:;					
            L5589D4CE_78:
            ; //	sfx_CHECKZERO();			
0033A:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_79;	
0033B:      	if NZ	jmp L5589D4CE_79
            ; //	goto	L5589D4CE_77;			
0033C:      	jmp	L5589D4CE_77
            ; //L5589D4CE_79:;					
            L5589D4CE_79:
            ; //	
            ; //_A5A7AA303_224:;				
            _A5A7AA303_224:
            ; //	sAX	= 0;				
0033D:      	AX	= 0x00
            ; //	sSI	= (int)&_bitp_1_8+0;		
0033E:      	AR	= -3
0033F:      	I1	= rm[BP_SAVE]
00340:      	I1	+= AR
            ; //	asm AR = rm[I1];			
00341:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
00342:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_81;		
00343:      	if ZR	jmp L5589D4CE_81
            ; //	sAX	= 1;				
00344:      	AX	= 0x01
            ; //L5589D4CE_81:;					
            L5589D4CE_81:
            ; //	sfx_CHECKZERO();			
00345:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_82;	
00346:      	if NZ	jmp L5589D4CE_82
            ; //	goto	L5589D4CE_80;			
00347:      	jmp	L5589D4CE_80
            ; //L5589D4CE_82:;					
            L5589D4CE_82:
            ; //	
            ; //_A5A7AA303_225:;				
            _A5A7AA303_225:
            ; //	sSI	= (int)&_pkey_1_10;		
00348:      	AR	= -4
00349:      	I1	= rm[BP_SAVE]
0034A:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
0034B:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
0034C:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
0034D:      	AR	= CX
0034E:      	AX	+= AR
            ; //	sDI	= sAX;				
0034F:      	AR	= AX
00350:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
00351:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
00352:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_84;	
00353:      	if NZ	jmp L5589D4CE_84
            ; //	goto	L5589D4CE_83;			
00354:      	jmp	L5589D4CE_83
            ; //L5589D4CE_84:;					
            L5589D4CE_84:
            ; //_A5A7AA303_226:;				
            _A5A7AA303_226:
            ; //	sSI	= (int)&_pkey_1_10;		
00355:      	AR	= -4
00356:      	I1	= rm[BP_SAVE]
00357:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00358:      	AX	= rm[I1]
            ; //	sCX	= 0x0002;			
00359:      	CX	= 0x02
            ; //	sAX	= sAX + sCX;			
0035A:      	AR	= CX
0035B:      	AX	+= AR
            ; //	sDI	= sAX;				
0035C:      	AR	= AX
0035D:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
0035E:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
0035F:      	AR	= AX
00360:      	P1	= AR
00361:      	P1.hh	= 0
00362:      	fcall	pm[P1]
            ; //L5589D4CE_83:;					
            L5589D4CE_83:
            ; //_A5A7AA303_227:;				
            _A5A7AA303_227:
            ; //	goto L5589D4CE_85;			
00363:      	jmp	L5589D4CE_85
            ; //L5589D4CE_80:;					
            L5589D4CE_80:
            ; //	
            ; //_A5A7AA303_228:;				
            _A5A7AA303_228:
            ; //	sSI	= (int)&_pkey_1_10;		
00364:      	AR	= -4
00365:      	I1	= rm[BP_SAVE]
00366:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00367:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
00368:      	AR	= AX
00369:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
0036A:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
0036B:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_87;	
0036C:      	if NZ	jmp L5589D4CE_87
            ; //	goto	L5589D4CE_86;			
0036D:      	jmp	L5589D4CE_86
            ; //L5589D4CE_87:;					
            L5589D4CE_87:
            ; //_A5A7AA303_229:;				
            _A5A7AA303_229:
            ; //	sSI	= (int)&_pkey_1_10;		
0036E:      	AR	= -4
0036F:      	I1	= rm[BP_SAVE]
00370:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00371:      	AX	= rm[I1]
            ; //	sDI	= sAX;				
00372:      	AR	= AX
00373:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
00374:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
00375:      	AR	= AX
00376:      	P1	= AR
00377:      	P1.hh	= 0
00378:      	fcall	pm[P1]
            ; //L5589D4CE_86:;					
            L5589D4CE_86:
            ; //_A5A7AA303_230:;				
            _A5A7AA303_230:
            ; //L5589D4CE_85:;					
            L5589D4CE_85:
            ; //_A5A7AA303_231:;				
            _A5A7AA303_231:
            ; //	goto L5589D4CE_88;			
00379:      	jmp	L5589D4CE_88
            ; //L5589D4CE_77:;					
            L5589D4CE_77:
            ; //	
            ; //_A5A7AA303_232:;				
            _A5A7AA303_232:
            ; //	sAX	= 0;				
0037A:      	AX	= 0x00
            ; //	sSI	= (int)&_bitp_1_8+0;		
0037B:      	AR	= -3
0037C:      	I1	= rm[BP_SAVE]
0037D:      	I1	+= AR
            ; //	asm AR = rm[I1];			
0037E:      	AR = rm[I1]//
            ; //	asm test AR.b0;				
0037F:      	test AR.b0//
            ; //	if(__jz__) goto L5589D4CE_90;		
00380:      	if ZR	jmp L5589D4CE_90
            ; //	sAX	= 1;				
00381:      	AX	= 0x01
            ; //L5589D4CE_90:;					
            L5589D4CE_90:
            ; //	sfx_CHECKZERO();			
00382:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_91;	
00383:      	if NZ	jmp L5589D4CE_91
            ; //	goto	L5589D4CE_89;			
00384:      	jmp	L5589D4CE_89
            ; //L5589D4CE_91:;					
            L5589D4CE_91:
            ; //	
            ; //_A5A7AA303_233:;				
            _A5A7AA303_233:
            ; //	sSI	= (int)&_pkey_1_10;		
00385:      	AR	= -4
00386:      	I1	= rm[BP_SAVE]
00387:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00388:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
00389:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
0038A:      	AR	= CX
0038B:      	AX	+= AR
            ; //	sDI	= sAX;				
0038C:      	AR	= AX
0038D:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
0038E:      	AX	= pm[P1]
            ; //	sfx_CHECKZERO();			
0038F:      	AR	= AX
            ; //	if(__jnz__)	goto L5589D4CE_93;	
00390:      	if NZ	jmp L5589D4CE_93
            ; //	goto	L5589D4CE_92;			
00391:      	jmp	L5589D4CE_92
            ; //L5589D4CE_93:;					
            L5589D4CE_93:
            ; //_A5A7AA303_234:;				
            _A5A7AA303_234:
            ; //	sSI	= (int)&_pkey_1_10;		
00392:      	AR	= -4
00393:      	I1	= rm[BP_SAVE]
00394:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
00395:      	AX	= rm[I1]
            ; //	sCX	= 0x0001;			
00396:      	CX	= 0x01
            ; //	sAX	= sAX + sCX;			
00397:      	AR	= CX
00398:      	AX	+= AR
            ; //	sDI	= sAX;				
00399:      	AR	= AX
0039A:      	P1	= AR
            ; //	sAX	= *(__int16*)sDI;		
0039B:      	AX	= pm[P1]
            ; //	sfx_CALL_BY_AX();			
0039C:      	AR	= AX
0039D:      	P1	= AR
0039E:      	P1.hh	= 0
0039F:      	fcall	pm[P1]
            ; //L5589D4CE_92:;					
            L5589D4CE_92:
            ; //_A5A7AA303_235:;				
            _A5A7AA303_235:
            ; //L5589D4CE_89:;					
            L5589D4CE_89:
            ; //_A5A7AA303_236:;				
            _A5A7AA303_236:
            ; //L5589D4CE_88:;					
            L5589D4CE_88:
            ; //_A5A7AA303_237:;				
            _A5A7AA303_237:
            ; //_A5A7AA303_238:;				
            _A5A7AA303_238:
            ; //	sSI	= (int)&_bits_1_6;		
003A0:      	AR	= -2
003A1:      	I1	= rm[BP_SAVE]
003A2:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003A3:      	AX	= rm[I1]
            ; //	asm sra AX, 1;				
003A4:      	sra AX, 1//
            ; //	sSI	= (int)&_bits_1_6;		
003A5:      	AR	= -2
003A6:      	I1	= rm[BP_SAVE]
003A7:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
003A8:      	rm[I1]	= AX
            ; //_A5A7AA303_239:;				
            _A5A7AA303_239:
            ; //	sSI	= (int)&_bitp_1_8;		
003A9:      	AR	= -3
003AA:      	I1	= rm[BP_SAVE]
003AB:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003AC:      	AX	= rm[I1]
            ; //	asm sra AX, 1;				
003AD:      	sra AX, 1//
            ; //	sSI	= (int)&_bitp_1_8;		
003AE:      	AR	= -3
003AF:      	I1	= rm[BP_SAVE]
003B0:      	I1	+= AR
            ; //	*(__int16*)sSI	= sAX;			
003B1:      	rm[I1]	= AX
            ; //_A5A7AA303_240:;				
            _A5A7AA303_240:
            ; //	sSI	= (int)&_pkey_1_10;		
003B2:      	AR	= -4
003B3:      	I1	= rm[BP_SAVE]
003B4:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI;		
003B5:      	AX	= rm[I1]
            ; //	sSI	= (int)&_pkey_1_10;		
003B6:      	AR	= -4
003B7:      	I1	= rm[BP_SAVE]
003B8:      	I1	+= AR
            ; //	asm AR = 0x0003;			
003B9:      	AR = 0x0003//
            ; //	sCX	= *(__int16*)sSI;		
003BA:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX + AR;			
003BB:      	rm[I1] = CX + AR//
            ; //	goto L5589D4CE_75;			
003BC:      	jmp	L5589D4CE_75
            ; //L5589D4CE_74:;					
            L5589D4CE_74:
            ; //L5589D4CE_69:;					
            L5589D4CE_69:
            ; //_A5A7AA303_241:;				
            _A5A7AA303_241:
            ; //	return;					
003BD:      	AR	= 5
003BE:      	BP	+= AR
003BF:      	pop	AR
003C0:      	rm[BP_SAVE]	= AR
003C1:      	rets
            ; //_PollingKey3B90E3B1_end:;			
            _PollingKey3B90E3B1_end:
            ; //_A5A7AA303_242:;				
            _A5A7AA303_242:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_keypad_0E0216C1_s(void)	
            ginit_code_keypad_0E0216C1_s:
            ; //{
            ; //	return;					
003C2:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\KEYPAD_0E0216C1.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\LED_376AFC9D.S.CODE.ASM> Start=========================
            ; led.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _KeyShowLEDA84888EC();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _KeyShowLEDA84888EC()			
            _KeyShowLEDA84888EC:
            ; //{
            ; //_A5A7AA303_243:;				
            _A5A7AA303_243:
            ; //	
            ; //_A5A7AA303_244:;				
            _A5A7AA303_244:
            ; //	sAX	= 0x0001;			
003C3:      	AX	= 0x01
            ; //	asm I1 = dtxtonech+7;			
003C4:      	I1 = dtxtonech+7//
            ; //	asm AR = rm[I1];			
003C6:      	AR = rm[I1]//
            ; //	asm AX = AX & AR;			
003C7:      	AX = AX & AR//
            ; //	sfx_CHECKZERO();			
003C8:      	AR	= AX
            ; //	if(__jz__) goto L7573600E_96;		
003C9:      	if ZR	jmp L7573600E_96
            ; //	asm set io[0x09].b0;			
003CA:      	set io[0x09].b0//
            ; //	goto	L7573600E_97;			
003CB:      	jmp	L7573600E_97
            ; //L7573600E_96:;					
            L7573600E_96:
            ; //	asm clr io[0x09].b0;			
003CC:      	clr io[0x09].b0//
            ; //L7573600E_97:;					
            L7573600E_97:
            ; //_A5A7AA303_245:;				
            _A5A7AA303_245:
            ; //	sAX	= 0x0002;			
003CD:      	AX	= 0x02
            ; //	asm I1 = dtxtonech+7;			
003CE:      	I1 = dtxtonech+7//
            ; //	asm AR = rm[I1];			
003D0:      	AR = rm[I1]//
            ; //	asm AX = AX & AR;			
003D1:      	AX = AX & AR//
            ; //	sfx_CHECKZERO();			
003D2:      	AR	= AX
            ; //	if(__jz__) goto L7573600E_98;		
003D3:      	if ZR	jmp L7573600E_98
            ; //	asm set io[0x09].b1;			
003D4:      	set io[0x09].b1//
            ; //	goto	L7573600E_99;			
003D5:      	jmp	L7573600E_99
            ; //L7573600E_98:;					
            L7573600E_98:
            ; //	asm clr io[0x09].b1;			
003D6:      	clr io[0x09].b1//
            ; //L7573600E_99:;					
            L7573600E_99:
            ; //L7573600E_95:;					
            L7573600E_95:
            ; //_A5A7AA303_246:;				
            _A5A7AA303_246:
            ; //	return;					
003D7:      	rets
            ; //_KeyShowLEDA84888EC_end:;			
            _KeyShowLEDA84888EC_end:
            ; //_A5A7AA303_247:;				
            _A5A7AA303_247:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_led_376AFC9D_s(void)	
            ginit_code_led_376AFC9D_s:
            ; //{
            ; //	return;					
003D8:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\LED_376AFC9D.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\SUB3PLAY_8ED4FA41.S.CODE.ASM> Start=========================
            ; sub3play.c Code Start!!;
            VarRM[0:4095]={
             bts_ch0_get_ix[2],PCMYIN_PTR,PCMYOU_PTR,PCMIN,SampleCh0Rate,BaseOn512#PCMY[512],SUBFLTI[4],SUBFLTA
            ,SUBFLTP,SUBFLTG 
            };
            
            ; //
            .code
            ; //
            ; //
            ; //rjmp void _ClearRenderBufB079D01D();
            ; //rjmp void _Sub3Initial96BE24F3();
            ; //rjmp void _WaitPCM_Empty_size53398B9D();
            ; //rjmp void _Sub3ZeroFillABFF23AA();
            ; //rjmp void _Sub3Play422CAD6D(__int16 _sdata_0_4_0, __int16 _sdata_0_4_1);
            ; //naked rjmp void Sbb_Ch0GetBts();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            .code
            ; //rjmp void _ClearRenderBufB079D01D()		
            _ClearRenderBufB079D01D:
            ; //{
            ; //	__int16 _i_1_2;
            ; //						
003D9:      	AR	= rm[BP_SAVE]
003DA:      	push	AR
003DB:      	AR	= BP
003DC:      	rm[BP_SAVE]	= AR
003DD:      	AR	 = -1
003DE:      	BP	+= AR
            ; //_A5A7AA303_248:;				
            _A5A7AA303_248:
            ; //	
            ; //_A5A7AA303_249:;				
            _A5A7AA303_249:
            ; //	asm AX = PCMY+0;			
003DF:      	AX = PCMY+0//
            ; //_A5A7AA303_250:;				
            _A5A7AA303_250:
            ; //	asm	AR = AX				
003E1:      	AR = AX
            ; //_A5A7AA303_251:;				
            _A5A7AA303_251:
            ; //	asm	I0 = AR				
003E2:      	I0 = AR
            ; //_A5A7AA303_252:;				
            _A5A7AA303_252:
            ; //	_i_1_2+0	= 0x0200;		
003E3:      	I1	= rm[BP_SAVE]
003E4:      	AR	= 0x0200
003E6:      	rm[I1]	= AR
            ; //LFB78B58C_103:;					
            LFB78B58C_103:
            ; //_A5A7AA303_253:;				
            _A5A7AA303_253:
            ; //	sSI	= (int)&_i_1_2;			
003E7:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
003E8:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
003E9:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
003EA:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
003EB:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
003EC:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
003ED:      	AR	= AX
            ; //	if(__jnz__)	goto LFB78B58C_104;	
003EE:      	if NZ	jmp LFB78B58C_104
            ; //	goto	LFB78B58C_102;			
003EF:      	jmp	LFB78B58C_102
            ; //LFB78B58C_104:;					
            LFB78B58C_104:
            ; //	
            ; //_A5A7AA303_254:;				
            _A5A7AA303_254:
            ; //	sAX	= 0x0000;			
003F0:      	AX	= 0x00
            ; //_A5A7AA303_255:;				
            _A5A7AA303_255:
            ; //	asm	rm[I0++] = AX			
003F1:      	rm[I0++] = AX
            ; //	goto LFB78B58C_103;			
003F2:      	jmp	LFB78B58C_103
            ; //LFB78B58C_102:;					
            LFB78B58C_102:
            ; //LFB78B58C_101:;					
            LFB78B58C_101:
            ; //_A5A7AA303_256:;				
            _A5A7AA303_256:
            ; //	return;					
003F3:      	AR	= 1
003F4:      	BP	+= AR
003F5:      	pop	AR
003F6:      	rm[BP_SAVE]	= AR
003F7:      	rets
            ; //_ClearRenderBufB079D01D_end:;			
            _ClearRenderBufB079D01D_end:
            ; //_A5A7AA303_257:;				
            _A5A7AA303_257:
            ; //}
            ; //
            ; //rjmp void _Sub3Initial96BE24F3()		
            _Sub3Initial96BE24F3:
            ; //{
            ; //_A5A7AA303_258:;				
            _A5A7AA303_258:
            ; //_A5A7AA303_259:;				
            _A5A7AA303_259:
            ; //	asm	dsi				
003F8:      	dsi
            ; //_A5A7AA303_260:;				
            _A5A7AA303_260:
            ; //	asm	nop				
003F9:      	nop
            ; //	
            ; //_A5A7AA303_261:;				
            _A5A7AA303_261:
            ; //_A5A7AA303_262:;				
            _A5A7AA303_262:
            ; //	_ClearRenderBufB079D01D();		
003FA:      	pch	= _ClearRenderBufB079D01D
003FB:      	lcall	_ClearRenderBufB079D01D
            ; //_A5A7AA303_263:;				
            _A5A7AA303_263:
            ; //	asm	AR = PASR,0			
003FC:      	AR = PASR,0
            ; //_A5A7AA303_264:;				
            _A5A7AA303_264:
            ; //	asm AX = PCMY+0;			
003FD:      	AX = PCMY+0//
            ; //	asm I1 = PCMYIN_PTR+0;			
003FF:      	I1 = PCMYIN_PTR+0//
            ; //	*(__int16*)sSI	= sAX			
00400:      	rm[I1]	= AX
            ; //_A5A7AA303_265:;				
            _A5A7AA303_265:
            ; //	asm AX = PCMY+0;			
00401:      	AX = PCMY+0//
            ; //	asm I1 = PCMYOU_PTR+0;			
00403:      	I1 = PCMYOU_PTR+0//
            ; //	*(__int16*)sSI	= sAX			
00404:      	rm[I1]	= AX
            ; //_A5A7AA303_266:;				
            _A5A7AA303_266:
            ; //	io[0x3C]	= 0x0000;		
00405:      	AR	= 0x00
00406:      	io[0x3C]	= AR
            ; //_A5A7AA303_267:;				
            _A5A7AA303_267:
            ; //	io[0x3E]	= 0x1FFF;		
00407:      	AR	= 0x1FFF
00409:      	io[0x3E]	= AR
            ; //_A5A7AA303_268:;				
            _A5A7AA303_268:
            ; //	io[0x3B]	= 0x0000;		
0040A:      	AR	= 0x00
0040B:      	io[0x3B]	= AR
            ; //_A5A7AA303_269:;				
            _A5A7AA303_269:
            ; //_A5A7AA303_270:;				
            _A5A7AA303_270:
            ; //	Subb3_Init();				
0040C:      	pch	= Subb3_Init
0040D:      	lcall	Subb3_Init
            ; //LFB78B58C_105:;					
            LFB78B58C_105:
            ; //_A5A7AA303_271:;				
            _A5A7AA303_271:
            ; //	return;					
0040E:      	rets
            ; //_Sub3Initial96BE24F3_end:;			
            _Sub3Initial96BE24F3_end:
            ; //_A5A7AA303_272:;				
            _A5A7AA303_272:
            ; //}
            ; //
            ; //rjmp void _WaitPCM_Empty_size53398B9D()		
            _WaitPCM_Empty_size53398B9D:
            ; //{
            ; //	__int16 _x_1_2;
            ; //						
0040F:      	AR	= rm[BP_SAVE]
00410:      	push	AR
00411:      	AR	= BP
00412:      	rm[BP_SAVE]	= AR
00413:      	AR	 = -1
00414:      	BP	+= AR
            ; //_A5A7AA303_273:;				
            _A5A7AA303_273:
            ; //_A5A7AA303_274:;				
            _A5A7AA303_274:
            ; //	asm I1 = PCMYOU_PTR+0;			
00415:      	I1 = PCMYOU_PTR+0//
            ; //	sAX	= *(__int16*)sSI;		
00416:      	AX	= rm[I1]
            ; //	asm I1 = PCMYIN_PTR+0;			
00417:      	I1 = PCMYIN_PTR+0//
            ; //	sCX	= *(__int16*)sSI;		
00418:      	CX	= rm[I1]
            ; //	sAX	= sAX - sCX;			
00419:      	AR	= CX
0041A:      	AX	-= AR
            ; //	
            ; //	sSI	= (int)&_x_1_2;			
0041B:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
0041C:      	rm[I1]	= AX
            ; //_A5A7AA303_275:;				
            _A5A7AA303_275:
            ; //	sSI	= (int)&_x_1_2;			
0041D:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0041E:      	AX	= rm[I1]
            ; //	sCX	= 0x0000;			
0041F:      	CX	= 0x00
            ; //	sfx_CMP_AX_CX_JL();			
00420:      	pch	= sfx_CMP_AX_CX_JL
00421:      	lcall	sfx_CMP_AX_CX_JL
            ; //	if(__je__)	goto LFB78B58C_108;	
00422:      	if ZR	jmp LFB78B58C_108
            ; //	goto	LFB78B58C_107;			
00423:      	jmp	LFB78B58C_107
            ; //LFB78B58C_108:;					
            LFB78B58C_108:
            ; //	
            ; //_A5A7AA303_276:;				
            _A5A7AA303_276:
            ; //	sAX	= 0x01FF;			
00424:      	AX	= 0x01FF
            ; //	sSI	= (int)&_x_1_2;			
00426:      	I1	= rm[BP_SAVE]
            ; //	sCX	= *(__int16*)sSI;		
00427:      	CX	= rm[I1]
            ; //	sAX	= sAX & sCX;			
00428:      	AR	= CX
00429:      	AX	&= AR
            ; //	sSI	= (int)&_x_1_2;			
0042A:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
0042B:      	rm[I1]	= AX
            ; //LFB78B58C_107:;					
            LFB78B58C_107:
            ; //_A5A7AA303_277:;				
            _A5A7AA303_277:
            ; //_A5A7AA303_278:;				
            _A5A7AA303_278:
            ; //	sSI	= (int)&_x_1_2;			
0042C:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0042D:      	AX	= rm[I1]
            ; //	sCX	= 0x0121;			
0042E:      	CX	= 0x0121
            ; //	sAX	= sAX - sCX;			
00430:      	AR	= CX
00431:      	AX	-= AR
            ; //	sSI	= (int)&_x_1_2;			
00432:      	I1	= rm[BP_SAVE]
            ; //	*(__int16*)sSI	= sAX;			
00433:      	rm[I1]	= AX
            ; //_A5A7AA303_279:;				
            _A5A7AA303_279:
            ; //	sSI	= (int)&_x_1_2;			
00434:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
00435:      	AX	= rm[I1]
            ; //	goto LFB78B58C_106;			
00436:      	jmp	LFB78B58C_106
            ; //LFB78B58C_106:;					
            LFB78B58C_106:
            ; //_A5A7AA303_280:;				
            _A5A7AA303_280:
            ; //	return;					
00437:      	AR	= 1
00438:      	BP	+= AR
00439:      	pop	AR
0043A:      	rm[BP_SAVE]	= AR
0043B:      	rets
            ; //_WaitPCM_Empty_size53398B9D_end:;		
            _WaitPCM_Empty_size53398B9D_end:
            ; //_A5A7AA303_281:;				
            _A5A7AA303_281:
            ; //}
            ; //
            ; //rjmp void _Sub3ZeroFillABFF23AA()		
            _Sub3ZeroFillABFF23AA:
            ; //{
            ; //	__int16 _i_1_2;
            ; //						
0043C:      	AR	= rm[BP_SAVE]
0043D:      	push	AR
0043E:      	AR	= BP
0043F:      	rm[BP_SAVE]	= AR
00440:      	AR	 = -1
00441:      	BP	+= AR
            ; //_A5A7AA303_282:;				
            _A5A7AA303_282:
            ; //_A5A7AA303_283:;				
            _A5A7AA303_283:
            ; //	asm	push CBL			
00442:      	push CBL
            ; //_A5A7AA303_284:;				
            _A5A7AA303_284:
            ; //	io[0x3B]	= 0x0009;		
00443:      	AR	= 0x09
00444:      	io[0x3B]	= AR
            ; //	
            ; //_A5A7AA303_285:;				
            _A5A7AA303_285:
            ; //	asm I1 = PCMYIN_PTR+0;			
00445:      	I1 = PCMYIN_PTR+0//
            ; //	sAX	= *(__int16*)sSI;		
00446:      	AX	= rm[I1]
            ; //_A5A7AA303_286:;				
            _A5A7AA303_286:
            ; //	asm	AR = AX				
00447:      	AR = AX
            ; //_A5A7AA303_287:;				
            _A5A7AA303_287:
            ; //	asm	I0 = AR				
00448:      	I0 = AR
            ; //_A5A7AA303_288:;				
            _A5A7AA303_288:
            ; //	_i_1_2+0	= 0x0120;		
00449:      	I1	= rm[BP_SAVE]
0044A:      	AR	= 0x0120
0044C:      	rm[I1]	= AR
            ; //LFB78B58C_111:;					
            LFB78B58C_111:
            ; //_A5A7AA303_289:;				
            _A5A7AA303_289:
            ; //	sSI	= (int)&_i_1_2;			
0044D:      	I1	= rm[BP_SAVE]
            ; //	sAX	= *(__int16*)sSI;		
0044E:      	AX	= rm[I1]
            ; //	sSI	= (int)&_i_1_2;			
0044F:      	I1	= rm[BP_SAVE]
            ; //	asm AR = 0x0001;			
00450:      	AR = 0x0001//
            ; //	sCX	= *(__int16*)sSI;		
00451:      	CX	= rm[I1]
            ; //	asm rm[I1] = CX - AR;			
00452:      	rm[I1] = CX - AR//
            ; //	sfx_CHECKZERO();			
00453:      	AR	= AX
            ; //	if(__jnz__)	goto LFB78B58C_112;	
00454:      	if NZ	jmp LFB78B58C_112
            ; //	goto	LFB78B58C_110;			
00455:      	jmp	LFB78B58C_110
            ; //LFB78B58C_112:;					
            LFB78B58C_112:
            ; //	
            ; //_A5A7AA303_290:;				
            _A5A7AA303_290:
            ; //	sAX	= 0x0000;			
00456:      	AX	= 0x00
            ; //_A5A7AA303_291:;				
            _A5A7AA303_291:
            ; //	asm	rm[I0++] = AX			
00457:      	rm[I0++] = AX
            ; //	goto LFB78B58C_111;			
00458:      	jmp	LFB78B58C_111
            ; //LFB78B58C_110:;					
            LFB78B58C_110:
            ; //_A5A7AA303_292:;				
            _A5A7AA303_292:
            ; //_A5A7AA303_293:;				
            _A5A7AA303_293:
            ; //	get_I0();				
00459:      	push	I0
0045A:      	pop	AX
            ; //	asm I1 = PCMYIN_PTR+0;			
0045B:      	I1 = PCMYIN_PTR+0//
            ; //	*(__int16*)sSI	= sAX			
0045C:      	rm[I1]	= AX
            ; //_A5A7AA303_294:;				
            _A5A7AA303_294:
            ; //	asm	pop CBL				
0045D:      	pop CBL
            ; //LFB78B58C_109:;					
            LFB78B58C_109:
            ; //_A5A7AA303_295:;				
            _A5A7AA303_295:
            ; //	return;					
0045E:      	AR	= 1
0045F:      	BP	+= AR
00460:      	pop	AR
00461:      	rm[BP_SAVE]	= AR
00462:      	rets
            ; //_Sub3ZeroFillABFF23AA_end:;			
            _Sub3ZeroFillABFF23AA_end:
            ; //_A5A7AA303_296:;				
            _A5A7AA303_296:
            ; //}
            ; //
            ; //rjmp void _Sub3Play422CAD6D(__int16 _sdata_0_4_0, __int16 _sdata_0_4_1)
            _Sub3Play422CAD6D:
            ; //{						
00463:      	AR	= rm[BP_SAVE]
00464:      	push	AR
00465:      	AR	= BP
00466:      	rm[BP_SAVE]	= AR
            ; //_A5A7AA303_297:;				
            _A5A7AA303_297:
            ; //	
            ; //_A5A7AA303_298:;				
            _A5A7AA303_298:
            ; //_A5A7AA303_299:;				
            _A5A7AA303_299:
            ; //	dtxStopSong();				
00467:      	pch	= dtxStopSong
00468:      	lcall	dtxStopSong
            ; //_A5A7AA303_300:;				
            _A5A7AA303_300:
            ; //	sSI	= (int)&_sdata_0_4_0;		
00469:      	AR	= 2
0046A:      	I1	= rm[BP_SAVE]
0046B:      	I1	+= AR
            ; //	sAX	= *(__int16*)sSI++;		
0046C:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
0046D:      	DX	= rm[I1--]
            ; //	asm I1 = bts_ch0_get_ix+0;		
0046E:      	I1 = bts_ch0_get_ix+0//
            ; //	sfx_STORSILONG();			
0046F:      	rm[I1++]	= AX
00470:      	rm[I1--]	= DX
            ; //_A5A7AA303_301:;				
            _A5A7AA303_301:
            ; //_A5A7AA303_302:;				
            _A5A7AA303_302:
            ; //	_Sub3Initial96BE24F3();			
00471:      	pch	= _Sub3Initial96BE24F3
00472:      	lcall	_Sub3Initial96BE24F3
            ; //_A5A7AA303_303:;				
            _A5A7AA303_303:
            ; //	asm AX = SUBFLTI+0;			
00473:      	AX = SUBFLTI+0//
            ; //	PUSH(sAX);				
00474:      	push	AX
            ; //	sAX	= 0x0000;			
00475:      	AX	= 0x00
            ; //	sSI	= POP();			
00476:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00477:      	rm[I1]	= AX
            ; //_A5A7AA303_304:;				
            _A5A7AA303_304:
            ; //	asm AX = SUBFLTI+1;			
00478:      	AX = SUBFLTI+1//
            ; //	PUSH(sAX);				
00479:      	push	AX
            ; //	sAX	= 0x0000;			
0047A:      	AX	= 0x00
            ; //	sSI	= POP();			
0047B:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
0047C:      	rm[I1]	= AX
            ; //_A5A7AA303_305:;				
            _A5A7AA303_305:
            ; //	asm AX = SUBFLTI+2;			
0047D:      	AX = SUBFLTI+2//
            ; //	PUSH(sAX);				
0047E:      	push	AX
            ; //	sAX	= 0x0000;			
0047F:      	AX	= 0x00
            ; //	sSI	= POP();			
00480:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00481:      	rm[I1]	= AX
            ; //_A5A7AA303_306:;				
            _A5A7AA303_306:
            ; //	asm AX = SUBFLTI+3;			
00482:      	AX = SUBFLTI+3//
            ; //	PUSH(sAX);				
00483:      	push	AX
            ; //	sAX	= 0x0000;			
00484:      	AX	= 0x00
            ; //	sSI	= POP();			
00485:      	pop	I1
            ; //	*(__int16*)sSI	= sAX;			
00486:      	rm[I1]	= AX
            ; //_A5A7AA303_307:;				
            _A5A7AA303_307:
            ; //	sAX	= 0x0000;			
00487:      	AX	= 0x00
            ; //	asm I1 = SUBFLTA+0;			
00488:      	I1 = SUBFLTA+0//
            ; //	*(__int16*)sSI	= sAX			
00489:      	rm[I1]	= AX
            ; //_A5A7AA303_308:;				
            _A5A7AA303_308:
            ; //	asm I1 = SampleCh0Rate+0;		
0048A:      	I1 = SampleCh0Rate+0//
            ; //	sAX	= *(__int16*)sSI;		
0048B:      	AX	= rm[I1]
            ; //	asm I1 = SUBFLTP+0;			
0048C:      	I1 = SUBFLTP+0//
            ; //	*(__int16*)sSI	= sAX			
0048D:      	rm[I1]	= AX
            ; //_A5A7AA303_309:;				
            _A5A7AA303_309:
            ; //	sAX	= 0x003F;			
0048E:      	AX	= 0x3F
            ; //	asm I1 = SUBFLTG+0;			
0048F:      	I1 = SUBFLTG+0//
            ; //	*(__int16*)sSI	= sAX			
00490:      	rm[I1]	= AX
            ; //_A5A7AA303_310:;				
            _A5A7AA303_310:
            ; //	asm	set io[INTENA].b0		
00491:      	set io[INTENA].b0
            ; //_A5A7AA303_311:;				
            _A5A7AA303_311:
            ; //	asm	eni				
00492:      	eni
            ; //LFB78B58C_113:;					
            LFB78B58C_113:
            ; //_A5A7AA303_312:;				
            _A5A7AA303_312:
            ; //	return;					
00493:      	pop	AR
00494:      	rm[BP_SAVE]	= AR
00495:      	rets
            ; //_Sub3Play422CAD6D_end:;				
            _Sub3Play422CAD6D_end:
            ; //_A5A7AA303_313:;				
            _A5A7AA303_313:
            ; //}
            ; //
            ; //naked rjmp void Sbb_Ch0GetBts()			
            Sbb_Ch0GetBts:
            ; //{
            ; //_A5A7AA303_314:;				
            _A5A7AA303_314:
            ; //_A5A7AA303_315:;				
            _A5A7AA303_315:
            ; //	asm	push I1				
00496:      	push I1
            ; //_A5A7AA303_316:;				
            _A5A7AA303_316:
            ; //	asm	push P1				
00497:      	push P1
            ; //_A5A7AA303_317:;				
            _A5A7AA303_317:
            ; //	asm	push AX				
00498:      	push AX
            ; //_A5A7AA303_318:;				
            _A5A7AA303_318:
            ; //	asm	push BX				
00499:      	push BX
            ; //_A5A7AA303_319:;				
            _A5A7AA303_319:
            ; //	asm	push CX				
0049A:      	push CX
            ; //_A5A7AA303_320:;				
            _A5A7AA303_320:
            ; //	asm	push DX				
0049B:      	push DX
            ; //_A5A7AA303_321:;				
            _A5A7AA303_321:
            ; //	asm	AR = P1.hh			
0049C:      	AR = P1.hh
            ; //_A5A7AA303_322:;				
            _A5A7AA303_322:
            ; //	asm	push AR				
0049D:      	push AR
            ; //	
            ; //_A5A7AA303_323:;				
            _A5A7AA303_323:
            ; //_A5A7AA303_324:;				
            _A5A7AA303_324:
            ; //_A5A7AA303_325:;				
            _A5A7AA303_325:
            ; //	asm I1 = bts_ch0_get_ix+0;		
0049E:      	I1 = bts_ch0_get_ix+0//
            ; //	sAX	= *(__int16*)sSI++;		
0049F:      	AX	= rm[I1++]
            ; //	sDX	= *(__int16*)sSI--;		
004A0:      	DX	= rm[I1--]
            ; //	sSI	= (int)&bts_ch0_get_ix[0];	
004A1:      	I1	= bts_ch0_get_ix
            ; //	PUSH(sAX);				
004A2:      	push	AX
            ; //	PUSH(sDX);				
004A3:      	push	DX
            ; //	sfx_GETSILONG_BXCX();			
004A4:      	CX	= rm[I1++]
004A5:      	BX	= rm[I1--]
            ; //	sAX = 0x0001;				
004A6:      	AX	= 0x01
            ; //	sDX = 0x0000;				
004A7:      	DX	= 0x00
            ; //	sfx_ADDLONG_BXCX_DXAX();		
004A8:      	AR	= AX
004A9:      	CX	= CX + AR
004AA:      	AR	= DX
004AB:      	BX	= BX + AR + C
            ; //	sfx_STORSILONG_BXCX();			
004AC:      	rm[I1++]	= CX
004AD:      	rm[I1--]	= BX
            ; //	sDX	= POP();			
004AE:      	pop	DX
            ; //	sAX	= POP();			
004AF:      	pop	AX
            ; //	_lptr_read(STACK[sSP + 0], STACK[sSP + 1]);
004B0:      	pch	= _lptr_read
004B1:      	lcall	_lptr_read
            ; //	vXCHG(STACK[sSP + 0]);			
004B2:      	AR	= AX
004B3:      	AX	= xchg AR
            ; //_A5A7AA303_326:;				
            _A5A7AA303_326:
            ; //	asm	pop AR				
004B4:      	pop AR
            ; //_A5A7AA303_327:;				
            _A5A7AA303_327:
            ; //	asm	P1.hh = AR			
004B5:      	P1.hh = AR
            ; //_A5A7AA303_328:;				
            _A5A7AA303_328:
            ; //	asm	AR = AX				
004B6:      	AR = AX
            ; //	
            ; //_A5A7AA303_329:;				
            _A5A7AA303_329:
            ; //	asm	pop DX				
004B7:      	pop DX
            ; //_A5A7AA303_330:;				
            _A5A7AA303_330:
            ; //	asm	pop CX				
004B8:      	pop CX
            ; //_A5A7AA303_331:;				
            _A5A7AA303_331:
            ; //	asm	pop BX				
004B9:      	pop BX
            ; //_A5A7AA303_332:;				
            _A5A7AA303_332:
            ; //	asm	pop AX				
004BA:      	pop AX
            ; //_A5A7AA303_333:;				
            _A5A7AA303_333:
            ; //	asm	pop P1				
004BB:      	pop P1
            ; //_A5A7AA303_334:;				
            _A5A7AA303_334:
            ; //	asm	pop I1				
004BC:      	pop I1
            ; //LFB78B58C_114:;					
            LFB78B58C_114:
            ; //_A5A7AA303_335:;				
            _A5A7AA303_335:
            ; //	return;					
004BD:      	rets
            ; //Sbb_Ch0GetBts_end:;				
            Sbb_Ch0GetBts_end:
            ; //_A5A7AA303_336:;				
            _A5A7AA303_336:
            ; //}
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_sub3play_8ED4FA41_s(void)	
            ginit_code_sub3play_8ED4FA41_s:
            ; //{
            ; //	return;					
004BE:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\SUB3PLAY_8ED4FA41.S.CODE.ASM> End=========================
            
            ;=========================Include <ASMFUNC\INTERRUPT.ASM> Start=========================
            
            ; ~.~------------------------------------------
            ; void PWM_ENTRY(void) interrupt 0
            ; ---------------------------------------------
            PWM_ENTRY:
            ; {
004BF:      	clr 		io[INTREQ].b0	; Clear Int0 Request!!
            
004C0:      	push		AX
004C1:      	push		BX
004C2:      	push		CX
004C3:      	push		DX
004C4:      	push		I0
004C5:      	push		I1
004C6:      	push		P1
004C7:      	AR=		P1.hh
004C8:      	push		AR
004C9:      	push		MX
004CA:      	push		MR0
004CB:      	push		MR1
004CC:      	push		MR2
004CD:      	push		CBL
            #ifdef _MSPEECHDSP_
            
            #else
004CE:      	AR=		MACOP
004CF:      	push		AR
004D0:      	MACOP=		0
            #endif
            
004D1:      	CBL=		0
            
004D2:      	I1=		dtxRender
004D4:      	io[DACL]=	rm[I1++2]
004D5:      	io[DACL]=	rm[I1++2]
004D6:      	io[DACL]=	rm[I1++2]
004D7:      	io[DACL]=	rm[I1++2]
            
            	; dtxDoChannel();
004D8:      		PCH=		dtxDoChannel
004D9:      		lcall		dtxDoChannel
            
            	; if(dtxnote)
004DA:      		I1=		dtxnote
004DC:      		AX=		rm[I1++]
004DD:      		AR=		rm[I1]
004DE:      		AR=		AR | AX
004DF:      		if ZR jmp	@pwm_label_1615
            	; {
            
            		; dtxDoEvent();
004E0:      			PCH=		dtxDoEvent
004E1:      			lcall		dtxDoEvent
            	; }
            	@pwm_label_1615:
            
            	
            	; -=-=-=-=-=-=-=-=-=-
            	; dtx + subband3 sound mix
            
004E2:      	I1=		SUBFLTI
004E3:      	FLTI=		rm[I1++]
004E4:      	FLTI=		rm[I1++]
004E5:      	FLTI=		rm[I1++]
004E6:      	FLTI=		rm[I1++]
004E7:      	FLTA=		rm[I1++]
004E8:      	FLTP=		rm[I1++]
004E9:      	FLTG=		rm[I1]
004EA:      	AR=		FLTO
            
004EB:      	MX=		1
004EC:      	CBL=		9
            
004ED:      	I1=		dtxRender
004EF:      	I0=		rm[PCMYOU_PTR]
004F0:      	CX=		3
            @pwm_loop_1340:
004F1:      	if FA jmp	@pwm_label_1340
            
004F2:      	AR=		rm[I0++]
004F3:      	FLTI=		AR
            @pwm_label_1340:
004F4:      	AR=		FLTO
            
            #ifdef _MSPEECHDSP_	
            	MULSS
            #else
004F5:      	MR=		MX * AR
            #endif
            	; ~~ can not use SATV because subband3 use it already
004F6:      	AX=		rm[I1++]
004F7:      	AR=		MR0
004F8:      	AX=		AX + AR
004F9:      	AR=		rm[I1--]
004FA:      	AR=		AR + MR1 + C
004FB:      	if AN jmp	@pwm_label_1021
004FC:      	SF=		AR - 0
004FD:      	if NE jmp	@pwm_label_1149
004FE:      	test		AX.b15
004FF:      	if ZR jmp	@pwm_label_1022
            @pwm_label_1149:
00500:      	AX=		0x7FFF
00502:      	jmp		@pwm_label_1022
            @pwm_label_1021:
00503:      	SF=		AR - 0xFF
00504:      	if NE jmp	@pwm_label_1149_1
00505:      	test		AX.b15
00506:      	if NZ jmp	@pwm_label_1022
            @pwm_label_1149_1:
00507:      	AX=		0x8001
            @pwm_label_1022:
00509:      	rm[I1++2]=	AX
0050A:      	loop		@pwm_loop_1340
            
0050B:      	I1=		SUBFLTI
0050C:      	rm[I1++]=	FLTI
0050D:      	rm[I1++]=	FLTI
0050E:      	rm[I1++]=	FLTI
0050F:      	rm[I1++]=	FLTI
00510:      	rm[I1++]=	FLTA
            
00511:      	rm[PCMYOU_PTR]=	I0
            
            	; -=-=-=-=-=-=-=-=-=-
            
            
            #ifdef _MSPEECHDSP_
            
            #else
00512:      	pop		AR
00513:      	MACOP=		AR
            #endif
00514:      	pop		CBL
00515:      	pop		MR2
00516:      	pop		MR1
00517:      	pop		MR0
00518:      	pop		MX
00519:      	pop		AR
0051A:      	P1.hh=		AR
0051B:      	pop		P1
0051C:      	pop		I1
0051D:      	pop		I0
0051E:      	pop		DX
0051F:      	pop		CX
00520:      	pop		BX
00521:      	pop		AX
00522:      	reti
            
            PWM_ENTRY_END:	
            ; }
            
            
            
            
            ;=========================Include <ASMFUNC\INTERRUPT.ASM> End=========================
            
            ;=========================Include <ASMFUNC\SUPPORT.ASM> Start=========================
            
            
            ; ~~ assembly function in C form...
            
            ; ---------------------------------------------
            
            ; --------------------------------------------------------------
            
            
            ChangePWMIntToDynCache:
            
            
            #ifdef PRAM_BANK
            	P1=		#PWM_ENTRY
            	AX=		#PWM_ENTRY_END
            	PCH=		sfx_DynFindPRG
            	lcall		sfx_DynFindPRG
            	if NZ jmp	@chpwmi_label_1757
            
            	rets
            @chpwmi_label_1757:
            	PCH=		sfx_DynBooking
            	lcall		sfx_DynBooking
            	if ZR jmp	@chpwmi_label_1758
            
            	rets
            @chpwmi_label_1758:
            	PCH=		sfx_DynCache
            	lcall		sfx_DynCache
            
            
            	; P0 is point to entry
            
            	set             io[STATUS].b13
            	I1=		PCMY
            	
            	CX=		DSP_VECT_SUPPORT - 2
            @cpitm_loop_1836:
            	AR=		io[IntVect]                      ;
            	rm[I1++]=	AR                           ;	; Int5~0
            	AR=		PCB
            	rm[I1++]=	AR                           ;	; Int5~0 PCB
            	loop            @cpitm_loop_1836
            
            
            	AR=		P0
            	AR++
            	rm[I1++]=	AR
            	AR=		P0.hh
            	rm[I1++]=	AR
            
            	clr		io[STATUS].b13
            
            	
            	; ~~ write new vector table
            
            	set             io[STATUS].b13
            	I1=		PCMY
            
            	CX=		DSP_VECT_SUPPORT - 1
            @cpitm_loop_1837:
            	AX=		rm[I1++]
            	AR=		rm[I1++]
            	PCB=		AR
            	AR=		AX
            	io[IntVect]=	AR
            	PCB=		0
            	loop		@cpitm_loop_1837
            
            	; Dis-int-vector table access
            	clr		io[STATUS].b13
            	P0.hh=		0
            #endif
            
00523:      	rets
            
            
            ;=========================Include <ASMFUNC\SUPPORT.ASM> End=========================
            
            ;=========================Include <DEPS\DATA_0EBCA7F9.S.CODE.ASM> Start=========================
            ; data.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //naked void melody();
            ; //naked void subdat0();
            ; //naked void subdat1();
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_data_0EBCA7F9_s(void)	
            ginit_code_data_0EBCA7F9_s:
            ; //{
            ; //	return;					
00524:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //naked void melody()				
            melody:
            ; //{
            ; //	asm	DW "dtx\gamedtx_32K_4CH_mp.dtx"	
031B5:      DW "dtx\gamedtx_32K_4CH_mp.dtx"
            ; //}
            ; //
            ; //naked void subdat0()				
            subdat0:
            ; //{
            ; //	asm	DW "subband3\Airport_16K@39K5bps.t3z"
0BDBA:      DW "subband3\Airport_16K@39K5bps.t3z"
            ; //}
            ; //
            ; //naked void subdat1()				
            subdat1:
            ; //{
            ; //	asm	DW "subband3\06_Story_12K1@27K8bps.t3z"
15684:      DW "subband3\06_Story_12K1@27K8bps.t3z"
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\DATA_0EBCA7F9.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\IO.ASM> Start=========================
            
            
            ; ~~ IO for DSP
            
            
            ; ~~ --------------------------
            ; void ClrWatchDog(void)
            ;~ ClrWatchDog:
            	;~ io[0x1D]=	AR
            	;~ rets
            
            
            ; ~~ --------------------------
            ; void dsi(void)
            ;~ dsi:
            	;~ clr		io[STATUS].b7
            	;~ nop
            	;~ rets
            
            
            ; ~~ --------------------------
            ; void eni(void)
            ;~ eni:
            	;~ set		io[STATUS].b7
            	;~ rets
            
            
            ; ~~ --------------------------
            ; int get_SATV(long value)
            get_SATV:
00525:      	AR=		BP
00526:      	AR=		AR + 1		; ~~ value
00527:      	I1=		AR
00528:      	AR=		SATV
00529:      	AR=		rm[I1++]
0052A:      	SATV=		AR
0052B:      	AR=		rm[I1++]
0052C:      	SATV=		AR
0052D:      	AR=		SATV
0052E:      	AX=		AR
0052F:      	rets
            
            #ifdef _MSPEECHDSP_
            
            set_ADPHD:
            get_ADPHD:
            set_ADPDAT:
            get_ADPDAT:
            	AX=		0
            	rets
            
            #else
            
            
            ; ~~ --------------------------
            ; void set_ADPHD(int value)
            set_ADPHD:
00530:      	AR=		BP
00531:      	AR=		AR + 1		; ~~ value
00532:      	I1=		AR
00533:      	ADPHD=		rm[I1]
00534:      	rets
            
            
            ; ~~ --------------------------
            ; int get_ADPHD(void)
            get_ADPHD:
00535:      	AR=		ADPHD
00536:      	AX=		AR
00537:      	rets
            
            
            ; ~~ --------------------------
            ; void set_ADPDAT(int value)
            set_ADPDAT:
00538:      	AR=		BP
00539:      	AR=		AR + 1		; ~~ value
0053A:      	I1=		AR
0053B:      	ADPDAT=		rm[I1]
0053C:      	rets
            
            
            ; ~~ --------------------------
            ; int get_ADPDAT(void)
            get_ADPDAT:
0053D:      	AR=		ADPDAT
0053E:      	AX=		AR
0053F:      	rets
            
            #endif
            
            
            
            ; ~~ --------------------------
            ; int get_ADPPCM(void)
            get_FLTI:
            get_ADPPCM:
00540:      	AR=		ADPPCM
00541:      	AX=		AR
00542:      	rets
            
            
            ; ~~ --------------------------
            ; int get_CBL(void)
            get_CBL:
00543:      	AR=		CBL
00544:      	AX=		AR
00545:      	rets
            
            
            ; ~~ --------------------------
            ; int get_FLTO(void)
            get_FLTO:
00546:      	AR=		FLTO
00547:      	AX=		AR
00548:      	rets
            
            
            ; ~~ --------------------------
            ; int get_FLTA(void)
            get_FLTA:
00549:      	AR=		FLTA
0054A:      	AX=		AR
0054B:      	rets
            
            
            ; ~~ --------------------------
            ; int get_FLTP(void)
            get_FLTP:
0054C:      	AR=		FLTP
0054D:      	AX=		AR
0054E:      	rets
            
            ; ///////////////////////////////////////////////////////////////////////////
            ; ///////////////////////////////////////////////////////////////////////////
            
            ; ~~ --------------------------
            ; void set_UART(void)
            set_UART:
0054F:      	set		io[STATUS].b5
00550:      	rets
            
            ; ~~ --------------------------
            ; void clr_UART(void)
            clr_UART:
00551:      	clr		io[STATUS].b5
00552:      	rets
            
            ; ~~ --------------------------
            ; void set_SPIM(void)
            set_SPIM:
00553:      	set		io[STATUS].b8
00554:      	rets
            
            ; ~~ --------------------------
            ; void clr_SPIM(void)
            clr_SPIM:
00555:      	clr		io[STATUS].b8
00556:      	rets
            
            ; ~~ --------------------------
            ; void set_SPIS(void)
            set_SPIS:
00557:      	set		io[STATUS].b9
00558:      	rets
            
            ; ~~ --------------------------
            ; void clr_SPIS(void)
            clr_SPIS:
00559:      	clr		io[STATUS].b9
0055A:      	rets
            
            ; ~~ --------------------------
            ; void set_IntPrWR(void)
            set_IntPrWR:
0055B:      	set		io[STATUS].b11
0055C:      	rets
            
            ; ~~ --------------------------
            ; void clr_IntPrWR(void)
            clr_IntPrWR:
0055D:      	clr		io[STATUS].b11
0055E:      	rets
            
            ; ~~ --------------------------
            ; void set_IntPrWR(void)
            set_SD:
0055F:      	set		io[STATUS].b12
00560:      	rets
            
            ; ~~ --------------------------
            ; void clr_IntPrWR(void)
            clr_SD:
00561:      	clr		io[STATUS].b12
00562:      	rets
            
            ; ~~ --------------------------
            ; void set_IntVWR(void)
            set_IntVWR:
00563:      	set		io[STATUS].b13
00564:      	rets
            
            ; ~~ --------------------------
            ; void clr_IntVWR(void)
            clr_IntVWR:
00565:      	clr		io[STATUS].b13
00566:      	rets
            
            ; ~~ --------------------------
            ; void set_INTENA(int value)
            set_INTENA:
00567:      	AR=		BP
00568:      	AR=		AR + 1		; ~~ value
00569:      	I1=		AR
0056A:      	AR=		rm[I1]
0056B:      	io[INTENA]=	AR
0056C:      	rets
            
            ; ~~ --------------------------
            ; int get_INTENA(int value)
            get_INTENA:
0056D:      	AR=		io[INTENA]
0056E:      	AX=		AR
0056F:      	rets
            
            ; ~~ --------------------------
            ; void set_INTREQ(int value)
            set_INTREQ:
00570:      	AR=		BP
00571:      	AR=		AR + 1		; ~~ value
00572:      	I1=		AR
00573:      	AR=		rm[I1]
00574:      	io[INTREQ]	=AR
00575:      	rets
            
            ; ~~ --------------------------
            ; int get_INTREQ(int value)
            get_INTREQ:
00576:      	AR=		io[INTREQ]
00577:      	AX=		AR
00578:      	rets
            
            ; ~~ --------------------------
            ; void set_IntVect(int value)
            set_IntVect:
00579:      	AR=		BP
0057A:      	AR=		AR + 1		; ~~ value
0057B:      	I1=		AR
0057C:      	AR=		rm[I1]
0057D:      	io[IntVect]	=AR
0057E:      	rets
            
            ; ~~ --------------------------
            ; int get_IntVect(int value)
            get_IntVect:
0057F:      	AR=		io[IntVect]
00580:      	AX=		AR
00581:      	rets
            
            
            ; ~~ --------------------------
            ; int get_IOC_PA(int value)
            get_IOC_PA:
00582:      	AR=		io[IOC_PA]
00583:      	AX=		AR
00584:      	rets
            
            
            ; ~~ --------------------------
            ; int get_IOC_PB(int value)
            get_IOC_PB:
00585:      	AR=		io[IOC_PB]
00586:      	AX=		AR
00587:      	rets
            
            
            ; ~~ --------------------------
            ; int get_IOC_PC(int value)
            get_IOC_PC:
00588:      	AR=		io[IOC_PC]
00589:      	AX=		AR
0058A:      	rets
            
            ; ~~ --------------------------
            ; int get_PortA(int value)
            get_PortA:
0058B:      	AR=		io[PortA]
0058C:      	AX=		AR
0058D:      	rets
            
            ; ~~ --------------------------
            ; int get_PortB(int value)
            get_PortB:
0058E:      	AR=		io[PortB]
0058F:      	AX=		AR
00590:      	rets
            
            
            ; ~~ --------------------------
            ; int get_PortC(int value)
            get_PortC:
00591:      	AR=		io[PortC]
00592:      	AX=		AR
00593:      	rets
            
            ; ~~ --------------------------
            ; void set_SPI_CTL(int value)
            set_SPI_CTL:
00594:      	AR=		BP
00595:      	AR=		AR + 1		; ~~ value
00596:      	I1=		AR
00597:      	AR=		rm[I1]
00598:      	io[SPI_CTL]=	AR
00599:      	rets
            
            ; ~~ --------------------------
            ; int get_SPI_CTL(int value)
            get_SPI_CTL:
0059A:      	AR=		io[SPI_CTL]
0059B:      	AX=		AR
0059C:      	rets
            
            ; ~~ --------------------------
            ; void set_SPI_DAT(int value)
            set_SPI_DAT:
0059D:      	AR=		BP
0059E:      	AR=		AR + 1		; ~~ value
0059F:      	I1=		AR
005A0:      	AR=		rm[I1]
005A1:      	io[SPI_DAT]=	AR
005A2:      	rets
            
            ; ~~ --------------------------
            ; int get_SPI_DAT(int value)
            get_SPI_DAT:
005A3:      	AR=		io[SPI_DAT]
005A4:      	AX=		AR
005A5:      	rets
            
            
            ; ~~ --------------------------
            ; void set_MISC(int value)
            set_MISC:
005A6:      	AR=		BP
005A7:      	AR=		AR + 1		; ~~ value
005A8:      	I1=		AR
005A9:      	AR=		rm[I1]
            	;~ io[0x1C]	=AR
005AA:      	rets
            
            ; ~~ --------------------------
            ; int get_MISC(int value)
            get_MISC:
005AB:      	AR=		io[MISC]
005AC:      	AX=		AR
005AD:      	rets
            
            ; ~~ --------------------------
            ; int get_Real_T(int value)
            get_Real_T:
            	;~ AR=		io[0x1D]
005AE:      	AX=		AR
005AF:      	rets
            
            
            ; ~~ --------------------------
            ; int get_MACOP(void)
            get_MACOP:
005B0:      	AR=		MACOP
005B1:      	AX=		AR
005B2:      	rets
            
            
            ; ~~ --------------------------
            ; void set_INTMASK(int value)
            ; set_INTMASK:
            	; AR=			BP
            	; AR=			AR + 1		; ~~ value
            	; I1=			AR
            	; AR=			rm[I1]
            	; io[INTMASK]=AR
            	; rets
            
            ; ~~ --------------------------
            ; int get_INTMASK(int value)
            ; get_INTMASK:
            	; AR=			io[INTMASK]
            	; AX=			AR
            	; rets
            
            ; ~~ --------------------------
            ; int vXCHG(int value)
            vXCHG:
005B3:      	AR=		BP
005B4:      	AR=		AR + 1
005B5:      	I1=		AR
005B6:      	AR=		rm[I1]
005B7:      	xchg		AR
005B8:      	AX=		AR
005B9:      	rets
            
            ; ~~ --------------------------
            ; void cpuHalt(void)
            cpuHalt:
005BA:      	halt
            
            
            #ifdef _MFDSP_
            
            ; ~~ --------------------------
            ; void setSystemSpeed(int value)
            set_SystemSpeed:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SPEED]=	AR
            	rets
            
            
            ; ~~ --------------------------
            ; void set_SD_CTL(int value)
            set_SD_CTL:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SD_CTL]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SD_CTL(int value)
            get_SD_CTL:
            	AR=		io[SD_CTL]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SD_DAT(int value)
            set_SD_DAT:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SD_DAT]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SD_DAT(void)
            get_SD_DAT:
            	AR=		io[SD_DAT]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SD_RSP(int value)
            set_SD_RSP:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SD_RSP]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SD_RSP(int value)
            get_SD_RSP:
            	AR=		io[SD_RSP]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_UART_CTL(int value)
            set_UART_CTL:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[UART_CTL]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_UART_CTL(int value)
            get_UART_CTL:
            	AR=		io[UART_CTL]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_UART_DAT(int value)
            set_UART_DAT:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[UART_DAT]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_UART_DAT(int value)
            get_UART_DAT:
            	AR=		io[UART_DAT]
            	AX=		AR
            	rets
            
            
            ; By Tsao	20161103
            
            ; ~~ --------------------------
            ; void set_ADH_CFG0(int value)
            set_ADH_CFG0:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[ADH_CFG0]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_ADH_CFG0(void)
            get_ADH_CFG0:
            	AR=		io[ADH_CFG0]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_ADH_CFG1(int value)
            set_ADH_CFG1:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[ADH_CFG1]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_ADH_CFG1(void)
            get_ADH_CFG1:
            	AR=		io[ADH_CFG1]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; int get_ADH_DO(void)
            get_ADH_DO:
            	AR=		io[ADH_DO]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SPIS_CTL(int value)
            set_SPIS_CTL:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SPIS_CTL]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SPIS_CTL(int value)
            get_SPIS_CTL:
            	AR=		io[SPIS_CTL]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_SPIS_DAT(int value)
            set_SPIS_DAT:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SPIS_DAT]=	AR
            	rets
            
            ; ~~ --------------------------
            ; int get_SPIS_DAT(int value)
            get_SPIS_DAT:
            	AR=		io[SPIS_DAT]
            	AX=		AR
            	rets
            
            ; ~~ --------------------------
            ; void set_GreenMode(int value)
            set_GreenMode:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[GREEN]=	AR
            	rets
            
            ; ~~ --------------------------
            ; void cpuStall(int value)
            cpuStall:
            	AR=		BP
            	AR=		AR + 1		; ~~ value
            	I1=		AR
            	AR=		rm[I1]
            	io[SLEEP]=	AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; set_SPI_DMA_CTL:
            	; AR=		BP
            	; AR=		AR + 1		// ~~ value
            	; I1=		AR
            	; AR=		rm[I1]
            	; io[SPI_DMA_CTL]=	AR
            	; rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            get_SPI_DMA_CTL:
            	AR=		io[SPI_DMA_CTL]
            	AX=		AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; set_SPI_DMA_RADR:
            	; AR=		BP
            	; AR=		AR + 1		// ~~ value
            	; I1=		AR
            	; AR=		rm[I1]
            	; io[SPI_DMA_RADR]=	AR
            	; rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            get_SPI_DMA_RADR:
            	AR=		io[SPI_DMA_RADR]
            	AX=		AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            ; set_SPI_DMA_DMANUM:
            	; AR=		BP
            	; AR=		AR + 1		// ~~ value
            	; I1=		AR
            	; AR=		rm[I1]
            	; io[0x55]=	AR
            	; rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            get_SPI_DMA_DMANUM:
            	AR=		io[SPI_DMA_DMANUM]
            	AX=		AR
            	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            
            #endif
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            read_I0:
005BB:      	AX=		rm[I0]
005BC:      	rets
            
            read_I0P:
005BD:      	AX=		rm[I0++]
005BE:      	rets
            
            read_I0P2:
005BF:      	AX=		rm[I0++2]
005C0:      	rets
            
            read_I0M:
005C1:      	AX=		rm[I0--]
005C2:      	rets
            
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            get_I0:
005C3:      	AR=		I0
005C4:      	AX=		AR
005C5:      	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            read_P0:
005C6:      	AX=		pm[P0]
005C7:      	rets
            
            read_P0P:
005C8:      	AX=		pm[P0++]
005C9:      	rets
            
            read_P0M:
005CA:      	AX=		pm[P0--]
005CB:      	rets
            
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            get_P0:
005CC:      	AR=		P0
005CD:      	AX=		AR
005CE:      	rets
            
            ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
            
            FA:
005CF:      	AX=		1
005D0:      	if FA jmp	@fa_label_1504
005D1:      	AX=		0
            @fa_label_1504:
005D2:      	rets
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\IO.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\_LPTR_READ.ASM> Start=========================
            _lptr_read:
005D3:      	AR=		DX
005D4:      	test		AR.b11
005D5:      	if ZR jmp	@_lptr_read_label_1510
            
005D6:      	P1.hh=		AR
005D7:      	AR=		AX
005D8:      	P1=		AR
005D9:      	AX=		pm[P1]
005DA:      	P1.hh=		0
005DB:      	rets
            
            @_lptr_read_label_1510:
            
005DC:      	AR=		AX
005DD:      	I1=		AR
005DE:      	AX=		rm[I1]
005DF:      	rets
            
            
            _lptr_read32:
005E0:      	AR=		DX
005E1:      	test		AR.b11
005E2:      	if ZR jmp	@_lptr_read_label_1510_32
            
005E3:      	P1.hh=		AR
005E4:      	AR=		AX
005E5:      	P1=		AR
005E6:      	AX=		pm[P1++]
005E7:      	DX=		pm[P1]
005E8:      	P1.hh=		0
005E9:      	rets
            
            @_lptr_read_label_1510_32:
            
005EA:      	AR=		AX
005EB:      	I1=		AR
005EC:      	AX=		rm[I1++]
005ED:      	DX=		rm[I1]
005EE:      	rets
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\_LPTR_READ.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\TICK.ASM> Start=========================
            
            
            _ClearTickCount5DDE4003:
            #ifdef _MFDSP_
            	set		io[MISC].b8
            #else
005EF:      	set		io[MISC].b7
            #endif
005F0:      	set		io[MISC].b15
            	
005F1:      	io[REAL_T]=	AR
005F2:      	AR=		io[REAL_T]
005F3:      	AR=		io[REAL_T]
005F4:      	io[REAL_T]=	AR
005F5:      	rets
            
            ; -----------------------------------------------
            
            _GetTickCount18DC070C:
005F6:      	AX=		0xFFF0
            @gettickcount_loop_1000:
005F8:      	io[ClrWDT]=	AR
005F9:      	AR=		io[REAL_T]
005FA:      	AR=		AR & AX
005FB:      	SF=		AR - AX
005FC:      	if ZR jmp	@gettickcount_loop_1000
005FD:      	AX=		AR
005FE:      	AR=		io[REAL_T]
005FF:      	DX=		AR
00600:      	rets
            
            	
            ; -----------------------------------------------
            ; void delay(int ms)
            ;
            ; in:
            ;     BP + 1 - int ms
            ;
            ; -----------------------------------------------
            _delay6F9F34ED:
            ; {
00601:      	AR=		BP
00602:      	AR=		AR + 1		; ~~ port
00603:      	I1=		AR
            
            	; unsigned long tick;
            	; unsigned long msr;
            
            	; ~~ 1ms = 32768 ticks
            
            	; msr = (unsigned long)ms << 15;
00604:      		R0=		0
00605:      		R1=		rm[I1]
00606:      		clr		C
00607:      		src		R1, 1
00608:      		src		R0, 1
            	
            	; tick = GetTickCount();
00609:      		call		_GetTickCount18DC070C
0060A:      		AR=		AX
0060B:      		CX=		AR
0060C:      		AR=		DX
0060D:      		BX=		AR
            	
            	; while((GetTickCount() - tick) < msr);
            	@delay_loop_1024:
0060E:      		call		_GetTickCount18DC070C
0060F:      		AR=		CX
00610:      		AX=		AX - AR
00611:      		AR=		BX
00612:      		DX=		DX - AR + C - 1
00613:      		AR=		R0
00614:      		AX=		AX - AR
00615:      		AR=		R1
00616:      		DX=		DX - AR + C - 1
00617:      		AR=		0
00618:      		AR=		AR - 0 + C - 1
00619:      		if AN jmp	@delay_loop_1024
            
0061A:      	rets
            ; }
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBIO\TICK.ASM> End=========================
            
            ;=========================Include <DEPS\DTX_3359D009.S.CODE.ASM> Start=========================
            ; C:\TRITAN\FDSP-IDE\tools\CC\lib\libdtx\dtx.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_dtx_3359D009_s(void)	
            ginit_code_dtx_3359D009_s:
            ; //{
            ; //	return;					
0061B:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //	nop
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\DTX_3359D009.S.CODE.ASM> End=========================
            
            ;=========================Include <DEPS\SUB3_CSHELL_257767F9.S.CODE.ASM> Start=========================
            ; .\lib\libsubb3\sub3_cshell.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code_sub3_cshell_257767F9_s(void)
            ginit_code_sub3_cshell_257767F9_s:
            ; //{
            ; //	return;					
0061C:      	rets
            ; //}
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .data
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //	nop
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\SUB3_CSHELL_257767F9.S.CODE.ASM> End=========================
            
            ;
            #LINKOBJ "C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\DTXDOCHANNEL.OBJ"
            ;
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\DTXPLAYER.ASM> Start=========================
            
            
            
            
            
            
            
            #define MAX_DTX_CHANNEL		4
            
            ; -----------------------------------------------------
            
            
            #define DTX_SET_CH1_INS		0
            #define DTX_SET_CH2_INS		1
            #define DTX_SET_CH4_INS		2
            #define DTX_RESERVE3		3
            #define DTX_CHANGE_CH1_VOL	4
            #define DTX_CHANGE_CH2_VOL	5
            #define DTX_CHANGE_CH3_VOL	6
            #define DTX_CHANGE_CH4_VOL	7
            #define DTX_USER_CMD		8
            #define DTX_REST		9
            #define DTX_SET_NOTEOFF		10
            #define DTX_END_SONG		11
            
            
            ; -----------------------------------------------------
            
            
            #define DTX_TONE_ENVADR		0
            #define DTX_TONE_ENVSTA		2
            #define DTX_TONE_TONE		4
            #define DTX_TONE_TONECNT	5
            #define DTX_TONE_FLTG		6
            #define DTX_TONE_MOD		7
            
            #define DTX_TONE_SIZEOF		8
            
            #define DTX_TONE_CH		(DTX_TONE_SIZEOF*3)
            
            ; -----------------------------------------------------
            
            #define DTX_PERC_INSADR		0
            #define DTX_PERC_INSADR_H	1
            #define DTX_PERC_FLTG		2
            #define DTX_PERC_FLTI		3
            #define DTX_PERC_FLTA		7
            #define DTX_PERC_FLTP		8
            #define DTX_PERC_ADPCM_HD	9
            #define DTX_PERC_ADPCM_S0	10
            #define DTX_PERC_ADPCM_S1	11
            #define DTX_PERC_ADPCM_CNT	12
            #define DTX_PERC_ADPCM_BUF	13
            
            #define DTX_PERC_SIZEOF		14
            
            ; -----------------------------------------------------
            
            
            VarRM[0:127] = {
            
            	dtxfltg,
            
            
            }
            
            
            
            VarRM[512:4095] = {
            
            	dtxbaseadr[2]
            	dtxinsbase[2]
            	dtxpercbase[2]
            	dtxsonghdr[2]
            	dtxnote[2]
            	dtxsongcnt
            	dtxtonech[DTX_TONE_CH]			; 3 channel tone
            	dtxperc[DTX_PERC_SIZEOF]
            
            	dtxPlayInfo
            	dtxPlayChannel
            	dtxReleaseCh
            	dtxBaseTimer
            	dtxEventTimer
            
            	dtxRender[8]
            }
            
            
            #define dtxbaseadr_l		dtxbaseadr
            #define dtxbaseadr_h		dtxbaseadr+1
            #define dtxinsbase_l		dtxinsbase
            #define dtxinsbase_h		dtxinsbase+1
            #define dtxpercbase_l		dtxpercbase
            #define dtxpercbase_h		dtxpercbase+1
            #define dtxsonghdr_l		dtxsonghdr
            #define dtxsonghdr_h		dtxsonghdr+1
            #define dtxnote_h		dtxnote+1
            
            
            
            ShareVar = {
            
            
            }
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            DTX_TONE_FREQ:
0074B:      	DW 0x7A01, 0x7302, 0x6D00, 0x6603, 0x6100, 0x5B02, 0x5602, 0x5102,
00753:      	DW 0x4D00, 0x4803, 0x4403, 0x4003, 0x3D01, 0x3903, 0x3602, 0x3302,
0075B:      	DW 0x3002, 0x2D03, 0x2B01, 0x2803, 0x2602, 0x2401, 0x2201, 0x2002,
00763:      	DW 0x1E02, 0x1C03, 0x1B01, 0x1903, 0x1801, 0x1700, 0x1502, 0x1402,
0076B:      	DW 0x1301, 0x1201, 0x1101, 0x1001, 0x0F01, 0x0E02, 0x0D02, 0x0C03,
00773:      	DW 0x0C01, 0x0B02, 0x0A03, 0x0A01, 0x0902, 0x0900, 0x0802, 0x0800,
0077B:      	DW 0x0702, 0x0701, 0x0603, 0x0602, 0x0600, 0x0503, 0x0502, 0x0500,
00783:      	DW 0x0403, 0x0402, 0x0401, 0x0400,
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            dtxInitialize:
            ; {
            	; dtxbaseadr = 0;
00787:      		AR=		0
00788:      		I1=		dtxbaseadr
0078A:      		rm[I1++]=	AR
0078B:      		rm[I1]=		AR
            
            	; dtxinsbase = 0;
0078C:      		I1=		dtxinsbase
0078E:      		rm[I1++]=	AR
0078F:      		rm[I1]=		AR
            
            	; dtxpercbase = 0;
00790:      		I1=		dtxpercbase
00792:      		rm[I1++]=	AR
00793:      		rm[I1]=		AR
            
            
00794:      	jmp		dtxInitParameters
            ; }
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            dtxInitParameters:
            ; {
            	; dtxPlayInfo = 0;
00795:      		I1=		dtxPlayInfo
00797:      		rm[I1]=		AR
            
            	; dtxPlayChannel = 0;
00798:      		I1=		dtxPlayChannel
0079A:      		rm[I1]=		AR
            
            	; dtxReleaseCh = 0;
0079B:      		I1=		dtxReleaseCh
0079D:      		rm[I1]=		AR
            
            	; dtxEventTimer = 0;
0079E:      		I1=		dtxEventTimer
007A0:      		rm[I1]=		AR
            
            	; memset(dtxtonech, 0, sizeof(dtxtonech));
007A1:      		CX=		DTX_TONE_CH - 1
007A2:      		I1=		dtxtonech
            	@dtxinit_loop_0932:
007A4:      		rm[I1++]=	AR
007A5:      		loop		@dtxinit_loop_0932
            
            	; memset(&dtxperc, 0, sizeof(dtxperc));
007A6:      		CX=		DTX_PERC_SIZEOF - 1
007A7:      		I1=		dtxperc
            	@dtxinit_loop_1804:
007A9:      		rm[I1++]=	AR
007AA:      		loop		@dtxinit_loop_1804
            
            	; dtxBaseTimer = 0x001F;
007AB:      		AR=		0x001F
007AC:      		I1=		dtxBaseTimer
007AE:      		rm[I1]=		AR
            
            	#ifdef DTX_PRAM_START
            		CX=		#DTXPLAYER_PRAM_LARGE_END - 1
            		AR=		#DTXPLAYER_PRAM_LARGE_START
            		CX=		CX - AR
            		P1=		#DTXPLAYER_PRAM_LARGE_START
            		P0=		DTX_PRAM_START
            		P0.hh=		DTX_PRAM_BANK
            	@dtxinit_loop_0913:
            		AR=		pm[P1++]
            		pm[P0++]=	AR
            		loop		@dtxinit_loop_0913
            		P0.hh=		0
            	#endif
            
007AF:      	rets
            ; }
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            dtxReadTune:
            ; {
            	; ~~ read tone modtune
            
            	; spiContReadStart(dtxbaseadr + 12, &dtx);
007B0:      		I1=		dtxbaseadr
007B2:      		AR=		rm[I1++]
007B3:      		AR=		AR + 12
007B4:      		AX=		AR
007B5:      		AR=		rm[I1]
007B6:      		AR=		AR + 0 + C
007B7:      		push		AR
007B8:      		push		AX
007B9:      		AR=		BP
007BA:      		AR=		AR + 2
007BB:      		I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,7704,7708,,,,,,,,,,,,,,,,  strat ======
007BC:      AR= rm[I1 -- ] 
007BD:      P1 = rm[I1] 
007BE:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
007BF:      		pop		AR
007C0:      		pop		AR
            
            	; dtxtonech[0].Mod = spiContReadByte();
007C1:      		I1=		dtxtonech + DTX_TONE_MOD
            ;;<<System message ======  Macro. mSfContReadByte,7717,7720,,,,,,,,,,,,,,,,  strat ======
007C3:      PCH = SfContReadByte 
007C4:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
007C5:      		rm[I1]=		AR
            
            	; dtxtonech[1].Mod = spiContReadByte();
007C6:      		I1=		dtxtonech + DTX_TONE_SIZEOF + DTX_TONE_MOD
            ;;<<System message ======  Macro. mSfContReadByte,7717,7720,,,,,,,,,,,,,,,,  strat ======
007C8:      PCH = SfContReadByte 
007C9:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
007CA:      		rm[I1]=		AR
            
            	; dtxtonech[2].Mod = spiContReadWord() >> 8;
007CB:      		I1=		dtxtonech + DTX_TONE_SIZEOF + DTX_TONE_SIZEOF + DTX_TONE_MOD
            ;;<<System message ======  Macro. mSfContReadWord,7711,7714,,,,,,,,,,,,,,,,  strat ======
007CD:      PCH = SfContReadWord 
007CE:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
007CF:      		AL=		0
007D0:      		xchg		AR
007D1:      		rm[I1]=		AR
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7723,7725,,,,,,,,,,,,,,,,  strat ======
007D2:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
007D3:      	rets
            ; }
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            ; bool dtxDoEvent(void)
            dtxDoEvent:
            ; {
            	; DSP16 AX;
            	; int i, mask, cmd;
            
            	; BaseTimer = (BaseTimer + 1) & 0x003F;
007D4:      		I1=		dtxBaseTimer
007D6:      		AR=		rm[I1]
007D7:      		AR++
007D8:      		AR=		AR & 0x3F
007D9:      		rm[I1]=		AR
            
            
            	; switch(BaseTimer)
007DA:      		SF=		AR - 0
007DB:      		if EQ jmp	@dtxdoe_case0_label_1906
007DC:      		SF=		AR - 0x20
007DD:      		if EQ jmp	@dtxdoe_case20_label_1906
007DE:      		jmp		@dtxdoe_case_default_1909
            	; {
            		; case 0:
            		@dtxdoe_case0_label_1906:
            		; {
            			; mask = 0x01;
007DF:      				I1=		dtxPlayChannel
007E1:      				AX=		rm[I1]
            
            			; for(i = 0; i < MAX_DTX_CHANNEL; i++)
007E2:      				CX=		MAX_DTX_CHANNEL - 1
007E3:      				BX=		dtxtonech
007E5:      				DX=		1
            			@dtxdoe_loop_0911:
            			; {
            				; if(PlayChannel & mask)
007E6:      					sra		AX, 1
007E7:      					if NC jmp	@dtxdoe_label_0913
            				; {
            					; if(i != 2)		// perc
007E8:      						test		DX.b2
007E9:      						if NZ jmp	@dtxdoe_label_0916
            					; {
            						; ch[i].tone.envadr++;
007EA:      							AR=		BX
007EB:      							I1=		AR	; DTX_TONE_ENVADR
007EC:      							AR=		rm[I1]
007ED:      							AR++
007EE:      							rm[I1++]=	AR
007EF:      							AR=		rm[I1]
007F0:      							AR=		AR + 0 + C
007F1:      							rm[I1]=		AR
            					; }
            					@dtxdoe_label_0916:
            				; }
            				@dtxdoe_label_0913:
            
            				; mask <<= 1;
007F2:      					test		DX.b2
007F3:      					if NZ jmp	@dtxdoe_label_1614
007F4:      						AR=		DTX_TONE_SIZEOF
007F5:      						BX=		BX + AR
            					@dtxdoe_label_1614:
007F6:      					slz		DX, 1
            
007F7:      				loop		@dtxdoe_loop_0911
            			; }
            		; }
            
            		; case 0x0020:
            		@dtxdoe_case20_label_1906:
            		; {
            			; dtxEventTimer--;
007F8:      				I1=		dtxEventTimer
007FA:      				AR=		rm[I1]
007FB:      				AR--
007FC:      				rm[I1]=		AR
            
            			; if(EventTimer != 0xFFFF)
007FD:      				SF=		AR - 0xFF
007FE:      				if EQ jmp	@dtxdoe_label_0919
            			; {
            				; return true;
            			; }
            
            			; break;
            		; }
            
            		; default:
            		@dtxdoe_case_default_1909:
            		; {
            			; return true;
007FF:      				set		Z
00800:      				rets
            		; }
            	; }
            	@dtxdoe_label_0919:
            
            
            	; spiContReadStart(dtxnote, &dtx);
00801:      		I1=		dtxnote_h
            ;;<<System message ======  Macro. mSfContReadStart,7704,7708,,,,,,,,,,,,,,,,  strat ======
00803:      AR= rm[I1 -- ] 
00804:      P1 = rm[I1] 
00805:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            	; ~~            byte 0                         byte 1
            	; ~~ +-----------------------------+-----------------------------+
            	; ~~ |      H             L        |      H              L       |
            	; ~~ +--------------+--------------+--------------+--------------+
            	; ~~ | Note Timer H | Note Timer M | Note Timer L |   PlayInfo   |
            	; ~~ +--------------+--------------+--------------+--------------+
            
            	; AX = spiContReadByte();
            ;;<<System message ======  Macro. mSfContReadByte,7717,7720,,,,,,,,,,,,,,,,  strat ======
00806:      PCH = SfContReadByte 
00807:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
            
            	; dtxEventTimer = (AX.U << 4);
00808:      		I1=		dtxEventTimer
0080A:      		AX=		AR
0080B:      		slz		AX, 2
0080C:      		slz		AX, 2
            
            	; AX = spiContReadByte();
            ;;<<System message ======  Macro. mSfContReadByte,7717,7720,,,,,,,,,,,,,,,,  strat ======
0080D:      PCH = SfContReadByte 
0080E:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
            
            	; dtxEventTimer |= (AX.U >> 4);
0080F:      		push		AR
00810:      		sra		AR, 2
00811:      		sra		AR, 2
00812:      		rm[I1]=		AR | AX
00813:      		AX=		rm[I1]
            
            	; dtxPlayInfo = (unsigned long)(AX.U & 0x000F);
00814:      		pop		AR
00815:      		I1=		dtxPlayInfo
00817:      		AR=		AR & 0x0F
00818:      		rm[I1]=		AR
            
            	; dtxnote += 2;
00819:      		I1=		dtxnote
0081B:      		AR=		rm[I1]
0081C:      		AR=		AR + 2
0081D:      		rm[I1++]=	AR
0081E:      		AR=		rm[I1]
0081F:      		AR=		AR + 0 + C
00820:      		rm[I1]=		AR
            
            	; if(!dtxPlayInfo)
00821:      		I1=		dtxPlayInfo
00823:      		AR=		rm[I1]
00824:      		if NZ jmp	@dtxdoe_label_0933
            	; {
            		; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7723,7725,,,,,,,,,,,,,,,,  strat ======
00825:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            		; return false;
00826:      			clr		Z
00827:      			rets
            	; }
            	@dtxdoe_label_0933:
            
            	; // ---
            
            	; while(PlayInfo)
            	@dtxdoe_loop_1400:
00828:      		io[ClrWDT]=	AR
00829:      		I1=		dtxPlayInfo
0082B:      		AR=		rm[I1]
0082C:      		if ZR jmp	@dtxdoe_label_0935
            	; {
            		; AX = spiContReadByte();
            ;;<<System message ======  Macro. mSfContReadByte,7717,7720,,,,,,,,,,,,,,,,  strat ======
0082D:      PCH = SfContReadByte 
0082E:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
0082F:      			AX=		AR
            
            		; note++;
00830:      			I1=		dtxnote
00832:      			AR=		rm[I1]
00833:      			AR++
00834:      			rm[I1++]=	AR
00835:      			AR=		rm[I1]
00836:      			AR=		AR + 0 + C
00837:      			rm[I1]=		AR
            
            		; //          byte 3
            		; // +---------------------+
            		; //      H           L
            		; // +---+-------+---------+
            		; // | 1 | 0 0 0 | x x x x |   command
            		; // +---+-------+---------+
            		; //           or
            		; // +---+-------+---------+
            		; // | y | y y y | x x x x |   data
            		; // +---+-------+---------+
            
            
            		; if(AX.N1 == 0x08)
00838:      			AR=		0x00F0
0083A:      			AR=		AR & AX
0083B:      			AH=		0xFF
0083C:      			SF=		AR - 0x80
0083D:      			if NE jmp	@dtxdoe_label_0939
            		; {
            			; // command prc
            
            			; note++;
0083E:      				I1=		dtxnote
00840:      				AR=		rm[I1]
00841:      				AR++
00842:      				rm[I1++]=	AR
00843:      				AR=		rm[I1]
00844:      				AR=		AR + 0 + C
00845:      				rm[I1]=		AR
            
            			; cmd = AX.N0;
00846:      				AR=		0x0F
00847:      				AR=		AX & AR
00848:      				push		AR
            
            			; AX = spiContReadByte();
            ;;<<System message ======  Macro. mSfContReadByte,7717,7720,,,,,,,,,,,,,,,,  strat ======
00849:      PCH = SfContReadByte 
0084A:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
0084B:      				AX=		AR
            
            			; switch(cmd)
0084C:      				pop		AR
0084D:      				SF=		AR - DTX_SET_CH1_INS
0084E:      				if EQ jmp	@dtxdoe_case_DTX_SET_CH1_INS_label_0948
0084F:      				SF=		AR - DTX_SET_CH2_INS
00850:      				if EQ jmp	@dtxdoe_case_DTX_SET_CH2_INS_label_0948
00851:      				SF=		AR - DTX_SET_CH4_INS
00852:      				if EQ jmp	@dtxdoe_case_DTX_SET_CH4_INS_label_0948
00853:      				SF=		AR - DTX_CHANGE_CH1_VOL
00854:      				if EQ jmp	@dtxdoe_case_DTX_CHANGE_CH1_VOL_label_0948
00855:      				SF=		AR - DTX_CHANGE_CH2_VOL
00856:      				if EQ jmp	@dtxdoe_case_DTX_CHANGE_CH2_VOL_label_0948
00857:      				SF=		AR - DTX_CHANGE_CH3_VOL
00858:      				if EQ jmp	@dtxdoe_case_DTX_CHANGE_CH3_VOL_label_0948
00859:      				SF=		AR - DTX_CHANGE_CH4_VOL
0085A:      				if EQ jmp	@dtxdoe_case_DTX_CHANGE_CH4_VOL_label_0948
0085B:      				SF=		AR - DTX_REST
0085C:      				if EQ jmp	@dtxdoe_case_DTX_REST_label_0948
0085D:      				SF=		AR - DTX_SET_NOTEOFF
0085E:      				if EQ jmp	@dtxdoe_case_DTX_SET_NOTEOFF_label_0948
0085F:      				SF=		AR - DTX_END_SONG
00860:      				if GE jmp	@dtxdoe_case_DTX_END_SONG_label_0948
00861:      				jmp		@dtxdoe_label_0955
            			; {
            				; case DTX_SET_CH1_INS:
            				@dtxdoe_case_DTX_SET_CH1_INS_label_0948:
            				; {
            					; SetTone(&ch[0].tone, (int)AX.U);
00862:      						BX=		dtxtonech
00864:      						call		dtxSetTone
            					; break;
00865:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_SET_CH2_INS:
            				@dtxdoe_case_DTX_SET_CH2_INS_label_0948:
            				; {
            					; SetTone(&ch[1].tone, (int)AX.U);
00866:      						BX=		dtxtonech + DTX_TONE_SIZEOF
00868:      						call		dtxSetTone
            					; break;
00869:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_SET_CH4_INS:
            				@dtxdoe_case_DTX_SET_CH4_INS_label_0948:
            				; {
            					; SetTone(&ch[3].tone, (int)AX.U);
0086A:      						BX=		dtxtonech + DTX_TONE_SIZEOF + DTX_TONE_SIZEOF
0086C:      						call		dtxSetTone
            					; break;
0086D:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_RESERVE3:
            					; break;
            
            				; case DTX_CHANGE_CH1_VOL:
            				@dtxdoe_case_DTX_CHANGE_CH1_VOL_label_0948:
            				; {
            					; SetChFLTG(&ch[0], (int)AX.U);
0086E:      						BX=		dtxtonech
00870:      						call		dtxSetToneFLTG
            					; break;
00871:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_CHANGE_CH2_VOL:
            				@dtxdoe_case_DTX_CHANGE_CH2_VOL_label_0948:
            				; {
            					; SetChFLTG(&ch[1], (int)AX.U);
00872:      						BX=		dtxtonech + DTX_TONE_SIZEOF
00874:      						call		dtxSetToneFLTG
            					; break;
00875:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_CHANGE_CH3_VOL:
            				@dtxdoe_case_DTX_CHANGE_CH3_VOL_label_0948:
            				; {
            					; SetChFLTG(&ch[2], (int)AX.U);
00876:      						BX=		dtxperc
00878:      						call		dtxSetPercFLTG
            					; break;
00879:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_CHANGE_CH4_VOL:
            				@dtxdoe_case_DTX_CHANGE_CH4_VOL_label_0948:
            				; {
            					; SetChFLTG(&ch[3], (int)AX.U);
0087A:      						BX=		dtxtonech + DTX_TONE_SIZEOF + DTX_TONE_SIZEOF
0087C:      						call		dtxSetToneFLTG
            					; break;
0087D:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_USER_CMD:
            					; break;
            
            				; case DTX_REST:
            				@dtxdoe_case_DTX_REST_label_0948:
            				; {
            					; //       H           L
            					; // +---------+--------------------------------+
            					; // | 0 0 0 0 | active bit for tone ctrl / flag|
            					; // +---------+--------------------------------+
            
            					; // TONE_FLAG as PlayChannel
            
            					; dtxPlayChannel &= (unsigned long)~AX.U;
0087E:      						AR=		-1
0087F:      						AX=		AX ^ AR
00880:      						I1=		dtxPlayChannel
00882:      						AR=		rm[I1]
00883:      						rm[I1]=		AR & AX
            
            					; dtxPlayInfo &= (unsigned long)~AX.U;
00884:      						I1=		dtxPlayInfo
00886:      						AR=		rm[I1]
00887:      						rm[I1]=		AR & AX
            
            					; break;
00888:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_SET_NOTEOFF:
            				@dtxdoe_case_DTX_SET_NOTEOFF_label_0948:
            				; {
            					; //       H           L
            					; // +---------+-----------------------------+
            					; // | 0 0 0 0 | active bit for CH_RAMP_FLAG |
            					; // +---------+-----------------------------+
            
            					; // CH_RAMP_FLAG as ReleaseChannel
            
            					; dtxReleaseCh |= (unsigned long)AX.U;
00889:      						I1=		dtxReleaseCh
0088B:      						AR=		rm[I1]
0088C:      						rm[I1]=		AR | AX
            
            					; PlayInfo &= (unsigned long)~AX.U;
0088D:      						AR=		-1
0088E:      						AX=		AX ^ AR
0088F:      						I1=		dtxPlayInfo
00891:      						AR=		rm[I1]
00892:      						rm[I1]=		AR & AX
            
            					; break;
00893:      						jmp		@dtxdoe_label_0955
            				; }
            
            				; case DTX_END_SONG:
            				@dtxdoe_case_DTX_END_SONG_label_0948:
            				; default:
            				; {
            					; dtxnote = 0;
00894:      						I1=		dtxnote
00896:      						AR=		0
00897:      						rm[I1++]=	AR
00898:      						rm[I1]=		AR
            
            					; dtxPlayChannel = 0;
00899:      						I1=		dtxPlayChannel
0089B:      						rm[I1]=		AR
            
            					; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7723,7725,,,,,,,,,,,,,,,,  strat ======
0089C:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            					; return false;
0089D:      						clr		Z
0089E:      						rets
            				; }
            			; }
            			@dtxdoe_label_0955:
            
0089F:      			jmp		@dtxdoe_label_0939_1
            		; }
            		; else
            		@dtxdoe_label_0939:
            		; {
            			; // data prc
            
            			; SetChannelData(AX);
008A0:      				call		dtxSetChannelData
            		; }
            		@dtxdoe_label_0939_1:
            
008A1:      		jmp		@dtxdoe_loop_1400
            	; }
            	@dtxdoe_label_0935:
            
            	; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7723,7725,,,,,,,,,,,,,,,,  strat ======
008A2:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; return true;
008A3:      		set		Z
008A4:      		rets
            ; }
            
            
            ; --------------------------------------------
            ; void SetTone(toneChannel *tonech, int ins)
            ;
            ; in:
            ;    tonech 	: BX
            ;    ins	: AX
            ;
            ; out:
            ;
            ;
            ; --------------------------------------------
            dtxSetTone:
            ; {
            	; unsigned long adr;
            	; DSP16 AX, BX;
            
            	; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7723,7725,,,,,,,,,,,,,,,,  strat ======
008A5:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; // read tone index map
            
            	; adr = dtxbaseadr + 16 + ins;
008A6:      		AR=		16
008A7:      		AX=		AX + AR
008A8:      		I1=		dtxbaseadr
008AA:      		AR=		rm[I1++]
008AB:      		AX=		AX + AR
008AC:      		AR=		rm[I1]
008AD:      		AR=		AR + 0 + C
            
            	; spiContReadStart(adr & ~1, &dtx);
008AE:      		push		AR
008AF:      		AR=		AX
008B0:      		clr		AR.b0
008B1:      		push		AR
008B2:      		AR=		BP
008B3:      		AR=		AR + 2
008B4:      		I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,7704,7708,,,,,,,,,,,,,,,,  strat ======
008B5:      AR= rm[I1 -- ] 
008B6:      P1 = rm[I1] 
008B7:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
008B8:      		pop		AR
008B9:      		pop		AR
            
            	; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7711,7714,,,,,,,,,,,,,,,,  strat ======
008BA:      PCH = SfContReadWord 
008BB:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            	; // high byte
            
            	; if(adr & 0x01)
008BC:      		test		AX.b0
008BD:      		if ZR jmp	@dtxst_label_1018
            	; {
            		; AX.U >>= 8;
008BE:      			xchg		AR
008BF:      		jmp		@dtxst_label_1018_1
            	; }
            	; else
            	@dtxst_label_1018:
            	; {
            		; AX.H = 0x00;
            	; }
            	@dtxst_label_1018_1:
008C0:      		AH=		0
008C1:      		AX=		AR
            
            	; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7723,7725,,,,,,,,,,,,,,,,  strat ======
008C2:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; AX.U <<= 2;
008C3:      		slz		AX, 2
            
            	; adr = dtxinsbase + AX.U;
008C4:      		I1=		dtxinsbase
008C6:      		AR=		rm[I1++]
008C7:      		AX=		AX + AR
008C8:      		AR=		rm[I1]
008C9:      		AR=		AR + 0 + C
            
            	; spiContReadStart(adr, &dtx);
008CA:      		push		AR
008CB:      		push		AX
008CC:      		AR=		BP
008CD:      		AR=		AR + 2
008CE:      		I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,7704,7708,,,,,,,,,,,,,,,,  strat ======
008CF:      AR= rm[I1 -- ] 
008D0:      P1 = rm[I1] 
008D1:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
008D2:      		pop		AR
008D3:      		pop		AR
            
            	; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7711,7714,,,,,,,,,,,,,,,,  strat ======
008D4:      PCH = SfContReadWord 
008D5:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
008D6:      		AX=		AR
            
            	; BX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7711,7714,,,,,,,,,,,,,,,,  strat ======
008D7:      PCH = SfContReadWord 
008D8:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
008D9:      		push		AR
            
            	; tonech->envsta = baseadr + ((unsigned long)BX.U << 16) + (unsigned long)AX.U;
008DA:      		I1=		dtxbaseadr + 1
008DC:      		AR=		rm[I1--]
008DD:      		push		AR
008DE:      		AR=		rm[I1]
008DF:      		push		AR
008E0:      		AR=		DTX_TONE_ENVSTA
008E1:      		AR=		AR + BX
008E2:      		I1=		AR
008E3:      		pop		AR
008E4:      		rm[I1++]=	AR + AX
008E5:      		pop		AX
008E6:      		pop		AR
008E7:      		rm[I1--]=	AR + AX + C
            
            	; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7723,7725,,,,,,,,,,,,,,,,  strat ======
008E8:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; // restore note pointer
            
            	; spiContReadStart(note, &dtx);
008E9:      		I1=		dtxnote_h
            ;;<<System message ======  Macro. mSfContReadStart,7704,7708,,,,,,,,,,,,,,,,  strat ======
008EB:      AR= rm[I1 -- ] 
008EC:      P1 = rm[I1] 
008ED:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
008EE:      	rets
            ; }
            
            ; --------------------------------------------
            ; void dtxSetToneFLTG(dtxChannel *chp, int FLTG)
            ;
            ; in:
            ;    BX		: chp
            ;    AX		: FLTG
            ;
            ;
            ;
            ;
            ; --------------------------------------------
            dtxSetToneFLTG:
            ; {
            	; chp->tone.FLTG = 0x0888 * FLTG;
008EF:      		MX=		0x0888
008F1:      		AR=		AX
            	#ifdef _MSPEECHDSP_
            		MULSS
            	#else
008F2:      		MR=		MX * AR
            	#endif
008F3:      		AR=		DTX_TONE_FLTG
008F4:      		AR=		AR + BX
008F5:      		I1=		AR
            
            	; AR = 0
            	; MR0 = AR
            
008F6:      		rm[I1]=		MR0
            
008F7:      	rets
            ; }
            
            
            ; --------------------------------------------
            ; void dtxSetPercFLTG(dtxChannel *chp, int FLTG)
            ;
            ; in:
            ;    BX		: chp
            ;    AX		: FLTG
            ;
            ;
            ;
            ;
            ; --------------------------------------------
            dtxSetPercFLTG:
            ; {
            	; chp->tone.FLTG = 0x0888 * FLTG;
            		; MX=		0x0888
            		; AR=		AX
            	; #ifdef _MSPEECHDSP_
            		; MULSS
            	; #else
            		; MR=		MX * AR
            	; #endif
            		; AR=		DTX_PERC_FLTG
            		; AR=		AR + BX
            		; I1=		AR
            		; rm[I1]=		MR0
            
008F8:      		slz		AX, 2
008F9:      		set		AX.b0
008FA:      		set		AX.b1
008FB:      		AR=		DTX_PERC_FLTG
008FC:      		AR=		AR + BX
008FD:      		I1=		AR
            
            	; AX = 0
            
008FE:      		rm[I1]=		AX
            
008FF:      	rets
            ; }
            
            
            ; --------------------------------------------
            ; void dtxSetChannelData(DSP16 AX)
            ;
            ; in:
            ;    AX		: AX
            ;
            ;
            ;
            ;
            ; --------------------------------------------
            dtxSetChannelData:
            ; {
            	; int i, adr;
            	; int mask;
            	; DSP16 BX;
            
            	; mask = 0x01;
00900:      		DX=		1
            
            	; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7723,7725,,,,,,,,,,,,,,,,  strat ======
00901:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; for(i = 0; i < MAX_DTX_CHANNEL; i++)
00902:      		CX=		MAX_DTX_CHANNEL - 1
00903:      		I1=		dtxPlayInfo
00905:      		BX=		rm[I1]
00906:      		MX=		dtxtonech
            	@dtxscd_loop_1128:
            	; {
            		; if(PlayInfo & mask)
00908:      			src		BX, 1
00909:      			if NC jmp	@dtxscd_label_1129
            		; {
            			; if(ch[i].type == dtxChannel::TONE_CHANNEL)
0090A:      				test		DX.b2
0090B:      				if NZ jmp	@dtxscd_label_1130
            			; {
            				; // read FREQ table in real chip
            
            				; ch[i].tone.envadr = ch[i].tone.envsta;
0090C:      					push		BX
0090D:      					push		DX
0090E:      					AR=		DTX_TONE_ENVSTA
0090F:      					AR=		MX + AR
00910:      					I1=		AR
00911:      					BX=		rm[I1++]
00912:      					DX=		rm[I1]
00913:      					AR=		MX		; DTX_TONE_ENVADR
00914:      					I1=		AR
00915:      					rm[I1++]=	BX
00916:      					rm[I1]=		DX
00917:      					pop		DX
00918:      					pop		BX
            
            				; ch[i].tone.TONE.FREQ = DTX_TONE_FREQ[AX.U];
00919:      					AR=		DTX_TONE_TONE
0091A:      					AR=		AR + MX
0091B:      					I1=		AR
0091C:      					P1=		#DTX_TONE_FREQ	; ~~ read stop !!
0091F:      					AR=		AX
00920:      					P1=		P1 + AR
00921:      					rm[I1++]=	pm[P1]
            
            				; ch[i].tone.TONECNT.FREQ = 0;
00922:      					AR=		0
00923:      					rm[I1]=		AR
            
            
00924:      				jmp		@dtxscd_label_1130_1
            			; }
            			; else
            			@dtxscd_label_1130:
            			; {
            				; memset(&dtxperc, 0, sizeof(dtxperc));
00925:      					push		CX
00926:      					I1=		dtxperc
00928:      					AR=		DTX_PERC_FLTI
00929:      					I1=		I1 + AR
0092A:      					CX=		DTX_PERC_SIZEOF - 4
0092B:      					AR=		0
            				@dtxscd_loop_1337:
0092C:      					rm[I1++]=	AR
0092D:      					loop		@dtxscd_loop_1337
0092E:      					pop		CX
            
            				; // perc + 128
            
            				; adr = dtxbaseadr + 16 + ((AX.U & 0x3F) | 0x80);
0092F:      					AR=		0x3F
00930:      					AX=		AX & AR
00931:      					AR=		0x0090
00933:      					AX=		AX + AR
00934:      					I1=		dtxbaseadr
00936:      					AR=		rm[I1++]
00937:      					AX=		AX + AR
00938:      					AR=		rm[I1]
00939:      					AR=		AR + 0 + C
            
            				; spiContReadStart(adr, &dtx);
0093A:      					push		AR
0093B:      					push		AX
0093C:      					AR=		BP
0093D:      					AR=		AR + 2
0093E:      					I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,7704,7708,,,,,,,,,,,,,,,,  strat ======
0093F:      AR= rm[I1 -- ] 
00940:      P1 = rm[I1] 
00941:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
00942:      					pop		AR
00943:      					pop		AR
            
            				; AX = spiContReadByte();
            ;;<<System message ======  Macro. mSfContReadByte,7717,7720,,,,,,,,,,,,,,,,  strat ======
00944:      PCH = SfContReadByte 
00945:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
00946:      					AX=		AR
            
            				; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7723,7725,,,,,,,,,,,,,,,,  strat ======
00947:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            				; // 4 bytes
            
            				; AX.U <<= 2;
00948:      					slz		AX, 2
            
            				; adr = dtxpercbase + AX.U;
00949:      					I1=		dtxpercbase
0094B:      					AR=		rm[I1++]
0094C:      					AX=		AX + AR
0094D:      					AR=		rm[I1]
0094E:      					AR=		AR + 0 + C
            
            				; spiContReadStart(adr, &dtx);
0094F:      					push		AR
00950:      					push		AX
00951:      					AR=		BP
00952:      					AR=		AR + 2
00953:      					I1=		AR
            ;;<<System message ======  Macro. mSfContReadStart,7704,7708,,,,,,,,,,,,,,,,  strat ======
00954:      AR= rm[I1 -- ] 
00955:      P1 = rm[I1] 
00956:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
00957:      					pop		AR
00958:      					pop		AR
            
            				; AX = spiContReadWord();
00959:      					push		BX
0095A:      					push		DX
            ;;<<System message ======  Macro. mSfContReadWord,7711,7714,,,,,,,,,,,,,,,,  strat ======
0095B:      PCH = SfContReadWord 
0095C:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
0095D:      					BX=		AR
            
            				; BX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7711,7714,,,,,,,,,,,,,,,,  strat ======
0095E:      PCH = SfContReadWord 
0095F:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00960:      					DX=		AR
            
            				; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7723,7725,,,,,,,,,,,,,,,,  strat ======
00961:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            				; ch[i].perc.insadr = baseadr + (((unsigned long)BX.U & 0x00FF) << 16) + (unsigned long)AX.U;
00962:      					push		DX
00963:      					I1=		dtxbaseadr
00965:      					DX.h=		0
00966:      					AR=		rm[I1++]
00967:      					BX=		BX + AR
00968:      					AR=		rm[I1]
00969:      					AR=		AR + DX + C
0096A:      					I1=		dtxperc
0096C:      					rm[I1++]=	BX
0096D:      					rm[I1++]=	AR
            
            				; // FLTP
            
            				; ch[i].perc.FLTP = (BX.U << 3) & 0xFF00;
0096E:      					pop		AR
0096F:      					slz		AR, 2
00970:      					slz		AR, 1
00971:      					AL=		0
00972:      					I1=		dtxperc + DTX_PERC_FLTP
00974:      					rm[I1]=		AR
00975:      					pop		DX
00976:      					pop		BX
            
            				; // pre-cache
            
            				; spiContReadStart(ch[i].perc.insadr, &dtx);
00977:      					I1=		dtxperc + 1
            ;;<<System message ======  Macro. mSfContReadStart,7704,7708,,,,,,,,,,,,,,,,  strat ======
00979:      AR= rm[I1 -- ] 
0097A:      P1 = rm[I1] 
0097B:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            				; AX = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7711,7714,,,,,,,,,,,,,,,,  strat ======
0097C:      PCH = SfContReadWord 
0097D:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            				; ch[i].perc.TASPAD.BUF = AX.S;
0097E:      					I1=		dtxperc + DTX_PERC_ADPCM_BUF
00980:      					rm[I1]=		AR
            
            				; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7723,7725,,,,,,,,,,,,,,,,  strat ======
00981:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            				; ch[i].perc.insadr += 2;
00982:      					I1=		dtxperc
00984:      					AR=		rm[I1]
00985:      					AR=		AR + 2
00986:      					rm[I1++]=	AR
00987:      					AR=		rm[I1]
00988:      					AR=		AR + 0 + C
00989:      					rm[I1]=		AR
            			; }
            			@dtxscd_label_1130_1:
            
            			; dtxPlayChannel |= mask;
0098A:      				I1=		dtxPlayChannel
0098C:      				AR=		rm[I1]
0098D:      				rm[I1]=		AR | DX
            
            			; dtxReleaseCh &= ~mask;
0098E:      				I1=		dtxReleaseCh
00990:      				push		DX
00991:      				AR=		-1
00992:      				DX=		DX ^ AR
00993:      				AR=		rm[I1]
00994:      				rm[I1]=		AR & DX
            
            			; dtxPlayInfo &= ~mask;
00995:      				I1=		dtxPlayInfo
00997:      				AR=		rm[I1]
00998:      				rm[I1]=		AR & DX
00999:      				pop		DX
            
            			; if(PlayInfo)
0099A:      				AR=		rm[I1]
0099B:      				if ZR jmp	@dtxscd_label_1358
            			; {
            				; spiContReadStart(note, &dtx);
0099C:      					I1=		dtxnote_h
            ;;<<System message ======  Macro. mSfContReadStart,7704,7708,,,,,,,,,,,,,,,,  strat ======
0099E:      AR= rm[I1 -- ] 
0099F:      P1 = rm[I1] 
009A0:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            				; AX = spiContReadByte();
            ;;<<System message ======  Macro. mSfContReadByte,7717,7720,,,,,,,,,,,,,,,,  strat ======
009A1:      PCH = SfContReadByte 
009A2:      lcall SfContReadByte 
            ;; System message>>====== Macro. mSfContReadByte end ======
009A3:      					AX=		AR
            
            				; note++;
009A4:      					I1=		dtxnote
009A6:      					AR=		rm[I1]
009A7:      					AR++
009A8:      					rm[I1++]=	AR
009A9:      					AR=		rm[I1]
009AA:      					AR=		AR + 0 + C
009AB:      					rm[I1]=		AR
            
            				; spiContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7723,7725,,,,,,,,,,,,,,,,  strat ======
009AC:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            			; }
            			@dtxscd_label_1358:
            		; }
            		@dtxscd_label_1129:
            
            		; mask <<= 1;
009AD:      			test		DX.b2
009AE:      			if NZ jmp	@dtxscd_label_1911
009AF:      				AR=		DTX_TONE_SIZEOF
009B0:      				MX=		MX + AR
            		@dtxscd_label_1911:
009B1:      			slz		DX, 1
            
009B2:      		loop		@dtxscd_loop_1128
            	; }
            
            	; spiContReadStart(note, &dtx);
009B3:      		I1=		dtxnote_h
            ;;<<System message ======  Macro. mSfContReadStart,7704,7708,,,,,,,,,,,,,,,,  strat ======
009B5:      AR= rm[I1 -- ] 
009B6:      P1 = rm[I1] 
009B7:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
009B8:      	rets
            ; }
            
            
            
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            ; ~.~---------------------------------------------------
            ; bool dtxFindToneEntry(unsigned long flashadr)
            ;
            ; in:
            ;    AX:BX		- flashadr
            ;
            ; out:
            ;
            ;
            ; affect registers:
            ;
            ;
            ; meaning registers:
            ;
            ;
            ; special request:
            ;
            ;
            ; -------------------------------------------------------------
            dtxFindToneEntry:
            ; {
            	; dtxbaseadr = flashadr;
009B9:      		I1=		dtxbaseadr
            	#ifdef DTX_WORD_ADR
009BB:      		slz		BX, 1
009BC:      		slc		AX, 1
            	#endif
009BD:      		rm[I1++]=	BX
009BE:      		rm[I1]=		AX
            
            	; dtxsonghdr = flashadr;
009BF:      		I1=		dtxsonghdr
009C1:      		rm[I1++]=	BX
009C2:      		rm[I1]=		AX
            
            	; sfContReadStart(HIADR(&dtxbaseadr));
            ;;<<System message ======  Macro. mSfContReadStart,7704,7708,,,,,,,,,,,,,,,,  strat ======
009C3:      AR= rm[I1 -- ] 
009C4:      P1 = rm[I1] 
009C5:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            	; AX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7711,7714,,,,,,,,,,,,,,,,  strat ======
009C6:      PCH = SfContReadWord 
009C7:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
009C8:      		AX=		AR
            
            	; BX = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7711,7714,,,,,,,,,,,,,,,,  strat ======
009C9:      PCH = SfContReadWord 
009CA:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
            
            	; ~~ check "DTX " mark
            
            	; if((AX != 0x5444) || (BX != 0x2058))
009CB:      		BX=		0x2058
009CD:      		SF=		AR - BX
009CE:      		if NZ jmp	@dtxfte_label_1821
009CF:      		AR=		0x5444
009D1:      		SF=		AR - AX
009D2:      		if NZ jmp	@dtxfte_label_1821
009D3:      		jmp		@dtxfte_label_1823
            	@dtxfte_label_1821:
            	; {
            		; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7723,7725,,,,,,,,,,,,,,,,  strat ======
009D4:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            		; return false;
009D5:      			clr		Z
009D6:      			rets
            	; }
            	@dtxfte_label_1823:
            
            
            	; dtxinsbase = dtxbaseadr + (unsigned long)head->InsAddrEntry;
009D7:      		I1=		dtxbaseadr_l
009D9:      		AX=		rm[I1++]
009DA:      		BX=		rm[I1]
            ;;<<System message ======  Macro. mSfContReadWord,7711,7714,,,,,,,,,,,,,,,,  strat ======
009DB:      PCH = SfContReadWord 
009DC:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
009DD:      		AX=		AX + AR
009DE:      		AR=		0
009DF:      		BX=		BX + AR + C
009E0:      		I1=		dtxinsbase
009E2:      		rm[I1++]=	AX
009E3:      		rm[I1]=		BX
            
            	; dtxpercbase = dtxbaseadr + (unsigned long)head->PercAddrEntry;
009E4:      		I1=		dtxbaseadr_l
009E6:      		AX=		rm[I1++]
009E7:      		BX=		rm[I1]
            ;;<<System message ======  Macro. mSfContReadWord,7711,7714,,,,,,,,,,,,,,,,  strat ======
009E8:      PCH = SfContReadWord 
009E9:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
009EA:      		AX=		AX + AR
009EB:      		AR=		0
009EC:      		BX=		BX + AR + C
009ED:      		I1=		dtxpercbase
009EF:      		rm[I1++]=	AX
009F0:      		rm[I1]=		BX
            
            	; dtxsonghdr = dtxbaseadr + (unsigned long)head->SongListEntry;
            ;;<<System message ======  Macro. mSfContReadWord,7711,7714,,,,,,,,,,,,,,,,  strat ======
009F1:      PCH = SfContReadWord 
009F2:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
009F3:      		AX=		AR
            ;;<<System message ======  Macro. mSfContReadWord,7711,7714,,,,,,,,,,,,,,,,  strat ======
009F4:      PCH = SfContReadWord 
009F5:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
009F6:      		BX=		AR
009F7:      		I1=		dtxbaseadr_l
009F9:      		AR=		rm[I1++]
009FA:      		AX=		AX + AR
009FB:      		AR=		rm[I1]
009FC:      		BX=		BX + AR + C
009FD:      		I1=		dtxsonghdr
009FF:      		rm[I1++]=	AX
00A00:      		rm[I1]=		BX
            
            	; ~~
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7723,7725,,,,,,,,,,,,,,,,  strat ======
00A01:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; sfContReadStart(HIADR(&dtxsonghdr));
00A02:      		I1=		dtxsonghdr_h
            ;;<<System message ======  Macro. mSfContReadStart,7704,7708,,,,,,,,,,,,,,,,  strat ======
00A04:      AR= rm[I1 -- ] 
00A05:      P1 = rm[I1] 
00A06:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            	; dtxsongcnt = spiContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7711,7714,,,,,,,,,,,,,,,,  strat ======
00A07:      PCH = SfContReadWord 
00A08:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00A09:      		I1=		dtxsongcnt
00A0B:      		rm[I1]=		AR
            
            	; dtxsonghdr += 2;
00A0C:      		I1=		dtxsonghdr_l
00A0E:      		AR=		rm[I1]
00A0F:      		AR=		AR + 2
00A10:      		rm[I1++]=	AR
00A11:      		AR=		rm[I1]
00A12:      		AR=		AR + 0 + C
00A13:      		rm[I1]=		AR
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7723,7725,,,,,,,,,,,,,,,,  strat ======
00A14:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            
            	; return true;
00A15:      		set		Z
00A16:      		rets
            ; }
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~.~------------------------------------------------------------
            ; bool dtxPlaySong(short index)
            ;
            ; in:
            ;    AX			- index
            ;
            ; out:
            ;    none
            ;
            ; affect registers:
            ;    All
            ;
            ; meaning registers:
            ;
            ;
            ; special request:
            ;   none
            ;
            ; -------------------------------------------------------------
            dtxPlaySong:
            ; {
            	; if(index >= mp.songcnt)
00A17:      		I1=		dtxsongcnt
00A19:      		AR=		rm[I1]
00A1A:      		SF=		AR - AX
00A1B:      		if LE jmp	@dtxplaysong_label_1541
00A1C:      		jmp		@dtxplaysong_label_1541_1
            	@dtxplaysong_label_1541:
            	; {
            		; return false;
00A1D:      			clr		Z
00A1E:      			rets
            	; }
            	@dtxplaysong_label_1541_1:
            
            
            	; dtxnote = dtxsonghdr + (index * sizeof(long));
00A1F:      		I1=		dtxsonghdr
00A21:      		BX=		rm[I1++]
00A22:      		DX=		rm[I1]
00A23:      		I1=		dtxnote
00A25:      		AR=		AX
00A26:      		slz		AR, 2
00A27:      		rm[I1++]=	BX + AR
00A28:      		AR=		0
00A29:      		rm[I1]=		DX + AR + C
            
            	; sfContReadStart(HIADR(&dtxnote));
00A2A:      		I1=		dtxnote_h
            ;;<<System message ======  Macro. mSfContReadStart,7704,7708,,,,,,,,,,,,,,,,  strat ======
00A2C:      AR= rm[I1 -- ] 
00A2D:      P1 = rm[I1] 
00A2E:      P1.hh = AR 
            ;; System message>>====== Macro. mSfContReadStart end ======
            
            	; lo = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7711,7714,,,,,,,,,,,,,,,,  strat ======
00A2F:      PCH = SfContReadWord 
00A30:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00A31:      		BX=		AR
            
            	; hi = sfContReadWord();
            ;;<<System message ======  Macro. mSfContReadWord,7711,7714,,,,,,,,,,,,,,,,  strat ======
00A32:      PCH = SfContReadWord 
00A33:      lcall SfContReadWord 
            ;; System message>>====== Macro. mSfContReadWord end ======
00A34:      		DX=		AR
            
            	; dtxnote = dtxbaseadr + (hi << 16) + lo;
00A35:      		I1=		dtxbaseadr
00A37:      		AR=		rm[I1++]
00A38:      		BX=		BX + AR
00A39:      		AR=		rm[I1]
00A3A:      		DX=		DX + AR + C
00A3B:      		I1=		dtxnote
00A3D:      		rm[I1++]=	BX
00A3E:      		rm[I1]=		DX
            
            	; sfContReadStop();
            ;;<<System message ======  Macro. mSfContReadStop,7723,7725,,,,,,,,,,,,,,,,  strat ======
00A3F:      P1.hh = 0 
            ;; System message>>====== Macro. mSfContReadStop end ======
            
            	; dtxBaseTimer = 0x001F;
00A40:      		AR=		0x001F
00A41:      		I1=		dtxBaseTimer
00A43:      		rm[I1]=		AR
            
            	; dtxEventTimer = 0;
00A44:      		I1=		dtxEventTimer
00A46:      		rm[I1]=		AR
            
            	; dtxStartBGServe();
00A47:      		PCH=		dtxStartBGServe
00A48:      		lcall		dtxStartBGServe
            
            	; return true;
00A49:      		set		Z
00A4A:      		rets
            ; }
            
            ; -----------------------------------------------
            
            
            dtxStopSong:
            ; {
00A4B:      	I1=		dtxnote
00A4D:      	AR=		0
00A4E:      	rm[I1++]=	AR
00A4F:      	rm[I1++]=	AR
            
00A50:      	I1=		dtxPlayChannel
00A52:      	rm[I1]=		AR
            
00A53:      	rets
            ; }
            
            
            ; -----------------------------------------------
            
            
            dtxCheckSongEnd:
            ; {
00A54:      	I1=		dtxnote
00A56:      	AR=		rm[I1++]
00A57:      	AX=		rm[I1]
00A58:      	AR=		AR | AX
00A59:      	rets
            ; }
            
            
            
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            dtxStartBGServe:
            ; {
            	; ClearIntReq(INT0);
00A5A:      		clr		io[INTREQ].b0
            
            	; EnableInterrupt(INT0);
00A5B:      		ena		INT0
            
            	; EnableInterrupts();
00A5C:      		eni
            
00A5D:      	rets
            ; }
            
            
            
            dtxStopBGServe:
            ; {
            	; DisableInterrupt(INT0);
00A5E:      		dsi		INT0
            
            	; ClearIntReq(INT0);
00A5F:      		clr		io[INTREQ].b0
            
00A60:      	rets
            ; }
            
            
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\DTXPLAYER.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\SPROM.ASM> Start=========================
            
            sfContReadByte:
            ; {
00A61:      	AR=		P1.hh
00A62:      	sra		AR, 1
00A63:      	P1.hh=		AR
00A64:      	src		P1, 1
00A65:      	AR=		pm[P1]
00A66:      	if NC jmp	@sfcrw_label_1736
00A67:      	push		AR
00A68:      	AR=		P1.hh
00A69:      	slc		P1, 1
00A6A:      	slc		AR, 1
00A6B:      	P1.hh=		AR
00A6C:      	AR=		pm[P1++]
00A6D:      	pop		AR
00A6E:      	xchg		AR
00A6F:      	jmp		@sfcrw_label_1813
            @sfcrw_label_1736:
00A70:      	push		AR
00A71:      	AR=		P1.hh
00A72:      	slc		P1, 1
00A73:      	slc		AR, 1
00A74:      	P1.hh=		AR
00A75:      	AR=		pm[P1++]
00A76:      	pop		AR
            @sfcrw_label_1813:
00A77:      	AH=		0
00A78:      	rets
            ; }
            
            
            ; ~~~~~~ no word align !!
            
            SfContReadWord:
            ; {
00A79:      	AR=		P1.hh
00A7A:      	sra		AR, 1
00A7B:      	P1.hh=		AR
00A7C:      	src		P1, 1
00A7D:      	AR=		pm[P1++]
            	
00A7E:      	push		AR
00A7F:      	AR=		P1.hh
00A80:      	slc		P1, 1
00A81:      	slc		AR, 1
00A82:      	P1.hh=		AR
00A83:      	pop		AR
00A84:      	rets
            ; }
            
            
            ; --------------------------------------------
            
            macro	mSfContReadStart
            	AR=		rm[I1--]
            	P1=		rm[I1]
            	P1.hh=		AR
            endm
            
            
            macro	mSfContReadWord
            	PCH=		SfContReadWord
            	lcall		SfContReadWord
            endm
            
            
            macro	mSfContReadByte
            	PCH=		SfContReadByte
            	lcall		SfContReadByte
            endm
            
            
            macro mSfContReadStop
            	P1.hh=		0
            endm
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\SPROM.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\DTX_CSHELL-E.ASM> Start=========================
            
            
            _dtxDoEvent05EA2C8C:
00A85:      	PCH=		dtxDoEvent
00A86:      	lcall		dtxDoEvent
            L3F7E7BE2_0:
00A87:      	AX=		0
00A88:      	if NZ jmp	L3F7E7BE2_1
00A89:      	AX=		1
            L3F7E7BE2_1:
00A8A:      	rets
            
            
            
            _dtxFindToneEntry12F3B4ED:
            ; DX:AX just right "flashadr"
00A8B:      	AR=		AX
00A8C:      	BX=		AR
00A8D:      	AR=		DX
00A8E:      	AX=		AR
00A8F:      	PCH=		dtxFindToneEntry
00A90:      	lcall		dtxFindToneEntry
00A91:      	jmp		L3F7E7BE2_0
            
            
            _dtxPlaySong5B7DBDA5:
            ; AX - just right "index"
00A92:      	PCH=		dtxPlaySong
00A93:      	lcall		dtxPlaySong
00A94:      	jmp		L3F7E7BE2_0
            
            
            _dtxCheckSongEnd870A9712:
00A95:      	PCH=		dtxCheckSongEnd
00A96:      	lcall		dtxCheckSongEnd
00A97:      	jmp		L3F7E7BE2_0
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\LIB\LIBDTX\DTX_CSHELL-E.ASM> End=========================
            
            ;
            #LINKOBJ ".\LIB\LIBSUBB3\SBB3_CH0DECV05.OBJ"
            ;
            
            ;=========================Include <.\LIB\LIBSUBB3\SUB3SUPP.ASM> Start=========================
            
            
            #ifdef _MSPEECHDSP_
            
            Subb3_Init:
            	PCH=            SDSP_Sbb3_Ch0InitV05
            	lcall           SDSP_Sbb3_Ch0InitV05
            	rets
            
            Subb3_Dec:
            	PCH=		SDSP_Sbb3_Ch0decV05
            	lcall		SDSP_Sbb3_Ch0decV05
                    AX=		0
                    if NZ jmp	@sdsp_sbb2_ch0dec_a
                    AX=		1
            @sdsp_sbb2_ch0dec_a:
            	rets
            	
            #else
            
            Subb3_Init:
02DF0:      	PCH=            Sbb3_Ch0InitV05
02DF1:      	lcall           Sbb3_Ch0InitV05
02DF2:      	rets
            
            Subb3_Dec:
02DF3:      	PCH=		Sbb3_Ch0decV05
02DF4:      	lcall		Sbb3_Ch0decV05
02DF5:              AX=		0
02DF6:              if NZ jmp	@sdsp_sbb2_ch0dec_a
02DF7:              AX=		1
            @sdsp_sbb2_ch0dec_a:
02DF8:      	rets
            	
            #endif
            
            
            
            	
            ;=========================Include <.\LIB\LIBSUBB3\SUB3SUPP.ASM> End=========================
            
            ;=========================Include <DEPS\6466E35F_GINIT.S.CODE.ASM> Start=========================
            ; 6466E35F_ginit.s.c Code Start!!;
            VarRM[0:4095]={
              
            };
            
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            ; //
            .code
            ; //
            ; //
            ; //naked void ginit_code(void)			
            ginit_code:
            ; //{
            ; //	ginit_code_HOW_DO_I_PLAY_DTX_AND_SUBBAND3_SIMULTANEOUSLY_528516D5_s();
02DF9:      	pch	= ginit_code_HOW_DO_I_PLAY_DTX_AND_SUBBAND3_SIMULTANEOUSLY_528516D5_s
02DFA:      	lcall	ginit_code_HOW_DO_I_PLAY_DTX_AND_SUBBAND3_SIMULTANEOUSLY_528516D5_s
            ; //	ginit_code_global_6037E6D5_s();		
02DFB:      	pch	= ginit_code_global_6037E6D5_s
02DFC:      	lcall	ginit_code_global_6037E6D5_s
            ; //	ginit_code_keypad_0E0216C1_s();		
02DFD:      	pch	= ginit_code_keypad_0E0216C1_s
02DFE:      	lcall	ginit_code_keypad_0E0216C1_s
            ; //	ginit_code_led_376AFC9D_s();		
02DFF:      	pch	= ginit_code_led_376AFC9D_s
02E00:      	lcall	ginit_code_led_376AFC9D_s
            ; //	ginit_code_sub3play_8ED4FA41_s();	
02E01:      	pch	= ginit_code_sub3play_8ED4FA41_s
02E02:      	lcall	ginit_code_sub3play_8ED4FA41_s
            ; //	ginit_code_data_0EBCA7F9_s();		
02E03:      	pch	= ginit_code_data_0EBCA7F9_s
02E04:      	lcall	ginit_code_data_0EBCA7F9_s
            ; //	ginit_code_dtx_3359D009_s();		
02E05:      	pch	= ginit_code_dtx_3359D009_s
02E06:      	lcall	ginit_code_dtx_3359D009_s
            ; //	ginit_code_sub3_cshell_257767F9_s();	
02E07:      	pch	= ginit_code_sub3_cshell_257767F9_s
02E08:      	lcall	ginit_code_sub3_cshell_257767F9_s
            ; //	return;					
02E09:      	rets
            ; //}
            ; //
            ; //
            ; //
            ;=========================Include <DEPS\6466E35F_GINIT.S.CODE.ASM> End=========================
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> Start=========================
            
            
            ; ~~ CRT0 support functions
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GLOBALINIT(void)
            ; void sfx_LOCALINIT(void)
            ;
            ; in:
            ;     I1	- pointer to SRAM initial value
            ;     P1	- pointer to PROM initial data
            ;     CX	- total count (word)
            ;
            ; out:
            ;     none
            ;
            ; --------------------------------------------
            sfx_GLOBALINIT:
            sfx_LOCALINIT:
02E0A:      	P1.hh=		0
02E0B:      	jmp		@glinit_label_1409
            @glinit_loop_1409:
02E0C:      	AR=		pm[P1++]
02E0D:      	rm[I1++]=	AR
            @glinit_label_1409:
02E0E:      	loop		@glinit_loop_1409
02E0F:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MUL_AX_CX(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MUL_AX_CX:
            
02E10:      	AR=		AX
02E11:      	MX=		AR
02E12:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
02E13:      	MACOP=		3
02E14:      	MR=		MX * AR
            #endif
            
02E15:      	AR=		MR0
02E16:      	AX=		AR
02E17:      	AR=		MR1
02E18:      	DX=		AR
02E19:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMUL_AX_CX(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMUL_AX_CX:
            
02E1A:      	AR=		AX
02E1B:      	MX=		AR
02E1C:      	AR=		CX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
02E1D:      	MACOP=		0
02E1E:      	MR=		MX * AR
            #endif
            
02E1F:      	AR=		MR0
02E20:      	AX=		AR
02E21:      	AR=		MR1
02E22:      	DX=		AR
02E23:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMULLONG(void)
            ;
            ; note:
            ;     signed multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (signed)
            ;
            ; --------------------------------------------
            sfx_IMULLONG:
02E24:      	AR=		rm[BP_SAVE]
02E25:      	push		AR
02E26:      	AR=		BP
02E27:      	rm[BP_SAVE]=	AR
02E28:      	AR=		AR - 3
02E29:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
02E2A:      	AR=		CX
02E2B:      	MX=		AR
02E2C:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
02E2D:      	MACOP=		3		; unsigned
02E2E:      	MR=		MX * AR
            #endif
            
02E2F:      	I1=		rm[BP_SAVE]
02E30:      	AR=		2
02E31:      	I1=		I1 - AR
02E32:      	rm[I1++]=	MR0
02E33:      	rm[I1++]=	MR1
02E34:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
02E35:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUS
            #else
02E36:      	MACOP=		1		; mx:unsigned / my:signed
02E37:      	MR=		MX * AR
            #endif
            
02E38:      	AR=		rm[I1]
02E39:      	AR=		AR + MR0
02E3A:      	rm[I1++]=	AR
02E3B:      	AR=		rm[I1]
02E3C:      	AR=		AR + MR1 + C
02E3D:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
02E3E:      	AR=		BX
02E3F:      	MX=		AR
02E40:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULSU
            #else
02E41:      	MACOP=		2		; mx:signed / my:unsigned
02E42:      	MR=		MX * AR
            #endif
            
02E43:      	AR=		rm[I1]
02E44:      	AR=		AR + MR0
02E45:      	rm[I1++]=	AR
02E46:      	AR=		rm[I1]
02E47:      	AR=		AR + MR1 + C
02E48:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
02E49:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULSS
            #else
02E4A:      	MACOP=		0		; mx:signed / my:signed
02E4B:      	MR=		MX * AR
            #endif
            
02E4C:      	AR=		rm[I1]
02E4D:      	AR=		AR + MR0
02E4E:      	rm[I1]=		AR
            
02E4F:      	I1=		rm[BP_SAVE]
02E50:      	CX=		rm[I1--]
02E51:      	DX=		rm[I1--]
02E52:      	AX=		rm[I1]
            
02E53:      	AR=		3
02E54:      	BP=		BP + AR
02E55:      	pop		AR
02E56:      	rm[BP_SAVE]=	AR
            
02E57:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MULLONG(void)
            ;
            ; note:
            ;     unsigned multiply
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     CX:DX:AX	- result (unsigned)
            ;
            ; --------------------------------------------
            sfx_MULLONG:
02E58:      	AR=		rm[BP_SAVE]
02E59:      	push		AR
02E5A:      	AR=		BP
02E5B:      	rm[BP_SAVE]=	AR
02E5C:      	AR=		AR - 3
02E5D:      	BP=		AR
            
            	; ~~ low 16-bit
            	; ~~ |   ---- oooo
            	; ~~ | x ---- oooo
            
02E5E:      	AR=		CX
02E5F:      	MX=		AR
02E60:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
02E61:      	MACOP=		3		; unsigned
02E62:      	MR=		MX * AR
            #endif
            
02E63:      	I1=		rm[BP_SAVE]
02E64:      	AR=		2
02E65:      	I1=		I1 - AR
02E66:      	rm[I1++]=	MR0
02E67:      	rm[I1++]=	MR1
02E68:      	rm[I1--]=	MR2
            
            	; ~~ |   oooo ----
            	; ~~ | x ---- oooo
            
02E69:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
02E6A:      	MR=		MX * AR
            #endif
            
02E6B:      	AR=		rm[I1]
02E6C:      	AR=		AR + MR0
02E6D:      	rm[I1++]=	AR
02E6E:      	AR=		rm[I1]
02E6F:      	AR=		AR + MR1 + C
02E70:      	rm[I1--]=	AR
            
            
            	; ~~ |   ---- oooo
            	; ~~ | x oooo ----
            
02E71:      	AR=		BX
02E72:      	MX=		AR
02E73:      	AR=		AX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
02E74:      	MR=		MX * AR
            #endif
            
02E75:      	AR=		rm[I1]
02E76:      	AR=		AR + MR0
02E77:      	rm[I1++]=	AR
02E78:      	AR=		rm[I1]
02E79:      	AR=		AR + MR1 + C
02E7A:      	rm[I1]=		AR
            
            	; ~~ |   oooo ----
            	; ~~ | x oooo ----
            
02E7B:      	AR=		DX
            
            #ifdef _MSPEECHDSP_
            	MULUU
            #else
02E7C:      	MR=		MX * AR
            #endif
            
02E7D:      	AR=		rm[I1]
02E7E:      	AR=		AR + MR0
02E7F:      	rm[I1]=		AR
            
02E80:      	I1=		rm[BP_SAVE]
02E81:      	CX=		rm[I1--]
02E82:      	DX=		rm[I1--]
02E83:      	AX=		rm[I1]
            
02E84:      	AR=		3
02E85:      	BP=		BP + AR
02E86:      	pop		AR
02E87:      	rm[BP_SAVE]=	AR
            
02E88:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIV_AX_CX(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIV_AX_CX:
            	; unsigned int reste = 0;
02E89:      		DX=		0
            	; unsigned char count = 16;
02E8A:      		R0=		16
            	; BOOL c;
            
            	; do
            	@divword_loop_1824:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
02E8B:      			slz		AX, 1
            		; reste <<= 1;
02E8C:      			slc		DX, 1
            
            		; if (c)
            		; {
            			; reste |= 1;
            		; }
            		@divword_label_1822:
            
            		; if (reste >= y)
02E8D:      			AR=		DX
02E8E:      			AR-=		CX
02E8F:      			AR=		0
02E90:      			AR=		AR - 0 + C - 1
02E91:      			if AN jmp	@divword_label_1823
            		; {
            			; reste -= y;
02E92:      				AR=		CX
02E93:      				DX=		DX - AR
            			; ~~ x <- (result = 1)
            			; x |= 1;
02E94:      				set		AX.b0
            		; }
            		@divword_label_1823:
            
02E95:      		R0--
02E96:      		if NZ jmp	@divword_loop_1824
            	; }while (--count);
            
            	; return x;
02E97:      		rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIV_AX_CX(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Quotient
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIV_AX_CX:
            
            	; register int r;
            
            	; r = sfx_DIV_AX_CX((x < 0 ? -x : x), (y < 0 ? -y : y));
02E98:      		R1=		0
02E99:      		AR=		0
02E9A:      		test		AX.b15
02E9B:      		if ZR jmp	@divsword_label_1833
02E9C:      			AX=		AR - AX
02E9D:      			set		R1.b0
            		@divsword_label_1833:
02E9E:      		test		CX.b15
02E9F:      		if ZR jmp	@divsword_label_1834
02EA0:      			CX=		AR - CX
02EA1:      			set		R1.b1
            		@divsword_label_1834:
02EA2:      		call		sfx_DIV_AX_CX
            
            	; if ((x < 0) ^ (y < 0))
02EA3:      		AR=		R1
02EA4:      		slz		AR, 1
02EA5:      		AR^=		R1
02EA6:      		test		AR.b1
02EA7:      		if ZR jmp	@divsword_label_1835
            	; {
            		; return (0 - r);
02EA8:      			AR=		0
02EA9:      			AX=		AR - AX
02EAA:      			DX=		AR - DX
            
            	; }
            	@divsword_label_1835:
            
            	; return r;
02EAB:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_DIVLONG(void)
            ;
            ; note:
            ;     unsigned divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_DIVLONG:
            	; unsigned long reste = 0L;
02EAC:      		R0=		0	; L
02EAD:      		R1=		0	; H
            	; unsigned char count = 32;
02EAE:      		R2=		32
            	; BOOL c;
            
            	; do
            	@divulong_loop_1723:
            	; {
            		; // reste: x <- 0;
            		; c = MSB_SET(x);
            
            		; x <<= 1;
02EAF:      			slz		AX, 1
02EB0:      			slc		DX, 1
            		; reste <<= 1;
02EB1:      			slc		R0, 1
02EB2:      			slc		R1, 1
            
            		; if (c)
            		; {
            			; reste |= 1L;
            		; }
            		@divulong_label_1726:
            
            		; if (reste >= y)
02EB3:      			AR=		R0
02EB4:      			AR-=		CX
02EB5:      			AR=		R1
02EB6:      			AR=		AR - BX + C - 1
02EB7:      			if AN jmp	@divulong_label_1734
            		; {
            			; reste -= y;
02EB8:      				AR=		CX
02EB9:      				R0=		R0 - AR
02EBA:      				AR=		BX
02EBB:      				R1=		R1 - AR + C - 1
            			; ~~ x <- (result = 1)
            			; x |= 1L;
02EBC:      				set		AX.b0
            		; }
            		@divulong_label_1734:
            
02EBD:      		R2--
02EBE:      		if NZ jmp	@divulong_loop_1723
            	; }while (--count);
            
            	; return x;
02EBF:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IDIVLONG(void)
            ;
            ; note:
            ;     signed divide
            ;
            ; in:
            ;     DX:AX	- Numerator   (x)
            ;     BX:CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Quotient
            ;     BX:DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IDIVLONG:
            	; long r;
            
            	; r = divulong((x < 0 ? -x : x), (y < 0 ? -y : y));
02EC0:      		R3=		0
02EC1:      		AR=		0
02EC2:      		test		DX.b15
02EC3:      		if ZR jmp	@divslong_label_1759
02EC4:      			AX=		AR - AX
02EC5:      			DX=		AR - DX + C - 1
02EC6:      			set		R3.b0
            		@divslong_label_1759:
02EC7:      		test		BX.b15
02EC8:      		if ZR jmp	@divslong_label_1800
02EC9:      			CX=		AR - CX
02ECA:      			BX=		AR - BX + C - 1
02ECB:      			set		R3.b1
            		@divslong_label_1800:
02ECC:      		call		sfx_DIVLONG
            
            	; if ((x < 0) ^ (y < 0))
02ECD:      		AR=		R3
02ECE:      		slz		AR, 1
02ECF:      		AR^=		R3
02ED0:      		test		AR.b1
02ED1:      		if ZR jmp	@divslong_label_1807
            	; {
            		; return -r;
02ED2:      			AR=		0
02ED3:      			AX=		AR - AX
02ED4:      			DX=		AR - DX + C - 1
02ED5:      			R0=		AR - R0
02ED6:      			R1=		AR - R1 + C - 1
            
            	; }
            	@divslong_label_1807:
            
            	; return r;
02ED7:      		rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MOD_AX_CX(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_MOD_AX_CX:
02ED8:      	call		sfx_DIV_AX_CX
02ED9:      	AR=		DX
02EDA:      	AX=		AR
02EDB:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMOD_AX_CX(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     AX	- Remainder
            ;     DX	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMOD_AX_CX:
02EDC:      	call		sfx_IDIV_AX_CX
02EDD:      	AR=		DX
02EDE:      	AX=		AR
02EDF:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_MODLONG(void)
            ;
            ; note:
            ;     unsigned remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_MODLONG:
02EE0:      	call		sfx_DIVLONG
02EE1:      	AR=		R0
02EE2:      	AX=		AR
02EE3:      	AR=		R1
02EE4:      	DX=		AR
02EE5:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_IMODLONG(void)
            ;
            ; note:
            ;     signed remainder
            ;
            ; in:
            ;     AX	- Numerator   (x)
            ;     CX	- Denominator (y)
            ;
            ; out:
            ;     DX:AX	- Remainder
            ;     R1:R0	- Remainder
            ;
            ; --------------------------------------------
            sfx_IMODLONG:
02EE6:      	call		sfx_IDIVLONG
02EE7:      	AR=		R0
02EE8:      	AX=		AR
02EE9:      	AR=		R1
02EEA:      	DX=		AR
02EEB:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG:
            	; AR=		CX
            	; AX=		AX + AR
            	; AR=		BX
            	; DX=		DX + AR + C
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDLONG_BXCX_DXAX(void)
            ;
            ; note:
            ;     signed add
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ADDLONG_BXCX_DXAX:
            	; AR=		AX
            	; CX=		CX + AR
            	; AR=		DX
            	; BX=		BX + AR + C
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBLONG(void)
            ;
            ; note:
            ;     signed sub
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SUBLONG:
            	; AR=		CX
            	; AX=		AX - AR
            	; AR=		BX
            	; DX=		DX - AR + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDDIOFS(void)
            ;
            ; note:
            ;     add P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDDIOFS:
02EEC:      	AR=		AX
02EED:      	P1=		P1 + AR
02EEE:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDSIOFS(void)
            ;
            ; note:
            ;     add I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_ADDSIOFS:
02EEF:      	AR=		AX
02EF0:      	I1=		I1 + AR
02EF1:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ADDAXOFS(void)
            ;
            ; note:
            ;     add AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_ADDAXOFS:
02EF2:      	AR=		CX
02EF3:      	AX=		AX + AR
02EF4:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBDIOFS(void)
            ;
            ; note:
            ;     sub P1 by AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     P1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBDIOFS:
02EF5:      	AR=		AX
02EF6:      	P1=		P1 - AR
02EF7:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBSIOFS(void)
            ;
            ; note:
            ;     sub I1 by AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;     AX	- offset
            ;
            ; out:
            ;     I1	- offset
            ;
            ; --------------------------------------------
            sfx_SUBSIOFS:
02EF8:      	AR=		AX
02EF9:      	I1=		I1 - AR
02EFA:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SUBAXOFS(void)
            ;
            ; note:
            ;     sub AX by CX
            ;
            ; in:
            ;     AX	- PROM or SRAM pointer
            ;     CX	- offset
            ;
            ; out:
            ;     AX	- offset
            ;
            ; --------------------------------------------
            sfx_SUBAXOFS:
02EFB:      	AR=		CX
02EFC:      	AX=		AX + AR
02EFD:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_DXAX(void)
            ;
            ; note:
            ;     load long data from PROM to DX:AX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG:
            ; sfx_GETDILONG_DXAX:
            	; AX=		pm[P1++]
            	; DX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETDILONG_BXCX(void)
            ;
            ; note:
            ;     load long data from PROM to BX:CX
            ;
            ; in:
            ;     P1	- PROM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETDILONG_BXCX:
            	; CX=		pm[P1++]
            	; BX=		pm[P1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_DXAX(void)
            ; void sfx_GETSILONG_DXAX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to DX:AX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     DX:AX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG:
            ; sfx_GETSILONG_D:
            ; sfx_GETSILONG_DXAX:
            ; sfx_GETSILONG_DXAX_D:
            	; AX=		rm[I1++]
            	; DX=		rm[I1--]
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_GETSILONG_BXCX(void)
            ; void sfx_GETSILONG_BXCX_D(void)		; for function's parameter
            ;
            ; note:
            ;     load long data from SRAM to BX:CX
            ;
            ; in:
            ;     I1	- SRAM pointer
            ;
            ; out:
            ;     BX:CX	- long data
            ;
            ; --------------------------------------------
            ; sfx_GETSILONG_BXCX:
            ; sfx_GETSILONG_BXCX_D:
            	; CX=		rm[I1++]
            	; BX=		rm[I1--]
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ANDLONG(void)
            ;
            ; note:
            ;     AND two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ANDLONG:
            	; AR=		CX
            	; AX=		AX & AR
            	; AR=		BX
            	; DX=		DX & AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_ORLONG(void)
            ;
            ; note:
            ;     OR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_ORLONG:
            	; AR=		CX
            	; AX=		AX | AR
            	; AR=		BX
            	; DX=		DX | AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XORLONG(void)
            ;
            ; note:
            ;     XOR two 32-bit data and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_XORLONG:
            	; AR=		CX
            	; AX=		AX ^ AR
            	; AR=		BX
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHL_AX_CX(void)
            ;
            ; note:
            ;     left shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHL_AX_CX:
            	; jmp		@shlac_label_1653
            ; @shlac_loop_1653:
            	; slz		AX, 1
            ; @shlac_label_1653:
            	; loop		@shlac_loop_1653
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_SHLLONG(void)
            ;
            ; note:
            ;     left shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHLLONG:
            	; jmp		@shllong_label_1653
            ; @shllong_loop_1653:
            	; slz		AX, 1
            	; slc		DX, 1
            ; @shllong_label_1653:
            	; loop		@shllong_loop_1653
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX_CX(void)
            ;
            ; note:
            ;     unsigned right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX_CX:
            	; jmp		@shrac_label_1657
            ; @shrac_loop_1657:
            	; clr		C
            	; src		AX, 1
            ; @shrac_label_1657:
            	; loop		@shrac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX_CX(void)
            ;
            ; note:
            ;     signed right shift AX data by CX and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;     CX	- shift count
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX_CX:
            	; jmp		@sarac_label_1657
            ; @sarac_loop_1657:
            	; sra		AX, 1
            ; @sarac_label_1657:
            	; loop		@sarac_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SARLONG(void)
            ;
            ; note:
            ;     signed right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- long data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SARLONG:
            	; jmp		@sarlong_label_1657
            ; @sarlong_loop_1657:
            	; sra		DX, 1
            	; src		AX, 1
            ; @sarlong_label_1657:
            	; loop		@sarlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHRLONG(void)
            ;
            ; note:
            ;     unsigned right shift DX:AX data by CX and store result in DX:AX
            ;
            ; in:
            ;     DX:AX	- ulong data
            ;     CX	- shift count
            ;
            ; out:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHRLONG:
            	; jmp		@shrlong_label_1657
            ; @shrlong_loop_1657:
            	; clr		C
            	; src		DX, 1
            	; src		AX, 1
            ; @shrlong_label_1657:
            	; loop		@shrlong_loop_1657
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SHR_AX(void)
            ;
            ; note:
            ;     unsigned right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SHR_AX:
            	; clr		C
            	; src		AX, 1
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_SAR_AX(void)
            ;
            ; note:
            ;     signed right shift AX data and store result in AX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; out:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_SAR_AX:
            	; sra		AX, 1
            	; rets
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG(void)
            ; void sfx_STORSILONG_D(void)		; for function's parameter
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG:
            ; sfx_STORSILONG_D:
            	; rm[I1++]=	AX
            	; rm[I1--]=	DX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORSILONG_BXCX(void)
            ;
            ; note:
            ;     store DX:AX data to SRAM (I1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     I1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_STORSILONG_BXCX:
            	; rm[I1++]=	CX
            	; rm[I1--]=	BX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG:
02EFE:      	pm[P1++]=	AX
02EFF:      	pm[P1--]=	DX
02F00:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_STORDILONG(void)
            ;
            ; note:
            ;     store DX:AX data to PROM (P1)
            ;
            ; in:
            ;     DX:AX	- long data
            ;     P1	- pointer
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            sfx_STORDILONG_BXCX:
02F01:      	pm[P1++]=	CX
02F02:      	pm[P1--]=	BX
02F03:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CX to BX
            ;
            ; in:
            ;     CX	- signed short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_CX:
            ; sfx_INT2ULONG_CX:
            	; BX=		0
            	; test		CX.b15
            	; if ZR jmp	@i2lcx_label_1756
            	; BX=		-1
            ; @i2lcx_label_1756:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_CX(void)
            ;
            ; note:
            ;     convert short unsigned value CX to long (BX:CX)
            ;
            ; in:
            ;     CX	- unsigned short data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_CX:
            ; sfx_UINT2ULONG_CX:
            	; BX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_CX(void)
            ;
            ; note:
            ;     extend sign bit of CL to BX:CH
            ;
            ; in:
            ;     CX	- signed char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_CX:
02F04:      	BX=		0
02F05:      	CX.h=		0
02F06:      	test		CX.b7
02F07:      	if ZR jmp	@c2lcx_label_1800
02F08:      	CX.h=		0xFF
02F09:      	BX=		-1
            @c2lcx_label_1800:
02F0A:      	rets
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_CX(void)
            ;
            ; note:
            ;     convert unsigned char value CL to long (BX:CX)
            ;
            ; in:
            ;     CL	- unsigned char data
            ;
            ; result:
            ;     BX:CX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_CX:
            	; CX.h=		0
            	; BX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INT2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AX to DX
            ;
            ; in:
            ;     AX	- signed short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_INT2LONG_AX:
            ; sfx_INT2ULONG_AX:
            	; DX=		0
            	; test		AX.b15
            	; if ZR jmp	@i2lax_label_1756
            	; DX=		-1
            ; @i2lax_label_1756:
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UINT2LONG_AX(void)
            ;
            ; note:
            ;     convert short unsigned value AX to long (DX:AX)
            ;
            ; in:
            ;     AX	- unsigned short data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UINT2LONG_AX:
            ; sfx_UINT2ULONG_AX:
            	; DX=		0
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CHAR2LONG_AX(void)
            ;
            ; note:
            ;     extend sign bit of AL to DX:AH
            ;
            ; in:
            ;     AX	- signed char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            sfx_CHAR2LONG_AX:
02F0B:      	DX=		0
02F0C:      	AX.h=		0
02F0D:      	test		AX.b7
02F0E:      	if ZR jmp	@c2lax_label_1800
02F0F:      	AX.h=		0xFF
02F10:      	DX=		-1
            @c2lax_label_1800:
02F11:      	rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_UCHAR2LONG_AX(void)
            ;
            ; note:
            ;     convert unsigned char value AL to long (DX:AX)
            ;
            ; in:
            ;     AL	- unsigned char data
            ;
            ; result:
            ;     DX:AX	- signed long data
            ;
            ; --------------------------------------------
            ; sfx_UCHAR2LONG_AX:
            	; AX.h=		0
            	; DX=		0
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_CALL_BY_AX(void)
            ;
            ; note:
            ;     call sub routine in AX (address)
            ;
            ; in:
            ;     AX	- sub routine address
            ;
            ; result:
            ;     none
            ;
            ; --------------------------------------------
            ; sfx_CALL_BY_AX:
            	; AR=		AX
            	; P1=		AR
            	; P1.hh=		0
            	; fjmp		pm[P1]
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHG_AX_CX(void)
            ;
            ; note:
            ;     exchange AX CX value
            ;
            ; in:
            ;     AX	- operator 1
            ;     CX	- operator 2
            ;
            ; result:
            ;     AX <-> CX
            ;
            ; --------------------------------------------
            ; sfx_XCHG_AX_CX:
            	; push		AX
            	; push		CX
            	; pop		AX
            	; pop		CX
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_XCHGLONG(void)
            ;
            ; note:
            ;     exchange DX:AX BX:CX value
            ;
            ; in:
            ;     DX:AX	- operator 1
            ;     BX:CX	- operator 2
            ;
            ; result:
            ;     DX:AX <-> BX:CX
            ;
            ; --------------------------------------------
            sfx_XCHGLONG:
02F12:      	push		AX
02F13:      	push		CX
02F14:      	pop		AX
02F15:      	pop		CX
02F16:      	push		DX
02F17:      	push		BX
02F18:      	pop		DX
02F19:      	pop		BX
02F1A:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEG_AX(void)
            ;
            ; note:
            ;     negative AX
            ;
            ; in:
            ;     AX	- operator 1
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEG_AX:
            	; AR=		0
            	; AX=		AR - AX
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NEGLONG(void)
            ;
            ; note:
            ;     negative DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NEGLONG:
            	; AR=		0
            	; AX=		AR - AX
            	; DX=		AR - DX + C - 1
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOT_AX(void)
            ;
            ; note:
            ;     not AX
            ;
            ; in:
            ;     AX	- operator
            ;
            ; result:
            ;     AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOT_AX:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_NOTLONG(void)
            ;
            ; note:
            ;     not DX:AX
            ;
            ; in:
            ;     DX:AX	- operator
            ;
            ; result:
            ;     DX:AX	- result
            ;
            ; --------------------------------------------
            ; sfx_NOTLONG:
            	; AR=		-1
            	; AX=		AX ^ AR
            	; DX=		DX ^ AR
            	; rets
            
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOT_AX(void)
            ;
            ; note:
            ;     logical NOT
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_LOGNOT_AX:
            	;; x86 code
            	;;   neg AX
            	;;   sbb AX,AX
            	;;   inc AX
            	; AR=		0
            	; AR=		AR - AX
            	; AX=		AR
            	; AX=		AR - AX + C - 1
            	; AX++
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_LOGNOTLONG(void)
            ;
            ; note:
            ;     logical NOT (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            sfx_LOGNOTLONG:
            	; x86 code
            	;   neg AX
            	;   sbb AX,AX
            	;   inc AX
02F1B:      	AR=		DX
02F1C:      	DX=		0
02F1D:      	AR=		AR | AX
02F1E:      	AX=		1
02F1F:      	if ZR jmp	@longnotl_label_1120
02F20:      	AX=		0
            @longnotl_label_1120:
02F21:      	rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOL_AX(void)
            ;
            ; note:
            ;     logical BOOL
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOL_AX:
            	;; x86 code
            	;;   neg ax
            	;;   sbb ax,ax
            	;;   neg ax
            	; AR=		AX
            	; AX=		0
            	; if ZR jmp	@boolax_label_1758
            	; AX=		1
            ; @boolax_label_1758:
            	; rets
            	
            	; AR=		-1
            	; AR=		AR + AX
            	; AX=		0
            	; AX += C
            
            
            ; ~.~-----------------------------------------
            ; void sfx_BOOLLONG(void)
            ;
            ; note:
            ;     logical BOOL (long)
            ;
            ; in:
            ;     DX:AX	- value
            ;
            ; result:
            ;     DX:AX	- result (0 or 1)
            ;
            ; --------------------------------------------
            ; sfx_BOOLLONG:
            	; AR=		DX
            	; DX=		0
            	; AR=		AR | AX
            	; AX=		0
            	; if ZR jmp	@boollong_label_1801
            	; AX=		1
            ; @boollong_label_1801:
            	; rets
            
            
            ; ~.~-----------------------------------------
            ; void sfx_INITSISTOR(void)
            ;
            ; note:
            ;     for used in global/local variable initial
            ;
            ; in:
            ;     AX	- value
            ;
            ; result:
            ;     I1 + 1
            ;
            ; --------------------------------------------
            ; sfx_INITSISTOR:
            	; rm[I1++]=	AX
            	; rets
            
            ; --------------------------------------------
            
            ; sfx_INITSISTORLONG:
            	; rm[I1++]=	AX
            	; rm[I1++]=	DX
            	; rets
            
            
            ; ~~ condition assistant functions ~~
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; JNE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            sfx_CMP_AX_CX_U_JNE:
02F22:      	DX=		0
02F23:      	BX=		0
            sfx_CMPLONG_JNE:
02F24:      	AR=		CX
02F25:      	AX=		AX - AR
02F26:      	AR=		BX
02F27:      	AR=		DX - AR + C - 1
02F28:      	AR=		AR | AX
02F29:      	if EQ jmp	@sfx_cl_jne_f
02F2A:      	set		Z		; true
02F2B:      	rets
            @sfx_cl_jne_f:
02F2C:      	clr		Z		; false
02F2D:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JNE:
02F2E:      	DX=		0
02F2F:      	BX=		0
            sfx_CMPLONG_BCDA_JNE:
02F30:      	AR=		AX
02F31:      	CX=		CX - AR
02F32:      	AR=		DX
02F33:      	AR=		BX - AR + C - 1
02F34:      	AR=		AR | CX
02F35:      	if EQ jmp	@sfx_clbcda_jne_f
02F36:      	set		Z		; true
02F37:      	rets
            @sfx_clbcda_jne_f:
02F38:      	clr		Z		; false
02F39:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JNE:
02F3A:      	AR=		CX
02F3B:      	SF=		AX - AR
02F3C:      	if EQ jmp	@sfx_ac_jne_f
02F3D:      	set		Z
02F3E:      	rets
            @sfx_ac_jne_f:
02F3F:      	clr		Z
02F40:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JNE:
02F41:      	AR=		AX
02F42:      	SF=		CX - AR
02F43:      	if EQ jmp	@sfx_ca_jne_f
02F44:      	set		Z
02F45:      	rets
            @sfx_ca_jne_f:
02F46:      	clr		Z
02F47:      	rets
            
            
            
            ; JE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            
            
            sfx_CMP_AX_CX_U_JE:
02F48:      	DX=		0
02F49:      	BX=		0
            sfx_CMPLONG_JE:
02F4A:      	AR=		CX
02F4B:      	AX=		AX - AR
02F4C:      	AR=		BX
02F4D:      	AR=		DX - AR + C - 1
02F4E:      	AR=		AR | AX
02F4F:      	if NE jmp	@sfx_cl_jz_f
02F50:      	set		Z		; true
02F51:      	rets
            @sfx_cl_jz_f:
02F52:      	clr		Z		; false
02F53:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_U_JE:
02F54:      	DX=		0
02F55:      	BX=		0
            sfx_CMPLONG_BCDA_JE:
02F56:      	AR=		AX
02F57:      	CX=		CX - AR
02F58:      	AR=		DX
02F59:      	AR=		BX - AR + C - 1
02F5A:      	AR=		AR | CX
02F5B:      	if NE jmp	@sfx_clbcda_jz_f
02F5C:      	set		Z		; true
02F5D:      	rets
            @sfx_clbcda_jz_f:
02F5E:      	clr		Z		; false
02F5F:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JE:
02F60:      	AR=		CX
02F61:      	SF=		AX - AR
02F62:      	if NE jmp	@sfx_ac_je_f
02F63:      	set		Z
02F64:      	rets
            @sfx_ac_je_f:
02F65:      	clr		Z
02F66:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JE:
02F67:      	AR=		AX
02F68:      	SF=		CX - AR
02F69:      	if NE jmp	@sfx_ca_je_f
02F6A:      	set		Z
02F6B:      	rets
            @sfx_ca_je_f:
02F6C:      	clr		Z
02F6D:      	rets
            
            
            
            ; JG group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; A - above (unsigned)
            ; G - greater (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JA:
            sfx_CMP_AX_CX_JA:
02F6E:      	DX=		0
02F6F:      	BX=		0
            sfx_CMPLONG_JG:
02F70:      	AR=		CX
02F71:      	AX=		AX - AR
02F72:      	AR=		BX
02F73:      	AR=		DX - AR + C - 1
02F74:      	if AN jmp	@sfx_cl_jg_f
            
            	; exclude EQU condition
02F75:      	AR=		AR | AX
02F76:      	if ZR jmp	@sfx_cl_jg_f
            
02F77:      	set		Z		; true
02F78:      	rets
            @sfx_cl_jg_f:
02F79:      	clr		Z		; false
02F7A:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JA:
02F7B:      	AR=		CX
02F7C:      	AX=		AX - AR
02F7D:      	AR=		BX
02F7E:      	DX=		DX - AR + C - 1
02F7F:      	AR=		0
02F80:      	AR=		AR - 0 + C - 1
02F81:      	if AN jmp	@sfx_cl_jg_f
            
02F82:      	AR=		AR | DX		; exclude EQU condition
02F83:      	AR=		AR | AX
02F84:      	if ZR jmp	@sfx_cl_jg_f
            
02F85:      	set		Z		; true
02F86:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JA:
            sfx_CMP_CX_AX_JA:
02F87:      	DX=		0
02F88:      	BX=		0
            sfx_CMPLONG_BCDA_JG:
02F89:      	AR=		AX
02F8A:      	CX=		CX - AR
02F8B:      	AR=		DX
02F8C:      	AR=		BX - AR + C - 1
02F8D:      	if AN jmp	@sfx_clbcda_jg_f
            
02F8E:      	AR=		AR | CX		; exclude EQU condition
02F8F:      	if ZR jmp	@sfx_clbcda_jg_f
            
02F90:      	set		Z		; true
02F91:      	rets
            @sfx_clbcda_jg_f:
02F92:      	clr		Z		; false
02F93:      	rets
            
            ; ~~---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JA:
02F94:      	AR=		AX
02F95:      	CX=		CX - AR
02F96:      	AR=		DX
02F97:      	BX=		BX - AR + C - 1
02F98:      	AR=		0
02F99:      	AR=		AR - 0 + C - 1
02F9A:      	if AN jmp	@sfx_clbcda_jg_f
            
02F9B:      	AR=		AR | BX		; exclude EQU condition
02F9C:      	AR=		AR | CX
02F9D:      	if ZR jmp	@sfx_clbcda_jg_f
            
02F9E:      	set		Z		; true
02F9F:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JG:
02FA0:      	AR=		CX
02FA1:      	SF=		AX - AR
02FA2:      	if LE jmp	@sfx_cmp_ac_jg_f
02FA3:      	set		Z
02FA4:      	rets
            @sfx_cmp_ac_jg_f:
02FA5:      	clr		Z
02FA6:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JG:
02FA7:      	AR=		AX
02FA8:      	SF=		CX - AR
02FA9:      	if LE jmp	@sfx_cmp_ca_jg_f
02FAA:      	set		Z
02FAB:      	rets
            @sfx_cmp_ca_jg_f:
02FAC:      	clr		Z
02FAD:      	rets
            
            
            ; JGE group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JAE:
            sfx_CMP_AX_CX_JAE:
02FAE:      	DX=		0
02FAF:      	BX=		0
            sfx_CMPLONG_JGE:
02FB0:      	AR=		CX
02FB1:      	AX=		AX - AR
02FB2:      	AR=		BX
02FB3:      	DX=		DX - AR + C - 1
02FB4:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
            
02FB5:      	set		Z		; true
02FB6:      	rets
            @sfx_cl_jge_f:
02FB7:      	clr		Z		; false
02FB8:      	rets
            
            ; ~~-----------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JAE:
02FB9:      	AR=		CX
02FBA:      	AX=		AX - AR
02FBB:      	AR=		BX
02FBC:      	DX=		DX - AR + C - 1
02FBD:      	AR=		0
02FBE:      	AR=		AR - 0 + C - 1
02FBF:      	if AN jmp	@sfx_cl_jge_f
            
            	; ~~ ignore equ condition
02FC0:      	set		Z		; true
02FC1:      	rets
            
            ; ---------
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JAE:
            sfx_CMP_CX_AX_JAE:
02FC2:      	DX=		0
02FC3:      	BX=		0
            sfx_CMPLONG_BCDA_JGE:
02FC4:      	AR=		AX
02FC5:      	CX=		CX - AR
02FC6:      	AR=		DX
02FC7:      	BX=		BX - AR + C - 1
02FC8:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
            
02FC9:      	set		Z		; true
02FCA:      	rets
            @sfx_clbcda_jge_f:
02FCB:      	clr		Z		; false
02FCC:      	rets
            
            ; ---------
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JAE:
02FCD:      	AR=		AX
02FCE:      	CX=		CX - AR
02FCF:      	AR=		DX
02FD0:      	BX=		BX - AR + C - 1
02FD1:      	AR=		0
02FD2:      	AR=		AR - 0 + C - 1
02FD3:      	if AN jmp	@sfx_clbcda_jge_f
            
            	; ~~ ignore equ condition
02FD4:      	set		Z		; true
02FD5:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JGE:
02FD6:      	AR=		CX
02FD7:      	SF=		AX - AR
02FD8:      	if AN jmp	@sfx_cmp_ac_jge_f
02FD9:      	set		Z
02FDA:      	rets
            @sfx_cmp_ac_jge_f:
02FDB:      	clr		Z
02FDC:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JGE:
02FDD:      	AR=		AX
02FDE:      	SF=		CX - AR
02FDF:      	if AN jmp	@sfx_cmp_ca_jge_f
02FE0:      	set		Z
02FE1:      	rets
            @sfx_cmp_ca_jge_f:
02FE2:      	clr		Z
02FE3:      	rets
            
            
            ; JL group
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            ; B - below (unsigned)
            ; L - less (signed)
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JB:
            sfx_CMP_AX_CX_JB:
02FE4:      	DX=		0
02FE5:      	BX=		0
            sfx_CMPLONG_JL:
02FE6:      	AR=		CX
02FE7:      	AX=		AX - AR
02FE8:      	AR=		BX
02FE9:      	AR=		DX - AR + C - 1
02FEA:      	if AN jmp	@sfx_cl_jl_chk
            
            @sfx_cl_jl_f:
02FEB:      	clr		Z		; false
02FEC:      	rets
            
            @sfx_cl_jl_chk:
02FED:      	AR=		AR | AX		; exclude EQU condition
02FEE:      	if ZR jmp	@sfx_cl_jl_f
02FEF:      	set		Z
02FF0:      	rets
            
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JB:
02FF1:      	AR=		CX
02FF2:      	AX=		AX - AR
02FF3:      	AR=		BX
02FF4:      	DX=		DX - AR + C - 1
02FF5:      	AR=		0
02FF6:      	AR=		AR - 0 + C - 1
02FF7:      	if AN jmp	@sfx_cl_jb_chk
            
            @sfx_cl_jb_f:
02FF8:      	clr		Z		; false
02FF9:      	rets
            
            @sfx_cl_jb_chk:
02FFA:      	AR=		AR | DX
02FFB:      	AR=		AR | AX		; exclude EQU condition
02FFC:      	if ZR jmp	@sfx_cl_jb_f
02FFD:      	set		Z
02FFE:      	rets
            
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JB:
            sfx_CMP_CX_AX_JB:
02FFF:      	DX=		0
03000:      	BX=		0
            sfx_CMPLONG_BCDA_JL:
03001:      	AR=		AX
03002:      	CX=		CX - AR
03003:      	AR=		DX
03004:      	AR=		BX - AR + C - 1
03005:      	if AN jmp	@sfx_clbcda_jl_chk
            
            @sfx_clbcda_jl_f:
03006:      	clr		Z		; false
03007:      	rets
            
            @sfx_clbcda_jl_chk:
03008:      	AR=		AR | CX		; exclude EQU condition
03009:      	if ZR jmp	@sfx_clbcda_jl_f
0300A:      	set		Z		; true
0300B:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JB:
0300C:      	AR=		AX
0300D:      	CX=		CX - AR
0300E:      	AR=		DX
0300F:      	BX=		BX - AR + C - 1
03010:      	AR=		0
03011:      	AR=		AR - 0 + C - 1
03012:      	if AN jmp	@sfx_clbcda_jb_chk
            
            @sfx_clbcda_jb_f:
03013:      	clr		Z		; false
03014:      	rets
            
            @sfx_clbcda_jb_chk:
03015:      	AR=		AR | CX
03016:      	AR=		AR | BX
03017:      	if ZR jmp	@sfx_clbcda_jb_f
03018:      	set		Z		; true
03019:      	rets
            
            
            ; ---------
            
            sfx_CMP_AX_CX_JL:
0301A:      	AR=		CX
0301B:      	SF=		AX - AR
0301C:      	if GE jmp	@sfx_cmp_ac_jl_f
0301D:      	set		Z
0301E:      	rets
            @sfx_cmp_ac_jl_f:
0301F:      	clr		Z
03020:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JL:
03021:      	AR=		AX
03022:      	SF=		CX - AR
03023:      	if GE jmp	@sfx_cmp_ca_jl_f
03024:      	set		Z
03025:      	rets
            @sfx_cmp_ca_jl_f:
03026:      	clr		Z
03027:      	rets
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_AX_CX_U_JBE:
            sfx_CMP_AX_CX_JBE:
03028:      	DX=		0
03029:      	BX=		0
            sfx_CMPLONG_JLE:
0302A:      	AR=		CX
0302B:      	AX=		AX - AR
0302C:      	AR=		BX
0302D:      	AR=		DX - AR + C - 1
0302E:      	if AN jmp	@sfx_cl_jle_t
            
0302F:      	AR=		AR | AX		; include EQU condition
03030:      	if ZR jmp	@sfx_cl_jle_t
            
03031:      	clr		Z		; false
03032:      	rets
            @sfx_cl_jle_t:
03033:      	set		Z		; true
03034:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_JBE:
03035:      	AR=		CX
03036:      	AX=		AX - AR
03037:      	AR=		BX
03038:      	DX=		DX - AR + C - 1
03039:      	AR=		0
0303A:      	AR=		AR - 0 + C - 1
0303B:      	if AN jmp	@sfx_cl_jle_t
            
0303C:      	AR=		AR | DX
0303D:      	AR=		AR | AX
0303E:      	if ZR jmp	@sfx_cl_jle_t
            
0303F:      	clr		Z		; false
03040:      	rets
            
            ; ---------
            
            ; ~~ using 32-bit to correct flag
            
            sfx_CMP_CX_AX_U_JBE:
            sfx_CMP_CX_AX_JBE:
03041:      	DX=		0
03042:      	BX=		0
            sfx_CMPLONG_BCDA_JLE:
03043:      	AR=		AX
03044:      	CX=		CX - AR
03045:      	AR=		DX
03046:      	AR=		BX - AR + C - 1
03047:      	if AN jmp	@sfx_clbcda_jle_t
            
03048:      	AR=		AR | CX		; include EQU condition
03049:      	if ZR jmp	@sfx_clbcda_jle_t
            
0304A:      	clr		Z		; false
0304B:      	rets
            @sfx_clbcda_jle_t:
0304C:      	set		Z		; true
0304D:      	rets
            
            ; ~~ using 48-bit to correct flag
            
            sfx_CMPLONG_BCDA_JBE:
0304E:      	AR=		AX
0304F:      	CX=		CX - AR
03050:      	AR=		DX
03051:      	BX=		BX - AR + C - 1
03052:      	AR=		0
03053:      	AR=		AR - 0 + C - 1
03054:      	if AN jmp	@sfx_clbcda_jle_t
            
03055:      	AR=		AR | BX
03056:      	AR=		AR | CX
03057:      	if ZR jmp	@sfx_clbcda_jle_t
            
03058:      	clr		Z		; false
03059:      	rets
            
            ; ---------
            
            sfx_CMP_AX_CX_JLE:
0305A:      	AR=		CX
0305B:      	SF=		AX - AR
0305C:      	if LE jmp	@sfx_cmp_ac_jl_t
0305D:      	clr		Z
0305E:      	rets
            @sfx_cmp_ac_jl_t:
0305F:      	set		Z
03060:      	rets
            
            ; ---------
            
            sfx_CMP_CX_AX_JLE:
03061:      	AR=		AX
03062:      	SF=		CX - AR
03063:      	if LE jmp	@sfx_cmp_ca_jl_t
03064:      	clr		Z
03065:      	rets
            @sfx_cmp_ca_jl_t:
03066:      	set		Z
03067:      	rets
            
            
            ; ~!~ bit-field support
            
            @sfx_ortable_0:
03068:      	DW 0xFFFE
            @sfx_ortable_1:
03069:      	DW 0xFFFC
            @sfx_ortable_2:
0306A:      	DW 0xFFF8
            @sfx_ortable_3:
0306B:      	DW 0xFFF0
            @sfx_ortable_4:
0306C:      	DW 0xFFE0
            @sfx_ortable_5:
0306D:      	DW 0xFFC0
            @sfx_ortable_6:
0306E:      	DW 0xFF80
            @sfx_ortable_7:
0306F:      	DW 0xFF00
            @sfx_ortable_8:
03070:      	DW 0xFE00
            @sfx_ortable_9:
03071:      	DW 0xFC00
            @sfx_ortable_10:
03072:      	DW 0xF800
            @sfx_ortable_11:
03073:      	DW 0xF000
            @sfx_ortable_12:
03074:      	DW 0xE000
            @sfx_ortable_13:
03075:      	DW 0xC000
            @sfx_ortable_14:
03076:      	DW 0x8000
            
            ; ~!~
            
            @sfx_orhigh:
03077:      	AR=		pm[P1]
03078:      	DX=		DX | AR
03079:      	rets
            
            @sfx_orhigh_dx:
0307A:      	DX=		-1
            @sfx_orlow:
0307B:      	AR=		pm[P1]
0307C:      	AX=		AX | AR
            @sfx_sextw_rets:
0307D:      	rets
            
            ; ~!~ signed short
            
            sfx_SignExtW0:
0307E:      	P1=		#@sfx_ortable_0
03081:      	test		AX.b0
03082:      	if ZR jmp	@sfx_sextw_rets
03083:      	jmp		@sfx_orlow
            
            sfx_SignExtW1:
03084:      	P1=		#@sfx_ortable_1
03087:      	test		AX.b1
03088:      	if ZR jmp	@sfx_sextw_rets
03089:      	jmp		@sfx_orlow
            
            sfx_SignExtW2:
0308A:      	P1=		#@sfx_ortable_2
0308D:      	test		AX.b2
0308E:      	if ZR jmp	@sfx_sextw_rets
0308F:      	jmp		@sfx_orlow
            
            sfx_SignExtW3:
03090:      	P1=		#@sfx_ortable_3
03093:      	test		AX.b3
03094:      	if ZR jmp	@sfx_sextw_rets
03095:      	jmp		@sfx_orlow
            
            sfx_SignExtW4:
03096:      	P1=		#@sfx_ortable_4
03099:      	test		AX.b4
0309A:      	if ZR jmp	@sfx_sextw_rets
0309B:      	jmp		@sfx_orlow
            
            sfx_SignExtW5:
0309C:      	P1=		#@sfx_ortable_5
0309F:      	test		AX.b5
030A0:      	if ZR jmp	@sfx_sextw_rets
030A1:      	jmp		@sfx_orlow
            
            sfx_SignExtW6:
030A2:      	P1=		#@sfx_ortable_6
030A5:      	test		AX.b6
030A6:      	if ZR jmp	@sfx_sextw_rets
030A7:      	jmp		@sfx_orlow
            
            sfx_SignExtW7:
030A8:      	P1=		#@sfx_ortable_7
030AB:      	test		AX.b7
030AC:      	if ZR jmp	@sfx_sextw_rets
030AD:      	jmp		@sfx_orlow
            
            sfx_SignExtW8:
030AE:      	P1=		#@sfx_ortable_8
030B1:      	test		AX.b8
030B2:      	if ZR jmp	@sfx_sextw_rets
030B3:      	jmp		@sfx_orlow
            
            sfx_SignExtW9:
030B4:      	P1=		#@sfx_ortable_9
030B7:      	test		AX.b9
030B8:      	if ZR jmp	@sfx_sextw_rets
030B9:      	jmp		@sfx_orlow
            
            sfx_SignExtW10:
030BA:      	P1=		#@sfx_ortable_10
030BD:      	test		AX.b10
030BE:      	if ZR jmp	@sfx_sextw_rets
030BF:      	jmp		@sfx_orlow
            
            sfx_SignExtW11:
030C0:      	P1=		#@sfx_ortable_11
030C3:      	test		AX.b11
030C4:      	if ZR jmp	@sfx_sextw_rets
030C5:      	jmp		@sfx_orlow
            
            sfx_SignExtW12:
030C6:      	P1=		#@sfx_ortable_12
030C9:      	test		AX.b12
030CA:      	if ZR jmp	@sfx_sextw_rets
030CB:      	jmp		@sfx_orlow
            
            sfx_SignExtW13:
030CC:      	P1=		#@sfx_ortable_13
030CF:      	test		AX.b13
030D0:      	if ZR jmp	@sfx_sextw_rets
030D1:      	jmp		@sfx_orlow
            
            sfx_SignExtW14:
030D2:      	P1=		#@sfx_ortable_14
030D5:      	test		AX.b14
030D6:      	if ZR jmp	@sfx_sextw_rets
030D7:      	jmp		@sfx_orlow
            
            ; ~!~ signed long
            
            sfx_SignExtL0:
030D8:      	P1=		#@sfx_ortable_0
030DB:      	test		AX.b0
030DC:      	if ZR jmp	@sfx_sextw_rets
030DD:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL1:
030DE:      	P1=		#@sfx_ortable_1
030E1:      	test		AX.b1
030E2:      	if ZR jmp	@sfx_sextw_rets
030E3:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL2:
030E4:      	P1=		#@sfx_ortable_2
030E7:      	test		AX.b2
030E8:      	if ZR jmp	@sfx_sextw_rets
030E9:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL3:
030EA:      	P1=		#@sfx_ortable_3
030ED:      	test		AX.b3
030EE:      	if ZR jmp	@sfx_sextw_rets
030EF:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL4:
030F0:      	P1=		#@sfx_ortable_4
030F3:      	test		AX.b4
030F4:      	if ZR jmp	@sfx_sextw_rets
030F5:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL5:
030F6:      	P1=		#@sfx_ortable_5
030F9:      	test		AX.b5
030FA:      	if ZR jmp	@sfx_sextw_rets
030FB:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL6:
030FC:      	P1=		#@sfx_ortable_6
030FF:      	test		AX.b6
03100:      	if ZR jmp	@sfx_sextw_rets
03101:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL7:
03102:      	P1=		#@sfx_ortable_7
03105:      	test		AX.b7
03106:      	if ZR jmp	@sfx_sextw_rets
03107:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL8:
03108:      	P1=		#@sfx_ortable_8
0310B:      	test		AX.b8
0310C:      	if ZR jmp	@sfx_sextw_rets
0310D:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL9:
0310E:      	P1=		#@sfx_ortable_9
03111:      	test		AX.b9
03112:      	if ZR jmp	@sfx_sextw_rets
03113:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL10:
03114:      	P1=		#@sfx_ortable_10
03117:      	test		AX.b10
03118:      	if ZR jmp	@sfx_sextw_rets
03119:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL11:
0311A:      	P1=		#@sfx_ortable_11
0311D:      	test		AX.b11
0311E:      	if ZR jmp	@sfx_sextw_rets
0311F:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL12:
03120:      	P1=		#@sfx_ortable_12
03123:      	test		AX.b12
03124:      	if ZR jmp	@sfx_sextw_rets
03125:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL13:
03126:      	P1=		#@sfx_ortable_13
03129:      	test		AX.b13
0312A:      	if ZR jmp	@sfx_sextw_rets
0312B:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL14:
0312C:      	P1=		#@sfx_ortable_14
0312F:      	test		AX.b14
03130:      	if ZR jmp	@sfx_sextw_rets
03131:      	jmp		@sfx_orhigh_dx
            
            sfx_SignExtL15:
03132:      	test		AX.b15
03133:      	if ZR jmp	@sfx_sextw_rets
03134:      	DX=		-1
03135:      	rets
            
            sfx_SignExtL16:
03136:      	P1=		#@sfx_ortable_0
03139:      	test		DX.b0
0313A:      	if ZR jmp	@sfx_sextw_rets
0313B:      	jmp		@sfx_orhigh
            
            sfx_SignExtL17:
0313C:      	P1=		#@sfx_ortable_1
0313F:      	test		DX.b1
03140:      	if ZR jmp	@sfx_sextw_rets
03141:      	jmp		@sfx_orhigh
            
            sfx_SignExtL18:
03142:      	P1=		#@sfx_ortable_2
03145:      	test		DX.b2
03146:      	if ZR jmp	@sfx_sextw_rets
03147:      	jmp		@sfx_orhigh
            
            sfx_SignExtL19:
03148:      	P1=		#@sfx_ortable_3
0314B:      	test		DX.b3
0314C:      	if ZR jmp	@sfx_sextw_rets
0314D:      	jmp		@sfx_orhigh
            
            sfx_SignExtL20:
0314E:      	P1=		#@sfx_ortable_4
03151:      	test		DX.b4
03152:      	if ZR jmp	@sfx_sextw_rets
03153:      	jmp		@sfx_orhigh
            
            sfx_SignExtL21:
03154:      	P1=		#@sfx_ortable_5
03157:      	test		DX.b5
03158:      	if ZR jmp	@sfx_sextw_rets
03159:      	jmp		@sfx_orhigh
            
            sfx_SignExtL22:
0315A:      	P1=		#@sfx_ortable_6
0315D:      	test		DX.b6
0315E:      	if ZR jmp	@sfx_sextw_rets
0315F:      	jmp		@sfx_orhigh
            
            sfx_SignExtL23:
03160:      	P1=		#@sfx_ortable_7
03163:      	test		DX.b7
03164:      	if ZR jmp	@sfx_sextw_rets
03165:      	jmp		@sfx_orhigh
            
            sfx_SignExtL24:
03166:      	P1=		#@sfx_ortable_8
03169:      	test		DX.b8
0316A:      	if ZR jmp	@sfx_sextw_rets
0316B:      	jmp		@sfx_orhigh
            
            sfx_SignExtL25:
0316C:      	P1=		#@sfx_ortable_9
0316F:      	test		DX.b9
03170:      	if ZR jmp	@sfx_sextw_rets
03171:      	jmp		@sfx_orhigh
            
            sfx_SignExtL26:
03172:      	P1=		#@sfx_ortable_10
03175:      	test		DX.b10
03176:      	if ZR jmp	@sfx_sextw_rets
03177:      	jmp		@sfx_orhigh
            
            sfx_SignExtL27:
03178:      	P1=		#@sfx_ortable_11
0317B:      	test		DX.b11
0317C:      	if ZR jmp	@sfx_sextw_rets
0317D:      	jmp		@sfx_orhigh
            
            sfx_SignExtL28:
0317E:      	P1=		#@sfx_ortable_12
03181:      	test		DX.b12
03182:      	if ZR jmp	@sfx_sextw_rets
03183:      	jmp		@sfx_orhigh
            
            sfx_SignExtL29:
03184:      	P1=		#@sfx_ortable_13
03187:      	test		DX.b13
03188:      	if ZR jmp	@sfx_sextw_rets
03189:      	jmp		@sfx_orhigh
            
            sfx_SignExtL30:
0318A:      	P1=		#@sfx_ortable_14
0318D:      	test		DX.b14
0318E:      	if ZR jmp	@sfx_sextw_rets
0318F:      	jmp		@sfx_orhigh
            
            
            ; ~.~--------------------
            ; I1, AX
            
            sfx_REPMOV_SS:
            @sfx_repmov_ss_loop_1804:
03190:      	push		I1
03191:      	AR=		AX
03192:      	I1=		AR
03193:      	AR=		rm[I1]
03194:      	pop		I1
03195:      	rm[I1++]=	AR
03196:      	AX++
03197:      	loop		@sfx_repmov_ss_loop_1804
03198:      	rets
            
            ; ~~
            
            sfx_REPMOV_SR:
03199:      	AR=		AX
0319A:      	P1=		AR
            @sfx_repmov_sr_loop_1804:
0319B:      	rm[I1++]=	pm[P1++]
0319C:      	loop		@sfx_repmov_sr_loop_1804
0319D:      	rets
            
            
            ; ~~
            
            sfx_REPMOV_RS:
0319E:      	AR=		AX
0319F:      	I1=		AR
            @sfx_repmov_rs_loop_1804:
031A0:      	AR=		rm[I1++]
031A1:      	pm[P1++]=	AR
031A2:      	loop		@sfx_repmov_rs_loop_1804
031A3:      	rets
            
            ; ~~
            
            sfx_REPMOV_RR:
            @sfx_repmov_rr_loop_1804:
031A4:      	push		P1
031A5:      	AR=		AX
031A6:      	P1=		AR
031A7:      	AR=		pm[P1]
031A8:      	pop		P1
031A9:      	pm[P1++]=	AR
031AA:      	AX++
031AB:      	loop		@sfx_repmov_rr_loop_1804
031AC:      	rets
            
            ; ~~
            
            ; sfx_CHECKZERO:
            	; AR=		AX
            	; rets
            
            ; ~~
            
            ; sfx_CHECKZEROLONG:
            	; AR=		AX
            	; AR=		AR | DX
            	; rets
            
            ; ~~
            
            
            #ifdef PRAM_BANK
            
            ;  ~~ simple link list for PRAM allocate
            
            ;  +---------+---------+
            ;  | field 0 | field 1 |
            ;  +---------+---------+
            ;  |   PROM  |  next   |
            ;  +---------+---------+
            
            sfx_DynFastCallInit:
            ; {
            	P1.hh=		PRAM_BANK
            	P1=		PRAM_OFFSET
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	rets
            ; }
            
            
            ; ~~ for C / ASM progam compatible used
            
            ; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            ; bool sfx_DynFindPrg(PRGADR)
            ;
            ; in:
            ;    P1		- function start address
            ;
            ; out:
            ;     Z		- found, P0 = program entry address at PRAM
            ;     NZ	- not found, P0 = free space (list) start at PRAM
            ; ----------------------------------------------------------------
            
            sfx_DynFindPrg:
            ; {
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfp_loop_1320:
            	AR=		pm[P0++]	; program address
            	if ZR jmp	@sfxdfp_label_1321
            	SF=		AR - P1
            	if NE jmp	@sfxdfp_label_1323
            	
            	P0++
            	set		Z
            	rets
            
            @sfxdfp_label_1323:
            	AR=		pm[P0]		; next
            	P0=		0xFC00
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfp_label_1655
            	P0=		AR
            	jmp		@sfxdfp_loop_1320
            
            @sfxdfp_label_1321:
            	P0--				; list
            	clr		Z
            	rets
            	
            @sfxdfp_label_1655:
            ; ~~ list broken...
            	P0=		PRAM_OFFSET
            	clr		Z
            	rets
            ; }
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free link start
            ; AX = function end address
            
            
            sfx_DynBooking:
            ; {
            	; check if PRG to big to fit in PRAM
            
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	; ~~ can not cache PRG (total PRAM_SIZE) ??
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdb_label_1345
            
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdb_label_1349
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdb_label_1349:
            	; create link list
            
            	AR=		P1
            	pm[P0++]=	AR		; PRG
            	AR=		P0
            	AR=		AR - 3		; remove 1 list and 1 next
            	CX=		CX + AR
            	pm[P0++]=	CX		; next
            
            	push		P1
            	P1=		#@sfxdfc_label_1840
            	AR=		pm[P1]		; inst -> P1.hh = 0
            	pm[P0++]=	AR
            	AR=		CX
            	P1=		AR
            	P1.hh=		PRAM_BANK
            	AR=		0
            	pm[P1++]=	AR
            	pm[P1]=		AR
            	P1.hh=		0
            	pop		P1
            	
            	set		Z
            	rets
            
            @sfxdb_label_1345:
            	P0.hh=		0
            	clr		Z
            	rets
            ; }
            
            
            ; --------------------------------------------------------
            
            ; P1 = function start address
            ; P0 = free PRG entry
            ; AX = function end address
            
            sfx_DynCache:
            	push		P0
            	AR=		AX
            	AR=		AR - P1
            	CX=		AR
            	jmp		@sfxdynch_label_1650
            @sfxdynch_loop_1650:
            	AR=		pm[P1++]
            	pm[P0++]=	AR
            @sfxdynch_label_1650:
            	loop		@sfxdynch_loop_1650
            	pop		P0
            	P0--
            	rets
            
            ; --------------------------------------------------------
            
            
            ; ~~ for C
            
            ; P1 = function start address
            ; AX = function end address
            
            sfx_DynFastCall:
            ; {
            	; look up function entry by prom address (P1)
            
            	P0.hh=		PRAM_BANK
            	P0=		PRAM_OFFSET
            @sfxdfc_label_1759:
            	AR=		pm[P0++]		; next
            	if ZR jmp	@sfxdfc_label_1758
            	SF=		AR - P1
            	if EQ jmp	@sfxdfc_label_1722
            	AR=		pm[P0]
            	P0=		0xFC00
            	P0=		P0 & AR
            	if NZ jmp	@sfxdfc_label_2035
            	P0=		AR
            	jmp		@sfxdfc_label_1759
            
            @sfxdfc_label_2035:
            	P0=		PRAM_OFFSET + 1
            
            ; -----
            
            @sfxdfc_label_1758:
            
            	; look for remain free space
            	AR=		AX
            	AR=		AR - P1		; PRG length
            	AR=		AR + 5		; 2 list space + 1 inst (P0.hh = 0)
            	CX=		AR
            
            	P0--
            
            	AR=		PRAM_SIZE
            	SF=		AR - CX
            	if AN jmp	@sfxdfc_label_1840
            	
            	; ~~ look up remain free space
            
            	AR=		PRAM_OFFSET
            	AR=		P0 - AR
            	DX=		PRAM_SIZE
            	AR=		DX - AR
            
            	SF=		AR - CX
            	if GE jmp	@sfxdfc_label_1817
            
            	; ~~ reset link list
            
            	P0=		PRAM_OFFSET
            
            @sfxdfc_label_1817:
            
            	; copy program to pram
            
            	; ~~ PROM field
            		AR=		P1
            		pm[P0++]=	AR
            	; ~~ next field
            		AR=		P0
            		AR=		AR - 3		; remove 1 list and 1 next
            		CX=		CX + AR
            		pm[P0++]=	CX		; next
            
            	; ~~ booking
            		push		P1
            		P1=		#@sfxdfc_label_1840
            		AR=		pm[P1]		; inst -> P1.hh = 0
            		pm[P0++]=	AR
            		AR=		CX
            		P1=		AR
            		P1.hh=		PRAM_BANK
            		AR=		0
            		pm[P1++]=	AR
            		pm[P1]=		AR
            		P1.hh=		0
            		pop		P1
            
            	; copy instruction  "P0.hh = 0"
            		push		P0		; save exec address
            	@sfxdfc_loop_1829:
            		AR=		pm[P1++]
            		pm[P0++]=	AR
            		AR=		P0
            		SF=		AR - CX
            		if AN jmp	@sfxdfc_loop_1829
            		pop		P0
            		P0--
            		fjmp		pm[P0]
            
            @sfxdfc_label_1722:
            	P0++			; program entry
            	fjmp		pm[P0]
            
            @sfxdfc_label_1840:
            	P0.hh=		0
            
            @sfxdfc_label_1733:
            	; free space too small, direct run
            	fjmp		pm[P1]
            ; }
            
            
            
            
            #endif
            
            
            
            
            
            
            
            
            
            
            
            ;=========================Include <C:\TRITAN\FDSP-IDE\TOOLS\CC\CRT0\RUNTIME.ASM> End=========================
            
            
            
            // .code segment
            
            WAKEUP_PROC:
031AD:      	PCH=	SYS_PROG_ENTRY
031AE:      	ljmp	SYS_PROG_ENTRY
            
            IntVectTable:
031AF:      	DW #EMPTY_INTENTRY
031B0:      	DW #EMPTY_INTENTRY
031B1:      	DW #EMPTY_INTENTRY
031B2:      	DW #EMPTY_INTENTRY
031B3:      	DW #EMPTY_INTENTRY
031B4:      	DW #PWM_ENTRY
            
            // .code ends
            ;;FDSP-IDE V2.53
            _SYSTEM_MAIN_PROGRAM_END_ADDRESS: 
